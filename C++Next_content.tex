\documentclass[C++.tex]{subfiles}
\begin{document}

\section{Et ensuite ?}

\begin{frame}
	\frametitle{Présentation}
	\begin{itemize}
		\item C++20 ne marque pas la fin des évolutions du C++
		\item Plusieurs sujets proposés et non pris en compte dans les versions actuelles
		\item Plusieurs TS publiés et non intégrés ou en cours d'étude
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item Surcharge de l'opérateur point (\lstinline|operator.()|)
		\begin{itemize}
			\item Si l'opérateur est défini, les opérations sont transférés à son résultat
			\item \ldots{} sauf celles spécifiquement déclarées membres
			\item Réalisation de \og \textit{smart reference}\fg{} (p.ex. proxy)
		\end{itemize}
		\item Surcharge de \lstinline|operator?:|
		\item \textit{Unified Call Syntax}
		\begin{itemize}
			\item \lstinline|f(x,y)| appelle \lstinline|x.f(y)| si \lstinline|f(x,y)| n'est pas trouvé
			\item Généralisation de \lstinline|std::begin()| et co. directement dans le langage
		\end{itemize}
		\item \lstinline|std::expected| contenant un statut et une valeur optionnelle : retour d'un compte rendu d'exécution de la fonction et, éventuellement, d'une valeur

\note[item]{permet de se passer d'exception dans les contextes où elles ne sont pas adaptées, de ne pas utiliser un paramètre en sortie pour le statut ou la valeur et de ne pas définir des structures/classes ad-hoc tout en proposant une API plus adaptée que pair ou tuple}

		\item \textit{Procedural function interfaces} : framework pour la vérification statique de partie du programme

\note[item]{Annotations de types claim / assertion permettant à des outils d'analyse de vérifier la correction du programme}
\note[item]{Recouvre les points du TS contract mais est plus ambitieux}

		\item Support de l'Unicode
		\item Support des entrées/sorties audio
		\item Dépréciation de l'usage de l'opérateur virgule dans les expressions d'indiçage

\note[item]{C'est à dire de ne plus pouvoir écrire \lstinline|[x,y]| comme indice d'un conteneur classique}
\note[item]{L'expression \lstinline|[x,y]| revient à utiliser y comme indice mais en ayant évalué x}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item Ajout de nouveaux \og conteneurs\fg{}:
		\begin{itemize}
			\item Adaptateurs \lstinline|std::flat_map| et \lstinline|std::flat_multimap| : map depuis une paire de conteneurs séquentiels
			\item \lstinline|std::mdspan| : vues multidimensionnels (et indiçage associé \lstinline|[x,y,z]|)

\note[item]{La dépréciation de l'opérateur virgule dans les indices est un préalable à ce type de conteneur}
		\end{itemize}

		\item Nouveaux pointeurs intelligents :
		\begin{itemize}
			\item \lstinline|out_ptr| : manipulation de \lstinline|T**| en paramètres de retour des API C
			\item \lstinline|retain_ptr| : pointeur intrusif manipulant le comptage de référence interne d'un objet
		\end{itemize}
		\item Création de pointeurs intelligents avec une valeur par défaut
		\item Évolutions des opérateurs de comparaison et de \lstinline|operator<=>()|
		\begin{itemize}
			\item Dépréciation des conversions entre énumération et flottant
			\item Dépréciation des conversions entre énumérations
			\item Dépréciation de la comparaison \og \textit{two-way}\fg{} entre type tableau
			\item Comparaison \og \textit{three-way}\fg{} entre \textit{unscoped} énumération et type entier

\note[item]{\textit{unscoped} énumération, c'est à dire les \lstinline|enum| par opposition aux \lstinline|enum class|}

		\end{itemize}

		\item Gestion de la compatibilité ascendante via la configuration d'un \textit{epoch} au niveau d'un module pour activer des évolutions brisant la compatibilité

\note[item]{P.ex. si le standard C++23 supprimme les coversions implicites, il serait possible d'appliquer ce changement uniquement sur les modules déclarant \lstinline|epoch 2023|}

	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item \textit{Pattern matching} via \lstinline|inspect| :
	
		\begin{lstlisting}[language=C++]
inspect (p) {  		// std::pair
  [0, 0]: cout << "on origin";
  [0, y]: cout << "on y-axis";
  [x, 0]: cout << "on x-axis";
  [x, y]: cout << x << ',' << y;}

inspect (shape) {	// Sous-type
  (as<Circle> ? [r]): cout << 3.14 * r * r;
  (as<Rectangle> ? [w, h]): cout << w * h;}\end{lstlisting}

		\begin{block}{Mais aussi}
			Sur les types entiers, les chaînes, les \textit{tuples}, les \lstinline|std::variant|, \ldots
		\end{block}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item Ajout de \lstinline|volatile_load<T>| et \lstinline|volatile_store<T>|
		\item \textit{Compile Time Regular Expression}
		\item \lstinline|std::embed()| : rendre disponible au \textit{runtime} des ressources externes

\note[item]{P.ex. pour embarquer une image dans l'application}
\note[item]{Sans aller lire au \textit{runtime} le fichier contenant la ressource}
\note[item]{Et sans passer par des conversions externes vers des tableaux de \textit{bytes} injectés dans un fichier d'en-tête}

		\item Gestion des UUID
		\item Amélioration de la déduction template dans les constructeurs : agrégats, alias et constructeurs hérités

\note[item]{Terme normatif : \textit{Class Template Argument Deduction}}
\note[item]{Pas de déduction dans ces trois cas pour l'instant}

		\item Implémentations \textit{freestanding} : intégration du plus grand sous-ensemble possible de la bibliothèque standard qui ne présente pas de \textit{memory overhead} ni ne nécessite de support de l'OS

\note[item]{Actuellement le sous-ensemble de la bibliothèque standard proposé est \textit{implementation-defined}}

		\item \textit{Layout} des classes
		\begin{itemize}
			\item Suppression de la possibilité donné au compilateur de réordonner les membres ayant des visibilités différentes
			\item Contrôle du \textit{layout} via un attribut permettant de privilégier la taille, la vitesse ou l'ordre de déclaration
		\end{itemize}

\note[item]{Deux propositions différentes, mais pas incompatibles}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item Méta-classes pour construire des types de classes (dont les classes elles-mêmes) ayant des contraintes, des comportements par défaut et des opérations par défaut (\lstinline|class|, \lstinline|struct|, \lstinline|enum class|, \textit{interface}, \textit{value})
		\item Répétition compile-time d'une expression : \textit{Expansion statement}
		
			\begin{lstlisting}[language=C++]
auto foo = make_tuple(0, 'a', 3.14);
for... (auto elem : tup)  
  cout << elem << "\n"\end{lstlisting}
			
			\begin{itemize}
				\item Pas une boucle : duplication de l'expression pour chaque élément
				\item Éléments de type différent
				\item Utilisable sur \lstinline|std::tuple|, \lstinline|std::array|, classes destructurables, \ldots
			\end{itemize}
		\item Exceptions légères

\note[item]{Appelées \textit{Zero-overhead deterministic exceptions}}

		\item Ajout \textit{floating-point types} de plus petite taille
		\item Réservation des attributs globaux et de l'espace de nom d'attributs \lstinline|std|
		\item Changement de contexte \textit{stackful} : \lstinline|fiber_context|
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item Utilisation de \textit{parameters pack} dans les \textit{structures bindings}

			\begin{lstlisting}[language=C++]
std::tuple<X, Y, Z> f();

auto [...xs] = f();
auto [x, ...rest] = f();
auto [x,y,z, ...rest] = f();
auto [x, ...rest, z] = f();
auto [...a, ...b] = f();  // ill-formed\end{lstlisting}

\note[item]{Proche dans l'esprit de ce qui se fait en Python 3}

		\item Accès bas-niveau aux IO : \lstinline|file_handle| et \lstinline|path_handle|
		\item Gestion des processus, de la communication avec ceux-ci et des \textit{pipes}
		\item invocation concurrente
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item Parsing de texte
			\begin{itemize}
				\item Pendant du formatage de texte introduit en C++20
				\item Alternative sûr, robuste à \lstinline|sscanf()|
				\item Extensible aux types utilisateurs
				\item Compatible avec les itérateurs et les \textit{ranges}
			\end{itemize}

			\begin{lstlisting}[language=C++]
string key;
int value;
scan("answer = 42", "{} = {}", key, value);
//    ~~~~~~~~~~~~~  ~~~~~~~~~  ~~~~~~~~~~
//        entree       format    arguments
// key : "answer", value : 42\end{lstlisting}

			\begin{lstlisting}[language=C++]
string key;
chrono::seconds time;
scan("start = 10:30", "{0} = {1:%H:%M}", key, time);\end{lstlisting}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item Algèbre linéaire basé sur un sous-ensemble de \href{https://www.netlib.org/blas/}{BLAS} (vecteur, matrice, \ldots)
		\item Support des unités physiques :
		\begin{itemize}
			\item Gestion des quantités et dimensions
			\item Supports des unités de base, dérivées, des multiples et des sous-multiples
			\item Conversion et opérations entre unités
		\end{itemize}

		\begin{lstlisting}[language=C++]
static_assert(10km / 2 == 5km);

static_assert(1h == 3600s);
static_assert(1km + 1m == 1001m);

static_assert(1km / 1s == 1000mps);
static_assert(2kmph * 2h == 4km);
static_assert(2km / 2kmph == 1h);

static_assert(1000 / 1s == 1kHz);

static_assert(10km / 5km == 2);\end{lstlisting}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item Manipulation des nombres
		\begin{itemize}
			\item Détection et gestion des débordements
			\item Gestion des arrondis
			\item Entiers larges
			\item Rationnel
			\item \textit{Proxy} pour manipuler la représentation interne des entiers
		\end{itemize}
		\item Concept pour les algorithmes numériques
		\item \lstinline|constexpr| dans la bibliothèque standard (\lstinline|std::list|, \lstinline|std::deque|, \ldots)

\note[item]{Poursuite de la prise en compte menée dans les versions précédentes}

		\item \lstinline|std::breakpoint| : point d'arrêt de debug dans le programme
		\item Support des \textit{executor}
		\item Unification et amélioration des API asynchrones

\note[item]{Qu'il s'agisse de coroutines, d'algorithmes paralléles, d'\textit{executor} ou autre}

	\end{itemize}
\end{frame}


\begin{frame}
	\frametitle{TS - Contracts}
	\begin{itemize}
		\item Retiré du draft C++20 et création d'un groupe d'étude en juillet 2019

\note[item]{Ne sera donc finalement pas en C++20, probablement en 2023}

		\item Support de la programmation par contrat
		\item Remplacement de la vérification à coup d'assert et de la documentation via commentaire @pre, @post et @invariant
		\item Initialement, plusieurs propositions \og concurrentes\fg{}
		\item \ldots{}mais un compromis à émerger
		\item Utilisation d'attributs \lstinline|[[assert:x]], |\lstinline|[[expects:x]]| et \lstinline|[[ensure:x]]|

\note[item]{\lstinline|[[assert:x]]| : invariants et autres vérifications}
\note[item]{\lstinline|[[expects:x]]| : préconditions}
\note[item]{\lstinline|[[ensure:x]]| : postconditions}

		\item Possibilité de les marquer \lstinline|audit| pour ne les activer qu'à la demande
		\item Possibilité de les marquer \lstinline|axiom| pour ne pas générer de code \textit{runtime} (\textit{compile-time} uniquement)
		\item Les contrats de fonctions membres publiques peuvent utiliser des membres privés ou protégés
		\item Intégration des contrats à la bibliothèque standard
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{TS - Networking TS}
	\begin{itemize}
		\item Publié en avril 2018
		\item Très probablement intégré à C++23
		\item Partiellement basé sur Boost.Asio
		\item Modèle asynchrone
		\item Gestion de timer
		\item Gestion de buffer et de flux orientés buffer
		\item Gestion de sockets et de flux \og socket\fg{}
		\item Gestion d'IPv4, IPv6, TCP, UDP
		\item Manipulation d'adresses IP
		\item Pas de protocoles de plus haut niveau actuellement
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{TS - Les autres\titlehfill{}1/2}
	\begin{itemize}
		\item \textit{Library fundamentals 2} : évolutions de la bibliothèque standard
		\begin{itemize}

\note[item]{Les listes de fonctionnalités des TS ne sont pas exhaustives}

			\item Pointeurs intelligents non possédant
			\item Nouveaux algorithmes

		\end{itemize}
		\item \textit{Library fundamentals 3} :
		\begin{itemize}
			\item \textit{Generic Scope Guard}
			\item \textit{RAII wrapper}
		\end{itemize}
	
		\item \textit{Parallelism} 2 : publié en juin 2018
		\item \textit{Transactional Memory} : publié
		\item \textit{Numerics}
		\item \textit{Array extension} : taille non connue à la compilation
		\item \textit{2D Graphics} (io2d) : API C++ au dessus de Cairo, différé

\note[item]{Mais le projet io2d en lui-même continue}
\note[item]{Le comité ne voit pas d'intérêt à poursuivre les travaux sur les aspects graphiques pour le moment}

		\item \lstinline|std::web_view| API fournissant une fenêtre dans laquelle le programme peut injecter des composants web (ou être appelé via \textit{callback})
		\item \textit{Reflection} : \textit{feature-complete}, TS en \og C++20\fg{}, probablement en C++ 23

\note[item]{Plusieurs sujets derrière ceci : réflexion statique, métaprogrammation, code compile-time, génération et injection, métaclasses, \ldots}
\note[item]{Dans un premier temps, il s'agit de réflexion statique}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{TS - Les autres\titlehfill{}2/2}
	\begin{itemize}
		\item \textit{Concurrency} 1 : publié
		\begin{itemize}
			\item \lstinline|future.then()|
		\end{itemize}
		\item \textit{Concurrency} 2
		\begin{itemize}
			\item \textit{Synchronic} : meilleure abstraction pour atomique permettant de tirer partie des caractéristiques logicielles et matérielles de la plateforme
			\item \textit{Executor} permettant de spécifier où s'exécute telle tâche (\textit{a priori} pour C++23)
		\end{itemize}
	\end{itemize}
\end{frame}
\end{document}