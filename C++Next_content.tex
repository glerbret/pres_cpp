\documentclass[C++.tex]{subfiles}
\begin{document}

\section{Et ensuite ?}

\begin{frame}
	\frametitle{Présentation}
	\begin{itemize}
		\item C++20 ne marque pas la fin des évolutions du C++
		\item Plusieurs sujets proposés et non pris en compte dans les versions actuelles
		\item Plusieurs TS publiés et non intégrés ou en cours d'étude
		\item Des évolutions dans l'organisation
		\begin{itemize}
			\item Création d'un ABI Review Group en charge de l'étude des impacts sur l'ABI des évolutions
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item Surcharge de l'opérateur point (\lstinline|operator.()|)
		\begin{itemize}
			\item Si l'opérateur est défini, les opérations sont transférés à son résultat
			\item \ldots{} sauf celles spécifiquement déclarées membres
			\item Réalisation de \og \textit{smart reference}\fg{} (p.ex. proxy)
		\end{itemize}
		\item Surcharge de \lstinline|operator?:|
		\item \textit{Unified Call Syntax}
		\begin{itemize}
			\item \lstinline|f(x,y)| appelle \lstinline|x.f(y)| si \lstinline|f(x,y)| n'est pas trouvé
			\item Généralisation de \lstinline|std::begin()| et co. directement dans le langage
		\end{itemize}
		\item \lstinline|std::expected| contenant un statut et une valeur optionnelle : retour d'un compte rendu d'exécution de la fonction et, éventuellement, d'une valeur

\note[item]{permet de se passer d'exception dans les contextes où elles ne sont pas adaptées, de ne pas utiliser un paramètre en sortie pour le statut ou la valeur et de ne pas définir des structures/classes ad-hoc tout en proposant une API plus adaptée que pair ou tuple}

		\item \textit{Procedural function interfaces} : framework pour la vérification statique de partie du programme

\note[item]{Annotations de types claim / assertion permettant à des outils d'analyse de vérifier la correction du programme}
\note[item]{Recouvre les points du TS contract mais est plus ambitieux}

		\item Support de l'Unicode
		\item Support des entrées/sorties audio
		\item Dépréciation de l'usage de l'opérateur virgule dans les expressions d'indiçage

\note[item]{C'est à dire de ne plus pouvoir écrire \lstinline|[x,y]| comme indice d'un conteneur classique}
\note[item]{L'expression \lstinline|[x,y]| revient à utiliser y comme indice mais en ayant évalué x}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item Ajout de nouveaux \og conteneurs\fg{}:
		\begin{itemize}
			\item Adaptateurs \lstinline|std::flat_map| et \lstinline|std::flat_multimap| : map depuis une paire de conteneurs séquentiels
			\item \lstinline|std::mdspan| : vues multidimensionnels (et indiçage associé \lstinline|[x,y,z]|)

\note[item]{La dépréciation de l'opérateur virgule dans les indices est un préalable à ce type de conteneur}
		\end{itemize}

		\item Nouveaux pointeurs intelligents :
		\begin{itemize}
			\item \lstinline|out_ptr| : manipulation de \lstinline|T**| en paramètres de retour des API C
			\item \lstinline|retain_ptr| : pointeur intrusif manipulant le comptage de référence interne d'un objet
		\end{itemize}
		\item Création de pointeurs intelligents avec une valeur par défaut
		\item Évolutions des opérateurs de comparaison et de \lstinline|operator<=>()|
		\begin{itemize}
			\item Dépréciation des conversions entre énumération et flottant
			\item Dépréciation des conversions entre énumérations
			\item Dépréciation de la comparaison \og \textit{two-way}\fg{} entre type tableau
			\item Comparaison \og \textit{three-way}\fg{} entre \textit{unscoped} énumération et type entier

\note[item]{\textit{unscoped} énumération, c'est à dire les \lstinline|enum| par opposition aux \lstinline|enum class|}

		\end{itemize}

		\item Gestion de la compatibilité ascendante via la configuration d'un \textit{epoch} au niveau d'un module pour activer des évolutions brisant la compatibilité

\note[item]{P.ex. si le standard C++23 supprimme les coversions implicites, il serait possible d'appliquer ce changement uniquement sur les modules déclarant \lstinline|epoch 2023|}

	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item \textit{Pattern matching} via \lstinline|inspect| :
		\begin{itemize}
			\item Sur des entiers

			\begin{lstlisting}[language=C++]
inspect (x) {
  0  : cout << "Aucun";
  1  : cout << "Un";
  __ : cout << "Plusieurs"; }\end{lstlisting}

\note[item]{Proche dans l'esprit de \lstinline|switch/case| avec une syntaxe plus légère et sans \textit{fallback}}

			\item Sur des chaînes

			\begin{lstlisting}[language=C++]
inspect (x) {
  "zero": cout << "Aucun";
  "un"  : cout << "Un";
  __    : cout << "Plusieurs";\end{lstlisting}
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item \textit{Pattern matching} via \lstinline|inspect| :
		\begin{itemize}
			\item Sur des \textit{tuple-like}

\note[item]{\lstinline|std::tuple|, \lstinline|std::pair|, \lstinline|std::array|, aggrégats et les classes implémentant l'interface \textit{tuple}}

			\begin{lstlisting}[language=C++]
inspect (p) {
  [0, 0]: cout << "on origin";
  [0, y]: cout << "on y-axis";
  [x, 0]: cout << "on x-axis";
  [x, y]: cout << x << ',' << y;}\end{lstlisting}

			\item Sur les \lstinline|std::variant| et \lstinline|std::any|

			\begin{lstlisting}[language=C++]
inspect (v) {
<int> i  : cout << "Entier " << i;
<float> f: cout << "Reel " << f;\end{lstlisting}
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item \textit{Pattern matching} via \lstinline|inspect| :
		\begin{itemize}
			\item Sur les types polymorphiques

			\begin{lstlisting}[language=C++]
inspect (shape) {
  <Circle> [r]      : cout << 3.14 * r * r;
  <Rectangle> [w, h]: cout << w * h;}\end{lstlisting}

\note[item]{Alternative bienvenue aux enfilades de \lstinline|dynamic_cast|}

			\item Version sous forme d'expressions

\note[item]{Et non de \textit{statement}}

			\begin{lstlisting}[language=C++]
int get_area(const Shape& shape) {
  return inspect (shape) {
    <Circle> [r]       => cout << 3.14 * r * r;
    <Rectangle> [w, h] => cout << w * h;} }\end{lstlisting}
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item \textit{Pattern matching} via \lstinline|inspect| :
		\begin{itemize}
			\item Avec une garde

			\begin{lstlisting}[language=C++]
inspect (p) {
  [x, y] if(x > y): cout << x << "superieur a" << y;\end{lstlisting}

			\item Et bien d'autres fonctionnalités \ldots
		\end{itemize}
	\end{itemize}

	\begin{alertblock}{Attention}
		Prise en compte de la première correspondance et non de la meilleure

\note[item]{Mais ça peut changer d'ici l'acceptation dans le standard}
	\end{alertblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item Ajout de \lstinline|volatile_load<T>| et \lstinline|volatile_store<T>|
		\item \textit{Compile Time Regular Expression}
		\item \lstinline|std::embed()| : rendre disponible au \textit{runtime} des ressources externes

\note[item]{P.ex. pour embarquer une image dans l'application}
\note[item]{Sans aller lire au \textit{runtime} le fichier contenant la ressource}
\note[item]{Et sans passer par des conversions externes vers des tableaux de \textit{bytes} injectés dans un fichier d'en-tête}

		\item Gestion des UUID
		\item Amélioration de la déduction template dans les constructeurs : agrégats, alias et constructeurs hérités

\note[item]{Terme normatif : \textit{Class Template Argument Deduction}}
\note[item]{Pas de déduction dans ces trois cas pour l'instant}

		\item Implémentations \textit{freestanding} : intégration du plus grand sous-ensemble possible de la bibliothèque standard qui ne présente pas de \textit{memory overhead} ni ne nécessite de support de l'OS

\note[item]{Actuellement le sous-ensemble de la bibliothèque standard proposé est \textit{implementation-defined}}

		\item \textit{Layout} des classes
		\begin{itemize}
			\item Suppression de la possibilité donné au compilateur de réordonner les membres ayant des visibilités différentes

\note[item]{Au sein d'une visibilité, les membres doivent conserver leur ordre}
\note[item]{En pratique, cette liberté n'est pas utilisée par les compilateurs}

			\item Contrôle du \textit{layout} pour privilégier la taille ou l'ordre de déclaration
			\item Voire la vitesse, l'ordre alphabétique ou les lignes de cache
			\item Contrôle de l'alignement (remplaçant de \lstinline|#pragma pack(N)|)
		\end{itemize}

\note[item]{Deux propositions différentes mais pas incompatibles. La première étant en fait un prérequis}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item Méta-classes pour construire des types de classes (dont les classes elles-mêmes) ayant des contraintes, des comportements par défaut et des opérations par défaut (\lstinline|class|, \lstinline|struct|, \lstinline|enum class|, \textit{interface}, \textit{value})
		\item Répétition compile-time d'une expression : \textit{Expansion statement}
		
			\begin{lstlisting}[language=C++]
auto foo = make_tuple(0, 'a', 3.14);
for... (auto elem : tup)  
  cout << elem << "\n"\end{lstlisting}
			
			\begin{itemize}
				\item Pas une boucle : duplication de l'expression pour chaque élément
				\item Éléments de type différent
				\item Utilisable sur \lstinline|std::tuple|, \lstinline|std::array|, classes destructurables, \ldots
			\end{itemize}
		\item Exceptions légères

\note[item]{Appelées \textit{Zero-overhead deterministic exceptions}}

		\item Ajout \textit{floating-point types} de plus petite taille
		\item Réservation des attributs l'espace de noms global d'attribut globaux et de l'espace de nom d'attributs \lstinline|std|
		\item Changement de contexte \textit{stackful} : \lstinline|fiber_context|
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item Utilisation de \textit{parameters pack} dans les \textit{structures bindings}

			\begin{lstlisting}[language=C++]
std::tuple<X, Y, Z> f();

auto [...xs] = f();
auto [x, ...rest] = f();
auto [x,y,z, ...rest] = f();
auto [x, ...rest, z] = f();
auto [...a, ...b] = f();  // ill-formed\end{lstlisting}

\note[item]{Proche dans l'esprit de ce qui se fait en Python 3}

		\item Accès bas-niveau aux IO : \lstinline|file_handle| et \lstinline|path_handle|
		\item Gestion des processus, de la communication avec ceux-ci et des \textit{pipes}
		\item invocation concurrente
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item Parsing de texte
			\begin{itemize}
				\item Pendant du formatage de texte introduit en C++20
				\item Alternative sûr, robuste à \lstinline|sscanf()|
				\item Extensible aux types utilisateurs
				\item Compatible avec les itérateurs et les \textit{ranges}
			\end{itemize}

			\begin{lstlisting}[language=C++]
string key;
int value;
scan("answer = 42", "{} = {}", key, value);
//    ~~~~~~~~~~~~~  ~~~~~~~~~  ~~~~~~~~~~
//        entree       format    arguments
// key : "answer", value : 42\end{lstlisting}

			\begin{lstlisting}[language=C++]
string key;
chrono::seconds time;
scan("start = 10:30", "{0} = {1:%H:%M}", key, time);\end{lstlisting}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item Algèbre linéaire basé sur un sous-ensemble de \href{https://www.netlib.org/blas/}{BLAS} (vecteur, matrice, \ldots)
		\item Support des unités physiques :
		\begin{itemize}
			\item Gestion des quantités et dimensions
			\item Supports des unités de base, dérivées, des multiples et des sous-multiples
			\item Conversion et opérations entre unités
		\end{itemize}

		\begin{lstlisting}[language=C++]
static_assert(10km / 2 == 5km);

static_assert(1h == 3600s);
static_assert(1km + 1m == 1001m);

static_assert(1km / 1s == 1000mps);
static_assert(2kmph * 2h == 4km);
static_assert(2km / 2kmph == 1h);

static_assert(1000 / 1s == 1kHz);

static_assert(10km / 5km == 2);\end{lstlisting}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item Concept pour les algorithmes numériques
		\item \lstinline|constexpr| dans la bibliothèque standard (\lstinline|std::list|, \lstinline|std::deque|, \ldots)

\note[item]{Poursuite de la prise en compte menée dans les versions précédentes}

		\item \lstinline|std::breakpoint| : point d'arrêt de debug dans le programme
		\item \textit{Executor} : abstraction gérant où et comment s'exécute un code dans un environnement concurrent
		\item Unification et amélioration des API asynchrones

\note[item]{Qu'il s'agisse de coroutines, d'algorithmes paralléles, d'\textit{executor} ou autre}

		\item \lstinline|std::web_view| API fournissant une fenêtre dans laquelle le programme peut injecter des composants web (ou être appelé via \textit{callback})
		\item Autoriser les conversions entiers vers booléens dans les \lstinline|static_assert| et \lstinline|if constexpr|
		\item Constructeur par déplacement \lstinline|=relocates| : similaire à \lstinline|=default| avec la garantie de pouvoir remplacer \og déplacement puis destruction\fg{} par des appels à \lstinline|memcpy() |

\note[item]{Donc de permettre des optimisations aux compilateurs}

	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item Attribut \lstinline|assume(expression)| indique que l'expression est vraie et que le compilateur peut utiliser cette hypothèse dans ses optimisations
		\item PFA (\textit{Proxy}, \textit{Facade}, \textit{Addresser}) : programmation polymorphique via \textit{type erasure}

\note[item]{Alternative à la POO et programmation fonctionnelle éliminant certaines de leurs limites}

		\item Interdiction de l'appel de \lstinline|operator=()| sur des temporaires

\note[item]{Ce n'est pas permis sur les types built-in mais possible sur les autres, avec tous les problèmes que ça peut poser}

		\item Retarder l'échec de \lstinline|static_assert(false)| dans des contextes template jusqu'à l'instanciation

		\begin{lstlisting}[language=C++]
template<typenameT>int my_func(constT&) {
  if constexpr(is_integral_v<T>) { 
    return 1; } 
  else if constexpr(is_convertible_v<string, T>) { 
    return 2 ;}
  else {
    // C++20 : echec de compilation systematique
    static_assert(false); } }\end{lstlisting}

\note[item]{Erreur en C++20 et précédent. L'idée est de traiter le \lstinline|static_assert| à l'instanciation et donc de n'échouer que si le paramètre template n'est convertible ni en entier ni en chaîne}

	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item Généralisation et simplification des \textit{variadic templates} (\textit{pack})
		\begin{itemize}
			\item Déclaration possible partout où une variable peut être déclarée

			\begin{lstlisting}[language=C++]
template <typename... Ts>
struct tuple { Ts... elems; };\end{lstlisting}

			\item Indexation des \textit{packs}

			\begin{lstlisting}[language=C++]
struct tuple_element<I, tuple<Ts...>> {
  using type = Ts...[I]; };\end{lstlisting}

			\item \og \textit{Unpack}\fg{} de \lstinline|std::tuple| à la volée

			\begin{lstlisting}[language=C++]
int sum(int x, int y, int z) { return x + y + z; }

tuple<int, int, int> point{1, 2, 3};
int s = sum(point.elems...);\end{lstlisting}

		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Propositions diverses}
  \begin{itemize}
	\item Possibilité d'instancier certains template au runtime (JIT limité aux templates)

\note[item]{P.ex. pour des matrices dont la taille n'est pas connue à la compilation}

	\item Mécanismes pour vérifier à la compilation qu'un type à la même représentation mémoire  qu'un autre

\note[item]{P.ex. une structure de deux \lstinline|float| et un tableau de deux \lstinline|float|}

	\item Voire pour forcer à avoir la représentation du type cible
  \end{itemize}
\end{frame}

\begin{frame}
	\frametitle{TS - Contracts}
	\begin{itemize}
		\item Retiré du draft C++20 et création d'un groupe d'étude en juillet 2019

\note[item]{Ne sera donc finalement pas en C++20, probablement en 2023}

		\item Support de la programmation par contrat
		\item Remplacement de la vérification à coup d'assert et de la documentation via commentaire @pre, @post et @invariant
		\item Initialement, plusieurs propositions \og concurrentes\fg{}
		\item \ldots{}mais un compromis à émerger
		\item Utilisation d'attributs \lstinline|[[assert:x]], |\lstinline|[[expects:x]]| et \lstinline|[[ensure:x]]|

\note[item]{\lstinline|[[assert:x]]| : invariants et autres vérifications}
\note[item]{\lstinline|[[expects:x]]| : préconditions}
\note[item]{\lstinline|[[ensure:x]]| : postconditions}

		\item Possibilité de les marquer \lstinline|audit| pour ne les activer qu'à la demande
		\item Possibilité de les marquer \lstinline|axiom| pour ne pas générer de code \textit{runtime} (\textit{compile-time} uniquement)
		\item Les contrats de fonctions membres publiques peuvent utiliser des membres privés ou protégés
		\item Intégration des contrats à la bibliothèque standard
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{TS - Networking TS}
	\begin{itemize}
		\item Publié en avril 2018
		\item Très probablement intégré à C++23
		\item Partiellement basé sur Boost.Asio
		\item Modèle asynchrone
		\item Gestion de timer
		\item Gestion de buffer et de flux orientés buffer
		\item Gestion de sockets et de flux \og socket\fg{}
		\item Gestion d'IPv4, IPv6, TCP, UDP
		\item Manipulation d'adresses IP
		\item Pas de protocoles de plus haut niveau actuellement
		\item Gestion de la sécurité (demande post-TS)
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{TS - Les autres\titlehfill{}1/2}
	\begin{itemize}
		\item \textit{Library fundamentals 2} : évolutions de la bibliothèque standard
		\begin{itemize}

\note[item]{Les listes de fonctionnalités des TS ne sont pas exhaustives}

			\item Pointeurs intelligents non possédant
			\item Nouveaux algorithmes

		\end{itemize}
		\item \textit{Library fundamentals 3} :
		\begin{itemize}
			\item \textit{Generic Scope Guard}
			\item \textit{RAII wrapper}
		\end{itemize}
	
		\item \textit{Parallelism} 2 : publié en juin 2018
		\item \textit{Transactional Memory} : publié
		\item \textit{Numerics}: manipulation des nombres
		\begin{itemize}
			\item Détection et gestion des débordements
			\item Gestion des arrondis
			\item Entiers larges
			\item Rationnel
			\item \textit{Proxy} pour manipuler la représentation interne des entiers
		\end{itemize}
	
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{TS - Les autres\titlehfill{}2/2}
	\begin{itemize}
		\item \textit{Array extension} : taille non connue à la compilation
		\item \textit{2D Graphics} (io2d) : API C++ au dessus de Cairo, différé

\note[item]{Mais le projet io2d en lui-même continue}
\note[item]{Le comité ne voit pas d'intérêt à poursuivre les travaux sur les aspects graphiques pour le moment}

		\item \textit{Reflection} : \textit{feature-complete}, TS en \og C++20\fg{}, probablement en C++ 23

\note[item]{Plusieurs sujets derrière ceci : réflexion statique, métaprogrammation, code compile-time, génération et injection, métaclasses, \ldots}
\note[item]{Dans un premier temps, il s'agit de réflexion statique}

		\item \textit{Reflection V2}

		\item \textit{Concurrency} 1 : publié
		\begin{itemize}
			\item \lstinline|future.then()|
		\end{itemize}
		\item \textit{Concurrency} 2
		\begin{itemize}
			\item \textit{Synchronic} : meilleure abstraction pour atomique permettant de tirer partie des caractéristiques logicielles et matérielles de la plateforme
			\item \textit{Executor} permettant de spécifier où s'exécute telle tâche (\textit{a priori} pour C++23)
		\end{itemize}
	\end{itemize}
\end{frame}
\end{document}