\documentclass[C++.tex]{subfiles}
\begin{document}

\section{Et ensuite ?}

\begin{frame}
	\frametitle{Présentation}
	\begin{itemize}
		\item C++20 ne marque pas la fin des évolutions du C++
		\item Plusieurs sujets proposés et non pris en compte dans les versions actuelles
		\item Plusieurs TS publiés et non intégrés ou en cours d'étude
		\item Des évolutions dans l'organisation
		\begin{itemize}
			\item Création d'un \textit{ABI Review Group} en charge de l'étude des impacts sur l'ABI des évolutions
			\item Processus d'évaluation des propositions d'évolutions pour réduire le risque d'erreur
			\item Groupe \textit{Undefined Behavior} dont le rôle est de documenter les comportements \textit{undefined} et \textit{unspecified}
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item Surcharge de l'opérateur point (\lstinline|operator.()|)
		\begin{itemize}
			\item Si l'opérateur est défini, les opérations sont transférés à son résultat
			\item \ldots{} sauf celles spécifiquement déclarées membres
			\item Réalisation de \textit{smart reference} (p.ex. \textit{proxy})
		\end{itemize}
		\item Surcharge de \lstinline|operator?:|
		\item \textit{Unified Call Syntax}
		\begin{itemize}
			\item \lstinline|f(x,y)| appelle \lstinline|x.f(y)| si \lstinline|f(x,y)| n'est pas trouvé
			\item Généralisation de \lstinline|std::begin()| et co. directement dans le langage
		\end{itemize}
		\item \lstinline|std::expected| contenant un statut et une valeur optionnelle : retour d'un compte rendu d'exécution de la fonction et, éventuellement, d'une valeur

\note[item]{permet de se passer d'exception dans les contextes où elles ne sont pas adaptées, de ne pas utiliser un paramètre en sortie pour le statut ou la valeur et de ne pas définir des structures/classes ad hoc tout en proposant une API plus adaptée que \lstinline|std::pair| ou \lstinline|std::tuple|}

		\item \textit{Procedural function interfaces} : \textit{framework} pour la vérification statique de partie du programme

\note[item]{Annotations de types claim / assertion permettant à des outils d'analyse de vérifier la correction du programme}
\note[item]{Recouvre les points du TS \textit{contract} mais est plus ambitieux}

		\item Support des entrées/sorties audio
		\item Dépréciation de l'usage de l'opérateur virgule dans les expressions d'indiçage

\note[item]{C'est à dire de ne plus pouvoir écrire \lstinline|[x,y]| comme indice d'un conteneur classique}
\note[item]{L'expression \lstinline|[x,y]| revient à utiliser y comme indice mais en ayant évalué x}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item Ajout de nouveaux \og conteneurs\fg{}:
		\begin{itemize}
			\item Adaptateurs \lstinline|std::flat_map| et \lstinline|std::flat_multimap| : \lstinline|map| depuis une paire de conteneurs séquentiels
			\item \lstinline|std::mdspan| : vues multidimensionnels (et indiçage associé \lstinline|[x,y,z]|)

\note[item]{La dépréciation de l'opérateur virgule dans les indices est un préalable à ce type de conteneur}

			\item \lstinline|std::static_vector| : \lstinline|vector| de capacité fixée en \textit{compile-time}

\note[item]{Par rapport à \lstinline|std::array| : la taille n'est pas fixée, seulement la capacité et donc utilisable pour des éléments \og sans valeur par défaut\fg{}}

			\item \lstinline|queue| concurrente
		\end{itemize}

		\item Nouveaux pointeurs intelligents :
		\begin{itemize}
			\item \lstinline|out_ptr| : manipulation de \lstinline|T**| en paramètres de retour des API C
			\item \lstinline|retain_ptr| : pointeur intrusif manipulant le comptage de référence interne d'un objet
		\end{itemize}
		\item Création de pointeurs intelligents avec une valeur par défaut
		\item Évolutions des opérateurs de comparaison et de \lstinline|operator<=>()|
		\begin{itemize}
			\item Dépréciation des conversions entre énumération et flottant
			\item Dépréciation des conversions entre énumérations
			\item Dépréciation de la comparaison \og \textit{two-way}\fg{} entre type tableau
			\item Comparaison \textit{three-way} entre \textit{unscoped} énumération et type entier

\note[item]{\textit{unscoped} énumération, c'est à dire les \lstinline|enum| par opposition aux \lstinline|enum class|}

		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item \textit{Pattern matching} via \lstinline|inspect| :
		\begin{itemize}
			\item Entiers

			\begin{lstlisting}[language=C++]
inspect (x) {
  0  : cout << "Aucun";
  1  : cout << "Un";
  __ : cout << "Plusieurs"; }\end{lstlisting}

\note[item]{Proche dans l'esprit de \lstinline|switch/case| avec une syntaxe plus légère et sans \textit{fallback}}

			\item Chaînes de caractères

			\begin{lstlisting}[language=C++]
inspect (x) {
  "zero": cout << "Aucun";
  "un"  : cout << "Un";
  __    : cout << "Plusieurs";\end{lstlisting}
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item \textit{Pattern matching} via \lstinline|inspect| :
		\begin{itemize}
			\item \textit{Tuple-like}

\note[item]{\lstinline|std::tuple|, \lstinline|std::pair|, \lstinline|std::array|, agrégats et les classes implémentant l'interface \textit{tuple}}

			\begin{lstlisting}[language=C++]
inspect (p) {
  [0, 0]: cout << "on origin";
  [0, y]: cout << "on y-axis";
  [x, 0]: cout << "on x-axis";
  [x, y]: cout << x << ',' << y;}\end{lstlisting}

			\item \lstinline|std::variant| et \lstinline|std::any|

			\begin{lstlisting}[language=C++]
inspect (v) {
<int> i  : cout << "Entier " << i;
<float> f: cout << "Reel " << f;\end{lstlisting}
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item \textit{Pattern matching} via \lstinline|inspect| :
		\begin{itemize}
			\item Types polymorphiques

			\begin{lstlisting}[language=C++]
inspect (shape) {
  <Circle> [r]      : cout << 3.14 * r * r;
  <Rectangle> [w, h]: cout << w * h;}\end{lstlisting}

\note[item]{Alternative bienvenue aux enfilades de \lstinline|dynamic_cast|}

			\item Variante sous forme d'expressions (et non de \textit{statement})

			\begin{lstlisting}[language=C++]
int get_area(const Shape& shape) {
  return inspect (shape) {
    <Circle> [r]       => 3.14 * r * r;
    <Rectangle> [w, h] => w * h;} }\end{lstlisting}
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item \textit{Pattern matching} via \lstinline|inspect| :
		\begin{itemize}
			\item Support des gardes

			\begin{lstlisting}[language=C++]
inspect (p) {
  [x, y] if(x > y): cout << x << "superieur a" << y;\end{lstlisting}

			\item Et bien d'autres fonctionnalités \ldots
		\end{itemize}
	\end{itemize}

	\begin{alertblock}{Attention}
		Prise en compte de la première correspondance et non de la meilleure

\note[item]{Mais ça peut changer d'ici l'acceptation dans le standard}
	\end{alertblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item Ajout de \lstinline|volatile_load<T>| et \lstinline|volatile_store<T>|
		\item \textit{Compile Time Regular Expression}
		\item \lstinline|std::embed()| : rendre disponible au \textit{runtime} des ressources externes

\note[item]{P.ex. pour embarquer une image dans l'application}
\note[item]{Sans aller lire au \textit{runtime} le fichier contenant la ressource}
\note[item]{Et sans passer par des conversions externes vers des tableaux de \textit{bytes} injectés dans un fichier d'en-tête}

		\item Gestion des UUID
		\item Amélioration de la déduction template dans les constructeurs : agrégats, alias et constructeurs hérités

\note[item]{Terme normatif : \textit{Class Template Argument Deduction}}
\note[item]{Pas de déduction dans ces trois cas pour l'instant}

		\item Implémentations \textit{freestanding} : intégration du plus grand sous-ensemble possible de la bibliothèque standard qui ne présente pas de \textit{memory overhead} ni ne nécessite de support de l'OS

\note[item]{Actuellement le sous-ensemble de la bibliothèque standard proposé est \textit{implementation-defined}}

		\item \textit{Layout} des classes
		\begin{itemize}
			\item Suppression de la possibilité donné au compilateur de réordonner les membres ayant des visibilités différentes

\note[item]{Au sein d'une visibilité, les membres doivent conserver leur ordre}
\note[item]{En pratique, cette liberté n'est pas utilisée par les compilateurs}

			\item Contrôle du \textit{layout} pour privilégier la taille, l'ordre de déclaration, la visibilité, la vitesse, l'ordre alphabétique, les lignes de cache ou les règles d'une version antérieure du C++ ou d'un autre langage
			\item Contrôle de l'alignement (remplaçant de \lstinline|#pragma pack(N)|)
		\end{itemize}

\note[item]{Deux propositions différentes mais pas incompatibles. La première étant en fait un pré-requis}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item Méta-classes pour construire des types de classes (dont les classes elles-mêmes) ayant des contraintes, des comportements par défaut et des opérations par défaut (\lstinline|class|, \lstinline|struct|, \lstinline|enum class|, \textit{interface}, \textit{value})
		\item Répétition \textit{compile-time} d'une expression : \textit{Expansion statement}
		
			\begin{lstlisting}[language=C++]
auto foo = make_tuple(0, 'a', 3.14);
for... (auto elem : tup)  
  cout << elem << "\n"\end{lstlisting}
			
			\begin{itemize}
				\item Pas une boucle : duplication de l'expression pour chaque élément
				\item Éléments de type différent
				\item Utilisable sur \lstinline|std::tuple|, \lstinline|std::array|, classes destructurables, \ldots
			\end{itemize}
		\item Exceptions légères (\textit{Zero-overhead deterministic exceptions})
		\item Capture mutable partielle par les lambdas

\note[item]{Par défaut, capture \lstinline|const|, possible de la rendre modifiable via \lstinline|mutable|, mais tous les données capturées sont alors mutable. Ici il est question de n'avoir que certaines données modifiables}

		\item Déduction de \lstinline|this| (\lstinline|const| ou non, \lstinline|&|, \lstinline|&&|) : adaptation de fonctions membres aux qualifiers de \lstinline|this|

\note[item]{Ce qui va permettre d'éliminer du code \textit{boilerplate}, p.ex. les couples de surcharges \lstinline|const|/non \lstinline|const|}

	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item Changement de contexte \textit{stackful} : \lstinline|fiber_context|
		\item Utilisation de \textit{parameters pack} dans les \textit{structures bindings}

			\begin{lstlisting}[language=C++]
std::tuple<X, Y, Z> f();

auto [...xs] = f();
auto [x, ...rest] = f();
auto [x,y,z, ...rest] = f();
auto [x, ...rest, z] = f();
auto [...a, ...b] = f();  // ill-formed\end{lstlisting}

\note[item]{Proche dans l'esprit de ce qui se fait en Python 3}

		\item Accès bas-niveau aux IO : \lstinline|file_handle| et \lstinline|path_handle|
		\item Gestion des processus, de la communication avec ceux-ci et des \textit{pipes}
		\item invocation concurrente
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item \textit{Parsing} de texte
			\begin{itemize}
				\item Pendant du formatage de texte introduit en C++20
				\item Alternative sûre et robuste à \lstinline|sscanf()|
				\item Extensible aux types utilisateurs
				\item Compatible avec les itérateurs et les \textit{ranges}
			\end{itemize}

			\begin{lstlisting}[language=C++]
string key;
int value;
scan("answer = 42", "{} = {}", key, value);
//    ~~~~~~~~~~~~~  ~~~~~~~~~  ~~~~~~~~~~
//        entree       format    arguments
// key : "answer", value : 42\end{lstlisting}

			\begin{lstlisting}[language=C++]
string key;
chrono::seconds time;
scan("start = 10:30", "{0} = {1:%H:%M}", key, time);\end{lstlisting}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item Algèbre linéaire basé sur un sous-ensemble de \href{https://www.netlib.org/blas/}{BLAS} (vecteur, matrice, \ldots)
		\item Support des unités physiques :
		\begin{itemize}
			\item Gestion des quantités et dimensions
			\item Supports des unités de base, dérivées, des multiples et des sous-multiples
			\item Conversion et opérations entre unités
		\end{itemize}

		\begin{lstlisting}[language=C++]
static_assert(10km / 2 == 5km);

static_assert(1h == 3600s);
static_assert(1km + 1m == 1001m);

static_assert(1km / 1s == 1000mps);
static_assert(2kmph * 2h == 4km);
static_assert(2km / 2kmph == 1h);

static_assert(1000 / 1s == 1kHz);

static_assert(10km / 5km == 2);\end{lstlisting}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item Concept pour les algorithmes numériques
		\item \lstinline|constexpr| dans la bibliothèque standard (\lstinline|std::list|, \lstinline|std::deque|, \ldots)

\note[item]{Poursuite de la prise en compte menée dans les versions précédentes}

		\item \lstinline|std::breakpoint| : point d'arrêt de debug dans le programme
		\item Bibliothèques de support des coroutines
		\item Unification et amélioration des API asynchrones

\note[item]{Qu'il s'agisse de coroutines, d'algorithmes parallèles, d'\textit{executor} ou autre}

		\item \lstinline|std::web_view| API fournissant une fenêtre dans laquelle le programme peut injecter des composants web (ou être appelé via \textit{callback})
		\item Autoriser les conversions entiers vers booléens dans les \lstinline|static_assert| et \lstinline|if constexpr|
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item Attribut \lstinline|assume(expression)| indique que l'expression est vraie et que le compilateur peut utiliser cette hypothèse dans ses optimisations
		\item PFA (\textit{Proxy}, \textit{Facade}, \textit{Addresser}) : programmation polymorphique via \textit{type erasure}

\note[item]{Alternative à la POO et programmation fonctionnelle éliminant certaines de leurs limites}

		\item Interdiction de l'appel de \lstinline|operator=()| sur des temporaires

\note[item]{Ce n'est pas permis sur les types \textit{built-in} mais possible sur les autres, avec tous les problèmes que ça peut poser}

		\item Retarder à l'instanciation l'échec de \lstinline|static_assert(false)| dans des template

		\begin{lstlisting}[language=C++]
template<typenameT>int my_func(constT&) {
  if constexpr(is_integral_v<T>) { 
    return 1; } 
  else if constexpr(is_convertible_v<string, T>) { 
    return 2 ;}
  else {
    // C++20 : echec de compilation systematique
    static_assert(false); } }\end{lstlisting}

\note[item]{Erreur en C++20 et précédent. L'idée est de traiter le \lstinline|static_assert| à l'instanciation et donc de n'échouer que si le paramètre template n'est convertible ni en entier ni en chaîne}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item Généralisation et simplification des \textit{parameters pack}
		\begin{itemize}
			\item Déclaration possible partout où une variable peut être déclarée

			\begin{lstlisting}[language=C++]
template <typename... Ts>
struct Foo { Ts... elems; };\end{lstlisting}

			\item Indexation des \textit{packs}

			\begin{lstlisting}[language=C++]
struct tuple_element<I, tuple<Ts...>> {
  using type = Ts...[I]; };\end{lstlisting}

			\item \textit{Slicing} de \textit{packs}

			\begin{lstlisting}[language=C++]
auto x = Foo(a1, [:]t1..., [3:]t2..., a2);
bar([1:]t1..., a3, [0]t1);\end{lstlisting}

		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item Généralisation et simplification des \textit{parameters pack}
		\begin{itemize}
			\item \textit{Pack} de taille fixe

			\begin{lstlisting}[language=C++]
template<unsigned int N>
struct my_vector {
  my_vector(int...[N] v) : values{v...} {}};\end{lstlisting}

			\item \textit{Variadic function} homogène

			\begin{lstlisting}[language=C++]
template <class T>
void f(T... vs);\end{lstlisting}

\note[item]{La fonction prend un nombre quelconque de paramètres, mais tous du type T}


			\item \og \textit{Unpack}\fg{} de \lstinline|std::tuple| à la volée

			\begin{lstlisting}[language=C++]
int sum(int x, int y, int z) { return x + y + z; }

tuple<int, int, int> point{1, 2, 3};
int s = sum(point.elems...);\end{lstlisting}

		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Propositions diverses}
  \begin{itemize}
	\item Possibilité d'instancier certains template au \textit{runtime} (JIT limité aux templates)

\note[item]{P.ex. pour des matrices dont la taille n'est pas connue à la compilation}

	\item \lstinline|if consteval| similaire à \lstinline|if(is_constant_evaluated())| mais permettant l'appel de fonctions immédiates (\lstinline|consteval|)

	\begin{lstlisting}[language=C++]
consteval int f(int i) { return i; }

constexpr int g(int i) {
	if consteval { return f(i) + 1;	} 
	else { return 42; } }

consteval int h(int i) {
	return f(i) + 1; } \end{lstlisting}

\note[item]{Le même exemple avec \lstinline|if(is_constant_evaluated())| serait incorrect}
\note[item]{En outre, c'est probablement plus lisible et ne nécessite pas de fichier d'en-tête}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item Vérification à la compilation qu'un type à la même représentation mémoire  qu'un autre

\note[item]{P.ex. une structure de deux \lstinline|float| et un tableau de deux \lstinline|float|}

		\item \ldots Voire forcer à avoir la représentation du type cible
		\item Accès aux octets sous-jacent d'un objet
		\begin{itemize}
			\item Nouvelle catégorie d'objet : \textit{contiguous-layout}
			\begin{itemize}
				\item Ne contient que des types scalaires ou des classes sans fonction ni base virtuelles
				\item N'hérite pas de objet non \textit{contiguous-layout}
				\item Contiguïté garantie
			\end{itemize}
			\item Représentation sous forme de tableau
			\item Obtention d'un pointeur sur représentation via \lstinline|reinterpret_cast| vers \lstinline|char|, \lstinline|unsigned char| ou \lstinline|std::byte|
			\item Conversion pointeur sur représentation vers pointeur sur objet via \lstinline|reinterpret_cast|
		\end{itemize}

		\begin{block}{Et actuellement ?}
			Formellement : comportement indéfini\\
			En pratique : comportement actuel des compilateurs 
		\end{block}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item Génération d'opérateurs à la demande par \lstinline|=default|
		\begin{itemize}
			\item \lstinline|operatorX=()| à partir de \lstinline|operatorX()|
			\item incrément et décrément préfixés à partir de l'addition et de la soustraction
			\item incrément et décrément postfixés à partir des versions préfixés
			\item \lstinline|operator->()| et \lstinline|operator->*()| à partir de \lstinline|operator*()| et \lstinline|operator.()|

\note[item]{A priori \lstinline|operator->()| et \lstinline|operator->*()| seront générés par défaut, mais cette génération sera désactivable avec \lstinline|=delete|}
\note[item]{Dans la continuité des opérateurs de comparaisons}

		\end{itemize}
	
		\item Utilisation de caractères Unicode via leur nom ou alias préfixé par \lstinline|\N|

		\begin{lstlisting}[language=C++]
"\N{LATIN CAPITAL LETTER A}"
"\N{NBSP}"\end{lstlisting}

		\item \lstinline|std::tag_invoke| mécanisme générique de configuration du comportement (\textit{policy})

\note[item]{Traditionnellement fait via des \textit{tags} \og template\fg{}, mais ça pose des soucis de résolution de nom que \lstinline|std::tag_invoke| devrait résoudre}

		\item Ajout de suffixes pour les littéraux \lstinline|std::size_t|, \lstinline|std::ptrdiff_t|
		\item \lstinline|std::colony| : conteneur de type \og tableau de \textit{buckets}\fg{}
		\item Ajout d'entiers larges : \lstinline|wide_integer<128, unsigned>|
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}

		\item Nouveau trait \lstinline|std::is_narrowing_convertible|
		\item Trait et fonctions pour garantir des conversions sans perte
		\item Objet standard pour le retour d'erreur (\lstinline|status_code| et \lstinline|error|)
		\item Constructeurs par déplacement \lstinline|=bitcopies|
		\item API \og itérateurs\fg{} de génération des nombres aléatoire
		\item Surcharge \og \textit{ranges}\fg{} de \lstinline|std::for_each_n|, \lstinline|std::clamp|, \lstinline|std::sample|, \lstinline|std::shift_left|, \lstinline|std::shift_right|
		\item Concept \lstinline|reconstructible_range| : \textit{range} reconstructible après une séparation en deux itérateurs
		\item Fonctions statistiques (moyenne, médiane, variance, \ldots)
		\item \lstinline|span| de taille fixe
		\item Paramètre template universel

\note[item]{Utile pour la création de méta-fonctions template \textit{high-order}, pour avoir des \lstinline|static_assert(false)| dépendants et pour certains tests sur les types}

		\item Autoriser les templates dans les classes locales
		\item Ajout de \lstinline|operator[]| à \lstinline|std::initializer_list|
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item Prise en charge de \lstinline|std::string_view| par \lstinline|std::from_chars|
		\item Relâchement des contraintes sur les tableaux \og C\fg{}: initialisation des tableaux d'agrégats, copies de tableaux, tableau comme type de retour

\note[item]{Copies des tableaux membres en particulier}

		\item Opérateur pipeline \lstinline!operator|>()! :  \lstinline!x|>f(y)! équivalent à \lstinline|f(x, y)|
		\item Ajout d'un paramètre \og pas\fg{} à \lstinline|std::iota_view|
		\item Modification du constructeur de \lstinline|std::string| depuis un caractère pour interdire les autres numériques (entiers ou flottants)

\note[item]{Il s'agit d'empêcher les initialisations depuis des numériques via la conversion en char}

		\item Voire dépréciation de la construction d'un \lstinline|std::string| depuis un caractère
		\item Suppression de \lstinline|NULL| et interdiction de \lstinline|0| comme pointeur nul
		\item Évolutions des modules : communication d'informations aux outils de \textit{build}
		\item Ajout d'une boucle \lstinline|do_until|
		\item Élision de copie des objets de retour nommés (NRVO) garantie

\note[item]{NRVO : \textit{Named Return Value Optimization}}
\note[item]{L'élision de copie des objets retournés est déjà garantie pour des \textit{prvalues} en C++17}
\note[item]{C'est déjà une optimisation réalisée par certains compilateur}

		\item Réservation des attributs sans namespace et avec le namespace \lstinline|std|

\note[item]{Attributs sans namespace, c'est à dire dans le namespace global}

	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item Opération \og \textit{relocate}\fg{} (équivalent à déplacement puis destruction)

\note[item]{L'opération \og \textit{relocate}\fg{} est généralement implémentable par un simple \lstinline|memcpy()| sur l}
\note[item]{L'idée est de permettre certaines optimisations sur les objets correspondant}

		\begin{itemize}
			\item Définition de la notion \og \textit{relocatable}\fg{} 
			\item Ajout du concept \lstinline|Relocatable|

\note[item]{En gros, si j'ai bien compris, il s'agit d'objet sur lesquels \lstinline|swap()| peut être appelé}

			\item Définition de la notion de \og \textit{trivial relocatability}\fg{}

\note[item]{Objets respectant la règle du 0 (pas de définition utilisateur de constructeur de copie/déplacement, d'opérateur d'affection par copie/déplacement ni de destructeur)}

			\item Ajout des traits \lstinline|is_relocatable|, \lstinline|is_nothrow_relocatable| et \lstinline|is_trivially_relocatable|
			\item Ajout de l'attribut \lstinline|[[trivially_relocatable]]| pour indiquer un type \textit{trivial relocatability}
			\item Ajout d'algorithmes gérant cette opération : \lstinline|std::relocate_at|, \lstinline|std::uninitialized_relocate| et \lstinline|std::uninitialized_relocate_n|
		\end{itemize}


\note[item]{Par défaut, la capture n'est pas mutable}
\note[item]{Il est déjà possible de changer ce comportement via le mot-clé \lstinline|mutable| mais il s'applique à tous les paramètres capturés}

		\item Évolution de \textit{floating-point types}
		\begin{itemize}
			\item Ajout de types de petites tailles (16 bits)
			\item Alias indiquant la taille (\lstinline|floatX_t|)
			\item Ajout des suffixes littéraux correspondants
			\item Cadre pour l'introduction d'autres types par une implémentation
		\end{itemize}

		\item Extension de \lstinline|=delete| à d'autres construction (notamment aux variables template)

\note[item]{La proposition initiale ne concernait que les variables template, mais elle a inspiré le comité}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Propositions diverses}
	\begin{itemize}
		\item Gestion de la compatibilité ascendante via la configuration d'un \textit{epoch} au niveau d'un module pour activer des évolutions brisant la compatibilité

\note[item]{P.ex. si le standard C++23 supprime les conversions implicites, il serait possible d'appliquer ce changement uniquement sur les modules déclarant \lstinline|epoch 2023|}
\note[item]{Pour l'instant pas de consensus trouvé, mais d'importants problèmes.}

		\item Améliorations du générateur aléatoire
		\item Construction de \lstinline|std::stack| et \lstinline|std::queue| depuis une paire d'itérateurs

			\begin{lstlisting}[language=C++]
vector<int> v(42);
queue q(v.begin(), v.end());
stack s(v.begin(), v.end());
\end{lstlisting}

\note[item]{En C++20 et précédent, il faut indiquer le type et utiliser une liste d'initialisation construite via la paire d'itérateur : \lstinline|queue<int> q({v.begin(), v.end()});|}

	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{TS - Contracts}
	\begin{itemize}
		\item Retiré du \textit{draft} C++20 et création d'un groupe d'étude en juillet 2019

\note[item]{Ne sera donc finalement pas en C++20, probablement en 2023}

		\item Support de la programmation par contrat
		\item Remplacement de la vérification à coup d'\lstinline|assert| et de la documentation via commentaire \lstinline|@pre|, \lstinline|@post| et \lstinline|@invariant|
		\item Initialement, plusieurs propositions \og concurrentes\fg{}
		\item \ldots{}mais un compromis à émerger
		\item Utilisation d'attributs \lstinline|[[assert:x]], |\lstinline|[[expects:x]]| et \lstinline|[[ensure:x]]|

\note[item]{\lstinline|[[assert:x]]| : invariants et autres vérifications}
\note[item]{\lstinline|[[expects:x]]| : pré-conditions}
\note[item]{\lstinline|[[ensure:x]]| : post-combustions}

		\item Possibilité de les marquer \lstinline|audit| pour ne les activer qu'à la demande
		\item Possibilité de les marquer \lstinline|axiom| pour ne pas générer de code \textit{runtime} (\textit{compile-time} uniquement)
		\item Les contrats de fonctions membres publiques peuvent utiliser des membres privés ou protégés
		\item Intégration des contrats à la bibliothèque standard
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{TS - Networking TS}
	\begin{itemize}
		\item Publié en avril 2018
		\item Possiblement intégré à C++23
		\item Partiellement basé sur Boost.Asio
		\item Modèle asynchrone
		\item Gestion de \textit{timer}
		\item Gestion de tampon et de flux orientés tampon
		\item Gestion de \textit{sockets} et de flux \og \textit{socket}\fg{}
		\item Gestion d'IPv4, IPv6, TCP, UDP
		\item Manipulation d'adresses IP
		\item Pas de protocoles de plus haut niveau actuellement
		\item Demande post-TS : gestion de la sécurité (a priori par possible)
	\end{itemize}

	\begin{alertblock}{Scope ?}
		Une partie du comité ne souhaitent pas que des fonctionnalités de haut-niveau, comme le réseau, soient intégrées au standard
	\end{alertblock}

\note[item]{En outre, la cryptographie ne peut pas être intégré au standard pour différentes raisons (rythme d'évolution différent entre le standard et la cryptographie, pas de processus pour gérer les failles de sécurité, problème légal d'exporter de la cryptographie dans certains pays dont les États-Unis d'Amérique)}

\end{frame}

\begin{frame}
	\frametitle{TS - Les autres\titlehfill{}1/2}
	\begin{itemize}
		\item \textit{Library fundamentals 2} : évolutions de la bibliothèque standard
		\begin{itemize}

\note[item]{Les listes de fonctionnalités des TS ne sont pas exhaustives}

			\item Pointeurs intelligents non possédant
			\item Nouveaux algorithmes

		\end{itemize}
		\item \textit{Library fundamentals 3} :
		\begin{itemize}
			\item \textit{Generic Scope Guard}
			\item \textit{RAII wrapper}
		\end{itemize}
	
		\item \textit{Parallelism} 2 : publié en juin 2018
		\item \textit{Transactional Memory} : publié
		\item \textit{Numerics}: manipulation des nombres
		\begin{itemize}
			\item Détection et gestion des débordements
			\item Gestion des arrondis
			\item Entiers larges
			\item Rationnel
			\item \textit{Proxy} pour manipuler la représentation interne des entiers
		\end{itemize}
	
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{TS - Les autres\titlehfill{}2/2}
	\begin{itemize}
		\item \textit{Array extension} : taille non connue à la compilation
		\item \textit{2D Graphics} (io2d) : API C++ au dessus de Cairo, différé

\note[item]{Mais le projet io2d en lui-même continue}
\note[item]{Le comité ne voit pas d'intérêt à poursuivre les travaux sur les aspects graphiques pour le moment}

		\item \textit{Reflection} : \textit{feature-complete}, TS en \og C++20\fg{}, probablement en C++ 23
		\begin{itemize}
			\item Introspection
			\item Méta-programmation et code \textit{compile-time}
			\item Injection
			\item Méta-classes
		\end{itemize}

\note[item]{Dans un premier temps, il s'agit de réflexion statique}

		\item \textit{Concurrency} 1 : publié
		\begin{itemize}
			\item \lstinline|future.then()|
		\end{itemize}
		\item \textit{Concurrency} 2
		\begin{itemize}
			\item \textit{Synchronic} : meilleure abstraction pour atomique permettant de tirer partie des caractéristiques logicielles et matérielles de la plateforme
			\item \textit{Executor} permettant de spécifier où et comment s'exécute un code dans un environnement concurrent (a priori pour C++23)
		\end{itemize}
	\end{itemize}
\end{frame}
\end{document}