\documentclass[C++.tex]{subfiles}
\begin{document}

\section{C++23}
\subsection*{Présentation}
\begin{frame}
	\frametitle{Présentation}
	\begin{itemize}
		\item Travaux lancés à l'été 2020
		\item Dernier \textit{Working Draft} : \href{https://github.com/cplusplus/draft/releases/download/n4868/n4868.pdf}{n4868}
	\end{itemize}
\end{frame}

\subsection*{Organisation}
\begin{frame}
	\frametitle{Changements d'organisation du comité}
	\begin{itemize}
		\item Création d'un \textit{ABI Review Group} : étude des impacts sur l'ABI des évolutions
		\item Création d'un \textit{Study Group} pour la liaison C/C++ (SG22)
	\end{itemize}
\end{frame}

\subsection*{if consteval}
\begin{frame}[fragile]
	\frametitle{\lstinline|if consteval|}
	\begin{itemize}
		\item Branche prise en compte uniquement à la compilation
		\item \lstinline|else| pour le code évalué au \textit{run-time}
	\end{itemize}

	\begin{lstlisting}[language=C++]
if consteval {...}
else {...}\end{lstlisting}

	\begin{itemize}
		\item Négation possible
	\end{itemize}

	\begin{lstlisting}[language=C++]
if not consteval {...}
// ou
if ! consteval {...}\end{lstlisting}

	\begin{alertblock}{Attention}
		\begin{itemize}
			\item Accolades obligatoires, même avec une unique instruction
		\end{itemize}
	\end{alertblock}
\end{frame}

\subsection*{Types}
\begin{frame}[fragile]
	\frametitle{Énumérations}
	\begin{itemize}
		\item \lstinline|std::to_underlying| convertit une énumération vers le type sous-jacent

\note[item]{Permet de remplacer les \lstinline|static_cast<XXXX>()|, qui présente un risque d'oubli de modification lors d'un changement du type sous-jacent}
	\end{itemize}

	\begin{lstlisting}[language=C++]
enum class FOO : uint32_t { A = 0xABCDEF };

auto bar = std::to_underlying(FOO::A); // uint32_t\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Entiers en booléens}
	\begin{itemize}
		\item Utilisation d'entiers sans conversion explicite en booléen
		\begin{itemize}
			\item Dans les \lstinline|static_assert|
			\item Dans les if \lstinline|constexpr|
		\end{itemize}
	\end{itemize}

	\begin{lstlisting}[language=C++]
// Valide en C++23, pas en C++20
if constexpr(flags & 0x01) {...}
else {...}\end{lstlisting}

	\begin{lstlisting}[language=C++]
// Valide en C++23, pas en C++20
template <std::size_t N>
class Foo {	static_assert(N, "Message"); };\end{lstlisting}
\end{frame}

\subsection*{Suffixes littéraux}
\begin{frame}[fragile]
	\frametitle{Suffixes littéraux}
	\begin{itemize}
		\item Suffixe \lstinline|uz| (ou \lstinline|zu|) pour \lstinline|size_t|
		\item Suffixe \lstinline|z| pour les \og \lstinline|signed|\fg{} \lstinline|size_t|

\note[item]{Le type entier signé correspondant à \lstinline|size_t|}
	\end{itemize}
\end{frame}

\subsection*{Conteneurs}
\begin{frame}[fragile]
	\frametitle{Chaînes de caractères}
	\begin{itemize}
		\item \lstinline|contains()| teste la présence d'une sous-chaîne
	\end{itemize}

	\begin{lstlisting}[language=C++]
string foo = "Hello world";
	
foo.contains("Hello");   // true
foo.contains("monde");   // false\end{lstlisting}

\note[item]{Comparaison \textit{case-sensitive} comme toutes les fonctions de recherche dans des \lstinline|std::string|}

	\begin{itemize}
		\item Interdiction de la construction de \lstinline|std::string| depuis \lstinline|nullptr|

\note[item]{Erreur de compilation, avant c'était un comportement indéfini}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{\lstinline|starts_with()| \& \lstinline|ends_with()|}
	\begin{itemize}
		\item Généralisation de \lstinline|starts_with()| et \lstinline|ends_with()| aux ranges
	\end{itemize}

	\begin{lstlisting}[language=C++]
auto foo = view::iota(0, 50);
auto bar = view::iota(0, 30);
if(ranges::starts_with(foo, bar)) { ... }\end{lstlisting}
\end{frame}

\subsection*{Itérateurs}
\begin{frame}[fragile]
	\frametitle{Input range adaptator et \lstinline|counted_iterator|}
	\begin{itemize}
		\item Corrections d'\lstinline|iterator_category|
		\item Rend valide en C++23 du code invalide en C++20
	\end{itemize}
\end{frame}

\subsection*{Pointeurs intelligents}
\begin{frame}[fragile]
	\frametitle{\lstinline|out_ptr| et \lstinline|inout_ptr|}
	\begin{itemize}
		\item Abstraction entre \textit{smart pointers} et API C
		\item Automatisation des appels à \lstinline|reset()| et \lstinline|release()|
		\item \textit{Exception-safe} : \textit{smart pointer} rétabli au retour de l'API C

\note[item]{Pas d'exception dans le code C++ avant le rétablissement du \textit{smart pointer}}

		\item Permet le passage comme pointeur C \lstinline|void*| ou \lstinline|void**|
		\item Permet la conversion vers un type de pointeur arbitraire
		\item \lstinline|inout_ptr| permet la libération par l'API C
	\end{itemize}
\end{frame}

\subsection*{Debug}
\begin{frame}[fragile]
	\frametitle{Bibliothèque de \textit{Stacktrace}}
	\begin{itemize}
		\item Basée sur Boost.stacktrace
		\item Récupération de la \textit{stacktrace} actuelle
		\item Parcours des entrées de la \textit{stacktrace}
		\item Récupération de la description, de la ligne et du fichier des entrées
	\end{itemize}
\end{frame}

\subsection*{Programmation fonctionnelle}
\begin{frame}[fragile]
	\frametitle{Lambdas}
		\begin{itemize}
			\item \lstinline|()| optionnelles en l'absence de paramètres dans les lambdas mutables

\note[item]{Elles étaient optionnelles dans tous les autres cas}

		\end{itemize}
\end{frame}

\subsection*{Traits}
\begin{frame}[fragile]
	\frametitle{Traits}
	\begin{itemize}
		\item Trait \lstinline|is_scoped_enum| pour déterminer si un type est un \lstinline|enum class|
	\end{itemize}
\end{frame}

\subsection*{Multi-threading}
\begin{frame}[fragile]
	\frametitle{Atomiques}
	\begin{itemize}
		\item Support des \lstinline|atomics| C
	\end{itemize}
\end{frame}

\subsection*{Durées et temps}
\begin{frame}[fragile]
	\frametitle{\lstinline|time_point::clock|}
	\begin{itemize}
		\item Relâchement des contraintes sur \lstinline|time_point::clock|
		\item Plus grande flexibilité du type d'horloge
		\item Permet des horloges \textit{stateful}, des horloges externes
		\item Permet la représentation d'un \textit{time of day} par un \lstinline|time_point| particulier
	\end{itemize}
\end{frame}

\subsection*{Variant}
\begin{frame}[fragile]
	\frametitle{\lstinline|std::variant|}
	\begin{itemize}
		\item Héritage de \lstinline|std::variant| possible
		\item \lstinline|std::visit()| restreints aux \lstinline|std::variant|

\note[item]{Et donc des dérivés en question}
\note[item]{Auparavant, les variants de \lstinline|std::visit| pouvaient être formellement de n'importe quel type}
	\end{itemize}
\end{frame}

\end{document}