\documentclass[C++.tex]{subfiles}
\begin{document}

\section{C++26}
\subsection*{Présentation}
\begin{frame}
	\frametitle{Présentation}
	\begin{itemize}
		\item Début formel des travaux en juin 2023
%		\item Dernier \textit{Working Draft} : \href{https://github.com/cplusplus/draft/releases/download/n4917/n4917.pdf}{n4917\linklogo}
	\end{itemize}
\end{frame}

\subsection*{Syntaxe}
\begin{frame}[fragile]
	\frametitle{Vérification statique}
	\begin{itemize}
		\item Support de messages construits par \mintinline{cpp}|static_assert|
	\end{itemize}

	\begin{minted}{cpp}
		static_assert(sizeof(Foo) == 1,
		              format("Attendu 1, obtenu {}", sizeof(Foo)));
	\end{minted}

	\begin{alertblock}{\textit{Compile-time}}
		\begin{itemize}
			\item Uniquement des valeurs connues au \textit{compile-time}
		\end{itemize}
	\end{alertblock}

	\begin{alertblock}{Dépendance}
		\begin{itemize}
			\item Nécessite que \mintinline{cpp}|std::format| devienne \mintinline{cpp}|constexpr|
		\end{itemize}
	\end{alertblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Lexer}
	\begin{itemize}
		\item Suppression de comportements indéfinis
		\begin{itemize}
			\item \textit{Universal characters} sur plusieurs lignes autorisés
		\end{itemize}
	\end{itemize}
	
	\begin{minted}[escapeinside=||]{cpp}
		int |\textbackslash|\
		u\
		0\
		3\
		9\
		1 = 0;
	\end{minted}

	\begin{itemize}
		\item [] \begin{itemize}
			\item Construction possible d'\textit{universal characters} par des macros
		\end{itemize}
	\end{itemize}

	\begin{minted}[escapeinside=||]{cpp}
		#define CONCAT(x, y) x ## y
		int CONCAT(|\textbackslash|, u0393) = 0;
	\end{minted}

	\begin{itemize}
		\item [] \begin{itemize}
			\item Une chaîne non terminée est une erreur
		\end{itemize}
	\end{itemize}
\end{frame}

\subsection*{Encodage}
\begin{frame}[fragile]
	\frametitle{Encodage}
	\begin{itemize}
		\item Ajout de \mintinline[escapeinside=||]{cpp}{|@|}, \mintinline{cpp}|$| et \mintinline[escapeinside=||]{cpp}{|`|} au jeu de caractères de base
	
\note[item]{Ajoutés en C (C23)}
\note[item]{Supportés par tous les encodages communément utilisés}

		\item Caractères non-encodables sont mal formés
		\item Notion de \textit{literal encoding} et \textit{environnement encoding} et API d'interrogation
	\end{itemize}
\end{frame}

\subsection*{Types}
\begin{frame}[fragile]
	\frametitle{\textit{Saturation arithmétic}}
	\begin{itemize}
		\item Fonctions \mintinline{cpp}|std::add_sat()|, \mintinline{cpp}|std::sub_sat()|, \mintinline{cpp}|std::mul_sat()|, \mintinline{cpp}|std::div_sat()| et \mintinline{cpp}|std::saturate_cast()|
		\item Les calculs dont le résultat est hors borne retournent les plus grandes ou plus petites valeurs représentables
	\end{itemize}

	\begin{minted}{cpp}
		add_sat(3, 4);                  // 7
		sub_sat(INT_MIN, 1);            // INT_MIN
		add_sat<unsigned char>(255, 4); // 255
	\end{minted}
\end{frame}

\subsection*{Variables}
\begin{frame}[fragile]
	\frametitle{Placeholders}
	\begin{itemize}
		\item Joker \mintinline{cpp}|_| pour des variables inutilisées
	\end{itemize}
	
	\begin{minted}{cpp}
		auto _ = foo();  // Equivalent a [[maybe_unused]] auto _ = foo();
	\end{minted}

	\begin{minted}{cpp}
		std::lock_guard _(mutex);
	\end{minted}

	\begin{minted}{cpp}
		auto  [x, y, _] = f();
	\end{minted}
\end{frame}

\subsection*{Conteneurs}
\begin{frame}[fragile]
	\frametitle{Conteneurs}
	\begin{itemize}
		\item Nouveaux conteneurs
		\begin{itemize}
			\item Vecteur de capacité fixée en \textit{compile-time} \mintinline{cpp}|std::inplace_vector|

\note[item]{Contrairement à \mintinline{cpp}|std::array| la taille n'est pas fixée, seule la capacité l'est, et donc utilisable pour des éléments \og sans valeur par défaut\fg{}}
		\end{itemize}
		\item Possibilité d'utiliser \mintinline{cpp}|std::weak_ptr| en tant que clé de conteneur associatif
		\item \mintinline{cpp}|std::submdspan()| retourne une vue sur un sous-ensemble d'un \mintinline{cpp}|std::mdspan|
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Chaînes de caractères}
	\begin{itemize}
		\item Support de \mintinline{cpp}|std::string_view| par \mintinline{cpp}|std::stringstream|
		\item Interfaçage de \mintinline{cpp}|std::bitset| avec \mintinline{cpp}|std::string_view|
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Initializer-list}
	\begin{itemize}
		\item \textit{static storage} possible pour les \textit{braced-initializer-list}
		
\note[item]{Évite de copier les données depuis le static storage vers le tableau sous-jacent de l'\textit{initializer list} puis vers le conteneur}
	\end{itemize}
\end{frame}

\subsection*{Algorithme}
\begin{frame}[fragile]
	\frametitle{Algèbre linéaire}
	\begin{itemize}
		\item Basé sur un sous-ensemble de \href{https://www.netlib.org/blas/}{BLAS\linklogo}
		\item Multiples opérations
		\begin{itemize}
			\item Somme de vecteurs
			\item Multiplication de vecteurs ou de matrices par un scalaire
			\item Produit de vecteurs et de matrices
			\item Triangularisation de matrices
			\item Rotation de plans
		\end{itemize}
		\item Plusieurs formats de stockage des matrices
	\end{itemize}

	\begin{minted}{cpp}
		vector<double> x_vec{1., 2., 3., 4., 5.};
		mdspan x(x_vec.data(), 5);

		linalg::scale(2.0, x); // x = 2.0 * x
	\end{minted}

\end{frame}

\begin{frame}[fragile]
	\frametitle{\mintinline[style=white]{cpp}|std::visit()|}
	\begin{itemize}
		\item Versions membres de \mintinline{cpp}|std::visit()| et \mintinline{cpp}|std::visit_format_arg()|
	\end{itemize}
\end{frame}

\subsection*{Ratio}
\begin{frame}[fragile]
	\frametitle{Ratio}
	\begin{itemize}
		\item Ajout des préfixes \mintinline{cpp}|quecto|, \mintinline{cpp}|ronto|, \mintinline{cpp}|ronna| et \mintinline{cpp}|quetta|
	\end{itemize}
\end{frame}

\subsection*{constexpr}
\begin{frame}[fragile]
	\frametitle{\mintinline[style=white]{cpp}|constexpr|}
	\begin{itemize}
		\item Davantage de \mintinline{cpp}|constexpr| dans la bibliothèque standard
		\item Conversion depuis \mintinline{cpp}|void*| dans des contextes \mintinline{cpp}|constexpr|
		\begin{itemize}
			\item \mintinline{cpp}|std::format()| au compile-time
			\item \mintinline{cpp}|std::function_ref|, \mintinline{cpp}|std::function| et \mintinline{cpp}|std::any| \mintinline{cpp}|constexpr|
		\end{itemize}
	\end{itemize}
\end{frame}

\subsection*{Parameters pack}
\begin{frame}[fragile]
	\frametitle{Parameters pack}
	\begin{itemize}
		\item Indexation des \textit{packs}
	\end{itemize}

	\begin{minted}{cpp}
		template <typename... T>
		constexpr auto first_plus_last(T... values) -> T...[0] {
		  return T...[0](values...[0] + values...[sizeof...(values)-1]);
		}

		first_plus_last(1, 2, 10);  // 11
	\end{minted}
\end{frame}

\subsection*{Gestion mémoire}
\begin{frame}[fragile]
	\frametitle{lifetime}
	\begin{itemize}
		\item \mintinline{cpp}|std::is_within_lifetime()| indique si l'objet pointé est vivant
		\item \ldots{} en particulier si un membre d'une union est active
	\end{itemize}
\end{frame}

\subsection*{Multithreading}
\begin{frame}[fragile]
	\frametitle{Gestion mémoire}
	\begin{itemize}
		\item \textit{hazard pointers} : unique écrivain, multiples lecteurs
		\item Structure de donnée \textit{read-copy update} : planification d'actions (p.ex. suppression) à réaliser plus tard
	\end{itemize}
\end{frame}

\subsection*{Programmation fonctionnelle}
\begin{frame}[fragile]
	\frametitle{Type appelable}
	\begin{itemize}
		\item Ajout de \mintinline{cpp}|std::copiable_function| pour les fonctions copiables

\note[item]{Pendant de \mintinline{cpp}|std::move_only_function|}

		\item Ajout de \mintinline{cpp}|std::function_ref|
		\begin{itemize}
			\item Type référence pour le passage d'appelable à une fonction
			\item Plus générique et moins gourmand que \mintinline{cpp}|std::function| et équivalents
	
\note[item]{Les fonctions n'ont pas besoin d'être copiables ni déplaçables}
		\end{itemize}
	\end{itemize}
\end{frame}

\subsection*{Flux}
\begin{frame}[fragile]
	\frametitle{\mintinline[style=white]{cpp}|std::format|}
	\begin{itemize}
		\item Possibilité de fournir une chaîne de format au \textit{runtime}
	\end{itemize}

	\begin{minted}{cpp}
		string str = "{}";
		format(runtime_format(str), 42);
	\end{minted}

	\begin{itemize}
		\item Redéfinition de \mintinline{cpp}|std::to_string| en terme de \mintinline{cpp}|std::format|
		\item Davantage de vérifications \textit{compile-time} du type des arguments
		\begin{itemize}
			\item Déjà le cas de la majorité des erreurs
			\item \ldots{} mais pas de toutes
		\end{itemize}
	\end{itemize}

	\begin{minted}{cpp}
		format("{:>{}}", "hello", "10");
		// Erreur run-time
	\end{minted}

	\begin{itemize}
		\item Formatage des pointeurs
	\end{itemize}

	\begin{minted}{cpp}
		format("{:#018X}", reinterpret_cast<uintptr_t>(&i));
		// 0X00007FFE0325C4E4
	\end{minted}
\end{frame}

\subsection*{Durées et temps}
\begin{frame}[fragile]
	\frametitle{Durées et temps}
	\begin{itemize}
		\item Spécialisation de \mintinline{cpp}|std::hash| pour \mintinline{cpp}|std::chrono|
	\end{itemize}
\end{frame}

\subsection*{Système de fichiers}
\begin{frame}[fragile]
	\frametitle{Accès bas-niveaux aux IO}
	\begin{itemize}
		\item Alias \mintinline{cpp}|native_handle_type| sur le descripteur de fichier de la plateforme
		
\note[item]{\mintinline{cpp}|int| sous POSIX, \mintinline{cpp}|HANDLE| (\mintinline{cpp}|void*|) sous Windows}
		 
		\item \mintinline{cpp}|native_handle()| retourne ce descripteur
	\end{itemize}
\end{frame}

\subsection*{Compilation et implémentation}
\begin{frame}[fragile]
	\frametitle{Debug}
	\begin{itemize}
		\item \mintinline{cpp}|std::breakpoint()| : point d'arrêt dans le programme
		\item \mintinline{cpp}|std::breakpoint_if_debugging| : point d'arrêt si l'exécution se fait dans un debugger
		\item \mintinline{cpp}|std::is_debugger_present()| permet de savoir si l'exécution se fait dans un debugger
	\end{itemize}
\end{frame}
\end{document}