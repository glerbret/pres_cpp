\documentclass[C++.tex]{subfiles}
\begin{document}

\section{Retour sur C++98/C++03}
\subsection*{Rappels}
\begin{frame}
	\frametitle{Rappels historiques}
	\begin{itemize}
		\item Années 80 : \og C with classes\fg{} par Bjarne Stroustrup aux Bell Labs
		\item 1983 : renommé C++
		\item 1985 : première version publique de CFront 
		\item 1985 : première version de \textit{The C++ Programming Language} 
		\item 1998 : première normalisation
		\item 2003 : amendement
		\item 2007 : publication du premier \textit{Technical Report} (TR1)
		
\note[item]{Les Technical Report (TR) ne sont pas normatifs}
\note[item]{Définition des TR par l'ISO : \textit{An informative document containing information of a different kind from that normally published in a normative document}}
		
		\begin{itemize}
			\item Partiellement implémenté par certains compilateurs ou Boost
			\item Repris en partie dans les normes suivantes et TS
			
\note[item]{\textit{Les Technical Specification} (TS) sont des documents normatifs ayant vocation a être intégrés dans la norme, ce sont essentiellement des \textit{preview}}
\note[item]{Définition des TS par l'ISO : \textit{A normative document representing the technical consensus within an ISO committee}}
			
		\end{itemize}
		\item Un projet de TR2 finalement transposé en \textit{Technical Specification}
		
\note[item]{Pas de publication de TR2 car changement des procédures au sein du comité ISO C++.}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{La \og philosophie\fg{} du C++}
	\begin{itemize}
		\item Langage multi-paradigme

\note[item]{Procédural, objet, générique et \textit{Template metaprogramming}}

		\item Typage statique déclaratif

\note[item]{Typage statique déclaratif : vrai en C++98 plus nuancé après}
\note[item]{Déclaratif est un terme de mon choix (consensus ?). Explicite convient}

		\item Généraliste

\note[item]{\textit{General Purpose} : par opposition à Fortran, Cobol, R ou l'assembleur}

		\item À l'origine, ajout des classes au C

\note[item]{Classes issues de Simula}

		\item Forte compatibilité avec le C : vaste sous-ensemble commun proche du C

\note[item]{Héritage - bas niveau - du C est probablement une part du succès}
\note[item]{meilleur typage que C (à l'origine d'incompatibilités : caractères littéraux de type \lstinline|char|, pas de conversion implicite depuis \lstinline|void|)}

		\item \textit{Zero-overhead abstraction}
		\item Compatibilité ascendante forte mais pas absolue
		\item Évolutions par les bibliothèques plutôt que par le langage
		\item Pas de \og magie\fg{} dans la bibliothèque standard
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Normalisation}
	\begin{itemize}
		\item Normalisé par l'ISO : \url{http://www.open-std.org/JTC1/SC22/WG21/}

\note[item]{Sous-comité 22, Working group 21}

		\item Comité distinct de celui du C

\note[item]{C : Working group 14}

		\item \ldots mais des membres en commun
		\item Pas de propriétaire du C++

\note[item]{Pas de propriétaire donc libre de droit, mais la norme ISO définitive est payante}

		\item Actualité de normalisation, et du C++ en général, sur \href{https://isocpp.org/}{isocpp.org}

\note[item]{Également une FAQ plutôt bien sur C++, ainsi qu'un guide de bonnes pratiques, les \textit{drafts} de la norme et les propositions}

	\begin{alertblock}{isocpp.org n'est pas le site du comité}
		Mais celui de \textit{Standard C++ Foundation} dont le but est la promotion du C++\\
		Les deux sont cependant très proches et partagent de nombreux membres
		
		\note[item]{Membres communs entre isocpp.org et comité : Bjarne Stroustrup, Herb Sutter (président de isocpp et secrétaire du comité)}
	\end{alertblock}

		\item Une conférence annuelle : \href{http://cppcon.org/}{cppcon}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Norme \& support}
	\begin{itemize}
		\item Compilateur
		\begin{itemize}
			\item GCC : \href{https://gcc.gnu.org/projects/cxx-status.html}{C++ Standards Support in GCC}
			\item Clang (LLVM) : \href{http://clang.llvm.org/cxx_status.html}{C++ Support in Clang}
			\item Visual studio : \href{https://docs.microsoft.com/fr-fr/cpp/overview/visual-cpp-language-conformance?view=msvc-160}{Tableau de conformité du langage Microsoft C++}
		\end{itemize}
		\item Bibliothèque standard
		\begin{itemize}
			\item GCC : \href{https://gcc.gnu.org/onlinedocs/libstdc++/manual/status.html}{status.html}
			\item Clang : \href{https://libcxx.llvm.org/}{C++ Standard Library}
		\end{itemize}
		\item Vision globale \href{http://en.cppreference.com/w/cpp/compiler_support}{C++ compiler support}
	\end{itemize}
\end{frame}

\subsection*{Gestion des erreurs}
\begin{frame}
	\frametitle{Erreurs - Code retour\titlehfill{}1/2}
	\begin{itemize}
		\item Plusieurs variantes
		\begin{itemize}
			\item Type de retour dédié
			\item Valeur particulière notant un échec (\lstinline|NULL|, \lstinline|-1|)
			\item Récupération de la dernière erreur (\lstinline|errno|, \lstinline|GetLastError()|)
		\end{itemize}
		\item \og Un test toutes les deux lignes de code\fg{}
		\item Gestion \og manuelle\fg{} de la remontée de la pile d'appel
		\item Adapté au traitement local des erreurs, pas au traitement \og plus haut\fg{}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Erreurs -  Code retour\titlehfill{}2/2}
	\begin{alertblock}{Problèmes et limites}
		\begin{itemize}
			\item Impact négatif sur la lisibilité
			\item Souvent délaissé dans un contexte d'enseignement ou de formation
			\item Finalement beaucoup de code avec une gestion d'erreur déficiente
		\end{itemize}
	\end{alertblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Erreurs - Exception\titlehfill{}1/2}
	\begin{itemize}
		\item Lancée par \lstinline|throw|\dots{}
		\item Attrapée par \lstinline|catch()| depuis un bloc \lstinline|try|
	\end{itemize}

	\begin{lstlisting}[language=C++]
try {
  ...
  // Lancement d'une exception
  throw logic_error("Oups !");
  ... }
catch(logic_error& e) {
  // Traitement de l'exception }\end{lstlisting}
\end{frame}

\begin{frame}
	\frametitle{Erreurs - Exception\titlehfill{}2/2}
	\begin{itemize}
		\item Type quelconque
		\item Idéalement héritant de \lstinline|std::exception| (via \lstinline|std::logic_error|, \lstinline|std::runtime_error| ou autres)
		\item \lstinline|catch(...)| pour attraper les exceptions de tout type
		\item Compatibles avec le \textit{stack unwinding}

\note[item]{Les objets sur la pile sont détruits lors de la sortie d'une fonction même via la levée d'une exception}
\note[item]{Destruction se fait dans l'ordre inverse de la création des objets}

		\item Les exceptions non attrapées provoquent l'appel de \lstinline|std::terminate()|

\note[item]{Sortie du programme sans \textit{stack unwinding}}

		\item Pas de \lstinline[keywordstyle=\color{black}]|finally|
		\item Utilisées par la bibliothèque standard (p.ex. \lstinline|std::bad_alloc|)
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Erreurs - Critiques des exceptions\titlehfill{}1/2}
	\begin{itemize}
		\item Critiquées, voire interdites, par certaines normes de codage (p.ex. : \href{https://google.github.io/styleguide/cppguide.html}{Google C++ Style Guide)}
		\item Arguments très variés :
		\begin{itemize}
			\item \og Je ne comprends pas\fg{}, \og Ça ne sert à rien\fg{}, \ldots
			\item Impact négatif sur les performances
		\end{itemize}

		\pause

		\begin{block}{Pas vraiment}
			\begin{itemize}
				\item Vrai à l'origine
				\item Actuellement une exception non levée ne coute quasiment rien
				\item Souvent comparée à une non gestion d'erreur. Est-ce pertinent ? 
			\end{itemize}
		\end{block}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Erreurs - Critiques des exceptions\titlehfill{}2/2}
	\begin{itemize}
		\item Arguments très variés :
		\begin{itemize}
			\item Mauvais support par les différents outils
		\end{itemize}

		\begin{block}{Très variable}
			\begin{itemize}
				\item Correctement supportées par les compilateurs actuels
				\item Inégalement gérées par les outils d'analyse, de documentation, \ldots
			\end{itemize}
		\end{block}

		\begin{itemize}
			\item Code plus complexe à analyser

\note[item]{Complexité discutable : il faut une vision plus globale, donc plus complexe, pour suivre un programme. Mais le code local est plus simple vu qu'il n'est noyé de code dédié à la gestion d'erreur}

			\item Difficiles à introduire dans une large base de code sans exception

\note[item]{L'argument de la difficulté d'introduction est à nuancer toutefois avec la levée d'exception par la bibliothèque standard qui a lieu dans tous les cas (hors options particulières du compilateur)}

			\item Absence d'ABI normalisée

\note[item]{Le problème d'ABI est plus large que les seules exceptions}
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Erreurs - Exception safety\titlehfill{}1/3}
	\begin{itemize}
		\item \textit{No-throw guarantee} : l'opération ne peut pas échouer

\note[item]{\textit{No-throw} : exceptions internes attrapées et traitées en interne}

		\begin{exampleblock}{Do}
			Destructeurs, déplacements et \lstinline|swap()| doivent être \lstinline|noexcept|
		\end{exampleblock}

		\item \textit{Strong exception safety} : pas d'effet de bord, pas de fuite, état conservé

\note[item]{\textit{Strong} : les objets sur lesquels opèrent la fonction (paramètres ou classe dont la fonction est membre) conservent leur valeur d'avant l'appel (\textit{Commit or rollback})}

		\item \textit{Basic exception safety} : invariants conservés, pas de fuite

\note[item]{\textit{Basic} (\textit{No-leak guarantee}) : les valeurs peuvent être différentes mais elles restent valides et cohérentes}
\note[item]{On ne peut pas poursuivre l'opération et des données \og transactionnelles\fg{} peuvent avoir été perdues mais on est encore capable de travailler et notamment de traiter l'erreur}

\item \textit{No exception safety} : aucune garantie
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Erreurs - Exception safety\titlehfill{}2/3}
	\begin{exampleblock}{Do}
		Privilégiez les garanties les plus fortes possibles (\textit{strong} ou \textit{no-throw})
	\end{exampleblock}

	\begin{alertblock}{Don't}
		\begin{itemize}
			\item Évitez la garantie faible
			\item Évitez absolument le \textit{No exception safety}
		\end{itemize}
	\end{alertblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Erreurs - Exception safety\titlehfill{}3/3}
	\begin{exampleblock}{Do}
		Utilisez l'idiome \textit{copy-and-swap} pour la \textit{Strong exception safety}
	\end{exampleblock}

\note[item]{Voir Exceptionnal C++ et GotW}

	\begin{lstlisting}[language=C++]
class A {
public:
  A(const A&);
  A& operator=(A);
  friend void swap(A& lhs, A& rhs); };  // Nothrow

A& A::operator=(A other) {              // Copy
  swap(*this, other);                   // And swap
  return *this;}\end{lstlisting}
\end{frame}

\begin{frame}
	\frametitle{Erreurs - Exceptions et bonnes pratiques\titlehfill{}1/2}
	\begin{exampleblock}{Do}
		\textit{Throw by value, catch by const reference} (\cite{coding} chap. 73)
	\end{exampleblock}

	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Utilisez des types dédiés héritant de \lstinline|std::exception|

\note[item]{Idéalement via \lstinline|std::logic_error| ou \lstinline|std::runtime_error|}

			\item Définissez des hiérarchies d'exceptions
		\end{itemize}
	\end{exampleblock}

	\begin{exampleblock}{Do}
		Capturez uniquement là où vous savez traiter l'erreur
	\end{exampleblock}
\end{frame}

\begin{frame}
	\frametitle{Erreurs - Exceptions et bonnes pratiques\titlehfill{}2/2}
	\begin{alertblock}{Don't}
		\begin{itemize}
			\item N'utilisez jamais les exceptions pour contrôler le flux d'exécution
			\item Ni pour gérer les \og échecs attendus\fg{}

\note[item]{P. ex. l'absence d'un élément dans une collection lors de la recherche}

			\item Réservez les exceptions au signalement d'erreurs
		\end{itemize}
	\end{alertblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Erreurs - Et \lstinline|assert| ?}
	\begin{itemize}
		\item Arrête le programme si l'expression est évalué à 0
		\item Affiche au moins l'expression, le fichier et la ligne
	\end{itemize}

	\begin{lstlisting}[language=C++]
assert(expression);\end{lstlisting}

	\begin{itemize}
		\item Sans effet lorsque \lstinline|NDEBUG| est défini :
		\begin{itemize}
			\item Coût nul en \textit{Release}
			\item Inutilisable pour les erreurs d'exécution et le contrôle des entrées
		\end{itemize}
	\end{itemize}

	\begin{block}{Objectifs}
		Traquer les erreurs de programmation et les violations de contrat interne
	\end{block}
\end{frame}

\begin{frame}
	\frametitle{Erreurs - Conclusion}
	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Utilisez exceptions ou codes retour pour les erreurs d'exécution et la vérification des données externes
			\item Réservez \lstinline|assert| aux erreurs de programmation et à la vérification des contrats internes
		\end{itemize}
	\end{exampleblock}

	\begin{exampleblock}{Do}
		Préférez les exceptions aux codes retour (\cite{coding} chap. 72)
	\end{exampleblock}

	\begin{alertblock}{Don't}
		Jamais d'\lstinline|assert| pour les erreurs d'exécution et le contrôle des entrées
	\end{alertblock}
\end{frame}

\subsection*{Gestion des ressources}
\begin{frame}[fragile]
	\frametitle{Gestion des ressources - Gestion manuelle\titlehfill{}1/3}
	\begin{alertblock}{Premier problème}
		Comment gérer les erreurs ?
	\end{alertblock}

	\begin{itemize}
		\item Solution C : \textit{Single Entry Single Exit}, bloc unique de libération
	\end{itemize}

	\begin{lstlisting}[language=C++]
FILE* file = NULL;
char* memory = NULL;
...
memory = malloc(50);
if(!memory) goto err;
...
file = fopen("bar.txt", "r");
if(!file) goto err;
...
err:
free(memory);
if(file) fclose(file);\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Ressources - Gestion manuelle\titlehfill{}2/3}
	\begin{itemize}
		\item Laborieux et source d'erreur
		\item Difficile à mettre en place en présence d'exceptions
	\end{itemize}

	\onslide<2>
	\begin{block}{Quiz : Comment éviter les fuites mémoires ?}
		\begin{lstlisting}[language=C++]
char* memory1 = NULL;
char* memory2 = NULL;
...
memory1 = new char[50];
...
memory2 = new char[200];
...
delete[] memory1;
delete[] memory2;\end{lstlisting}
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Ressources - Gestion manuelle\titlehfill{}3/3}
	\begin{alertblock}{Second problème}
		Comment copier des classes possédant des ressources ?
	\end{alertblock}

	\begin{itemize}
		\item Constructeurs et opérateurs générés copient les adresses des pointeurs
		\item La double libération est une erreur
	\end{itemize}

	\begin{lstlisting}[language=C++]
struct Foo {
public:
  Foo() : bar(new char[50]) {}
  ~Foo() { delete[] bar; }

private:
  char* bar; };\end{lstlisting}
\end{frame}

\begin{frame}
	\frametitle{Ressources - Gestion manuelle et bonnes pratiques}
	\begin{exampleblock}{Do}
		Si une classe manipule une ressource brute, elle doit :
		\begin{itemize}
			\item Soit définir constructeur de copie et opérateur d'affectation
			\item Soit les déclarer privés sans les définir (classe non copiable)
		\end{itemize}
	\end{exampleblock}

	\begin{exampleblock}{\textit{Big Rule of three}}
		Si vous devez définir l'une des trois fonctions de base que sont le constructeur de copie, l'opérateur d'affectation ou le destructeur, alors vous devriez définir les trois

\note[item]{Ou les \og désactiver\fg{} en les déclarant sans les définir}

	\end{exampleblock}

\note[item]{Forme canonique orthodoxe de Coplien}
\note[item]{Thèse de Coplien : \textit{Multi-paradigm Design}}
\end{frame}

\begin{frame}
	\frametitle{Ressources - RAII\titlehfill{}1/2}

\note[item]{C'est à dire : \textit{Resource Acquisition Is Initialization}}

	\begin{itemize}
		\item Acquisition des ressources lors de l'initialisation de l'objet
		\item Libération automatique lors de sa destruction

\note[item]{Proche du try with resources de Java ou du with de Python}

		\item Propriété intrinsèque des objets \og par design\fg{}

\note[item]{Intrinsèque à la classe contrairement à Java ou Python où c'est une propriété de l'usage}

		\item Fonctionnement de la bibliothèque standard (conteneurs, fichiers, \lstinline|auto_ptr|)
		\item Conséquences :
		\begin{itemize}
			\item Objets créés dans un état cohérent, testable et utilisable
			\item Ressources automatiquement libérées à la destruction de l'objet

\note[item]{Et de façon déterministe}
			
			\item Capsules RAII copiables sans effort
		\end{itemize}
	\end{itemize}

	\begin{exampleblock}{Do}
		Utilisez RAII pour vos objets
	\end{exampleblock}
\end{frame}

\begin{frame}
	\frametitle{Ressources - RAII\titlehfill{}2/2}
	\begin{exampleblock}{Do}
		Faites des constructeurs qui construisent des objets :
		\begin{itemize}
			\item Cohérents
			\item Utilisables
			\item Complètement initialisés (si possible)
		\end{itemize}
	\end{exampleblock}

	\begin{alertblock}{Don't}
		Évitez les couples constructeur \og vide\fg{} et fonction d'initialisation
	\end{alertblock}

	\begin{alertblock}{Don't}
		Évitez les couples constructeur \og vide\fg{} et ensemble de mutateurs

\note[item]{Ca ne signifie pas qu'il n'y ait pas de setter, seulement que le constructeur doit être \og complet\fg{}}
	\end{alertblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Ressources - Limites du RAII\titlehfill{}1/2}
	\begin{alertblock}{Gestion des erreurs}
		\begin{itemize}
			\item Pas d'erreur ni d'exception dans les destructeurs
			\item La libération peut échouer (p.ex. \lstinline|flush| lors de la fermeture de fichier)
		\end{itemize}
	\end{alertblock}

	\begin{lstlisting}[language=C++]
{
  ifstream src("input.txt");
  ofstream dst("output.txt");
  copy_files(src, dst);
}

remove_file(src);
// Potentielle perte de donnees\end{lstlisting}

\note[item]{Le problème se résout en forçant l'écriture (\lstinline|flush|) en fin de la fonction \lstinline|copy_files()| et en remontant une exception en cas d'erreur}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Ressources - Limites du RAII\titlehfill{}2/2}
	\begin{alertblock}{\lstinline|std::auto_ptr|}
		\begin{itemize}
			\item \lstinline|std::auto_ptr| est copiable
			\item Cette copie transfère la responsabilité de la ressource
		\end{itemize}
	\end{alertblock}

	\begin{lstlisting}[language=C++]
void foo(auto_ptr<int> bar) {}

auto_ptr<int> bar(new int(5));
foo(bar);
// Erreur : bar n'est plus utilisable
cout << *bar << "\n";\end{lstlisting}

\note[item]{\lstinline|std::auto_ptr| déprécié en C++11 et remplacé par \lstinline|std::unique_ptr| qui fonctionne mieux (sémantique de déplacement)}

\end{frame}

\begin{frame}
	\frametitle{Ressources - Loi de Déméter\titlehfill{}1/3}

\note[item]{À strictement parler, gestion de l'accès aux ressources pas de la libération}

	\begin{itemize}
		\item Ou principe de connaissance minimale

\note[item]{\og Ne parlez qu'à vos amis proches\fg{}}

		\item Un objet \lstinline|A| peut utiliser les services d'un deuxième objet \lstinline|B|
		\item Mais ne doit pas utiliser \lstinline|B| pour accéder à un troisième objet

\note[item]{Dit autrement : Les amis de mes amis sont de parfaits inconnus}

		\item En particulier, une classe n'expose pas ses données

		\begin{block}{Exceptions}
			Agrégats et conteneurs dont le rôle est de contenir des données

\note[item]{Agrégat désigne ici des classes, ou structures, qui agrège un ensemble de données ensembles sans comportement ni invariant. Ce n'est pas exactement la même chose que l'\textit{aggregate} du standard}
\note[item]{Certains (p.ex. Loïc Joly) utilisent aussi le terme d'agglomérat, ce qui évite la confusion}
		\end{block}
	\end{itemize}

	\begin{block}{Objectifs}
		\begin{itemize}
			\item Mise en place du RAII
			\item Meilleure encapsulation
			\item Respect des \textit{patterns} SOLID et GRASP

\note[item]{Notamment le principe ouvert-fermé, l'inversion de dépendance et le couplage faible}

			\item Meilleure lisibilité, maintenabilité et réutilisabilité
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}
	\frametitle{Ressources - Loi de Déméter\titlehfill{}2/3}
	\begin{exampleblock}{Do, agrégats}
		\begin{itemize}
			\item Préférez les structures aux classes
			\item Laissez les membres publics
			\item Fournissez, éventuellement, des constructeurs initialisant les données
		\end{itemize}

\note[item]{Pas de fonction de services dans les agrégats, éventuellement des fonctions techniques}
	\end{exampleblock}

	\begin{exampleblock}{Do, conteneurs}
		Respectez l'interface et la logique des conteneurs standard

\note[item]{Interface standard aussi utile pour point suivant (conteneurs/algorithmes)}
	\end{exampleblock}

	\begin{exampleblock}{Do, classes de service}
		\begin{itemize}
			\item Exposez des services non des données
			\item Pas de données publiques
			\item Limitez les accesseurs et encore plus les mutateurs
		\end{itemize}
	\end{exampleblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Ressources - Loi de Déméter\titlehfill{}3/3}
	\begin{block}{Conseil}
		\begin{itemize}
			\item N'hésitez pas à étendre l'interface de classe avec des fonctions libres
			\item Pensez à l'amitié pour cette interface étendue
			\item Implémentez-la en terme de fonctions membres (p.ex. \lstinline|+| à partir de \lstinline|+=|)
		\end{itemize}
	\end{block}

	\begin{lstlisting}[language=C++]
class Foo {
public:
  Foo& operator+=(const Foo& other); };

Foo operator+(Foo lhs, const Foo& rhs) {
  return lhs += rhs; }\end{lstlisting}
\end{frame}

\begin{frame}
	\frametitle{Ressources - Et le Garage Collector ?}
	\begin{itemize}
		\item Pas de GC dans le langage ni dans la bibliothèque standard
		\item Au moins un GC en bibliothèque tierce (\href{http://www.hboehm.info/gc/}{Hans Boehm})
		\item \ldots{} mais limité par manque de support par le langage
		\item Fondamentalement non déterministe : adapté à la mémoire pas aux autres ressources

\note[item]{Inadaptation à d'autres types de ressource est la raison d'être du \textit{try with resource} de Java}

		\item Particulièrement adapté à la gestion des structures cycliques

\note[item]{Gestion des cycles en RAII : \lstinline|std::shared_ptr| ou \lstinline|std::weak_ptr|, ou responsabilité déléguée à un tiers ?}

		\item D'autres avantages pour la mémoire (compactage, recyclage, \ldots)

\note[item]{Mais ces fonctionnalités évoluées des GC ne sont probablement pas compatibles avec le fonctionnement du C++}
	\end{itemize}

	\begin{block}{Wait and see}
		Un complément à RAII, pas un concurrent ni un remplaçant\\
		Indisponible à ce jour

\note[item]{Et visiblement, ce n'est pas près d'arriver, le support minimal de C++11 n'a été implémenté par aucun compilateur et risque d'être supprimé de la norme, et pas de travaux sur le sujet}
	\end{block}
\end{frame}

\begin{frame}
	\frametitle{Ressources - Conclusion\titlehfill{}1/2}
	\begin{exampleblock}{Do}
		Utilisez RAII
		\begin{itemize}
			\item Préférez les classes RAII de la bibliothèque standard aux ressources brutes
			\item Encapsulez les ressources dans des capsules RAII standard
			\item Concevez vos classes en respectant le RAII
		\end{itemize}
	\end{exampleblock}

	\begin{exampleblock}{Do}
		Respectez Déméter
	\end{exampleblock}
\end{frame}

\begin{frame}
	\frametitle{Ressources - Conclusion\titlehfill{}2/2}
	\begin{alertblock}{Don't}
		Pas de \lstinline|delete| dans le code applicatif

\note[item]{\lstinline|delete| dans les classes bas niveau qui définissent des capsules RAII}
	\end{alertblock}

	\begin{alertblock}{Attention}
		\begin{itemize}
			\item Sous Linux, méfiez-vous de l'\textit{Optimistic Memory Allocator}

\note[item]{Retourne une adresse lors d'un \lstinline|new| ou d'un \lstinline|malloc()| sans allocation avec peu de contrôle}
\note[item]{Allocation uniquement lors de l'usage de la mémoire}
\note[item]{Si manque de mémoire à ce moment : une application est tuée (probablement le demandeur ou la plus gourmande, influence du \textit{uptime}, de la priorité ou du propriétaire ?) mais jamais \lstinline|init|}
\note[item]{Pourquoi OMA : les logiciels demandent plus de mémoire que ce qu'ils utilisent réellement}

			\item Pensez à paramétrer correctement l'OS
		\end{itemize}
	\end{alertblock}
\end{frame}

\subsection*{STL}
\begin{frame}
	\frametitle{STL - Standard Template Library\titlehfill{}1/3}
	\begin{itemize}
		\item Partie de la bibliothèque standard comprenant

\note[item]{Formellement, la STL n'existe plus dans la norme C++ actuelle.}

		\begin{itemize}
			\item Conteneurs et \lstinline|std::basic_string| : données

\note[item]{\lstinline|std::basic_string| contient, est template et a une interface \og conteneurs\fg{}. Mais a une sémantique particulière et n'est pas remplaçable de ce fait et possède des algorithmes spécifiques}

			\item Itérateurs : parcours des conteneurs
			\item Algorithmes : manipulation des données via les itérateurs
		\end{itemize}
	\end{itemize}

	\begin{block}{Note}
		Quelques algorithmes manipulant directement des données (p.ex. \lstinline|std::min()|)
	\end{block}

	\begin{itemize}
		\item Conçue initialement par Alexander Stepanov :
		\begin{itemize}
			\item Promoteur de la programmation générique

\note[item]{Programmation générique : template en C++, \lstinline|generic| en Java}
\note[item]{Programmation générique = polymorphisme paramétrique}

			\item Sceptique vis à vis de la POO

\note[item]{Pour Stepanov : POO = hoax (canular)}
\note[item]{Stepanov a de vrais arguments et cible davantage le marketing survendeur (\textit{silver bullet}) et les promesses non tenues que la POO elle-même}
\note[item]{Stepanov ne s'oppose pas à l'abstraction et à encapsulation mais à la façon dont la POO prétend y répondre}

		\end{itemize}
		\item Basée sur les templates, pas de POO

\note[item]{Pas de POO dans la STL : utilisation de classes (abstraction, modularité) mais ni polymorphisme de sous-typage ni \textit{dynamic dispatch}}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{STL - Standard Template Library\titlehfill{}2/3}
	\begin{block}{Intérêts}
		\begin{itemize}
			\item $n$ conteneurs et $m$ algorithmes, seulement $m$ implémentations

\note[item]{Seulement $m$ implémentations vs. $n * m$ pour modèle objet avec algorithme sous forme de fonctions membres}

			\item Tout nouvel algorithme est disponible sur tous conteneurs compatibles
			\item Tout nouveau conteneur bénéficie de tous les algorithmes compatibles

\note[item]{Compatible, c'est à dire que le conteneur fournit un itérateur permettant les opérations requises par l'algorithme}

			\item Changement de conteneur à effort réduit
		\end{itemize}
	\end{block}

	\begin{block}{Pour aller plus loin}
		\cite{effStl} de Scott Meyers
	\end{block}
\end{frame}

\begin{frame}
	\frametitle{STL - Standard Template Library\titlehfill{}3/3}
	\begin{block}{À nuancer}
		Algorithmes membres sur certains conteneurs
		\begin{itemize}
			\item Accès par itérateurs insuffisant (p.ex. \lstinline|std::list|)
			\item Habitudes et historiques (p.ex. \lstinline|std::string|)
			\item Performances (p.ex. \lstinline|map.find()|)
		\end{itemize}
	\end{block}
\end{frame}

\subsection*{STL - Conteneurs}
\begin{frame}[fragile]
	\frametitle{STL Conteneurs - Généralités}
	\begin{itemize}
		\item Contiennent des objets copiables et non constants

\note[item]{En C++11 et suivante : copiables ou déplaçable}
\note[item]{On peut avoir des conteneurs \lstinline|const| et donc ne pas pouvoir modifier les éléments, mais on ne peut pas avoir de conteneur de \lstinline|const|}

		\item \ldots{} qui peuvent être les adresses d'autres objets

		\begin{alertblock}{Conteneurs de pointeurs}
			Pas de libération automatique des objets \og pointés\fg{}
		\end{alertblock}

		\item \ldots{} accessibles via un itérateur
		\item Fourniture possible d'une politique d'allocation
		\item Vu des algorithmes, tout ce qui fournit une paire d'itérateurs, est un conteneur
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Conteneurs - Conteneurs séquentiels\titlehfill{}1/3}
	\begin{itemize}
		\item \lstinline|std::vector|
		\begin{itemize}
			\item Tableau de taille variable d'éléments contigus
			\item Accès indexé
			\item Croissance en temps amorti
			\item Modifications en fin de vecteur (couteux ailleurs)

\note[item]{Couteux d'insérer/retirer ailleurs qu'en fin car il faut déplacer les données}
\note[item]{Possible d'échanger puis de retirer à la fin (si l'ordre n'est pas important)}

			\item Compatible avec l'organisation mémoire des tableaux C

\note[item]{Passage à un tableau C en prenant l'adresse du premier élément : \lstinline|T* ptr = &vec[0];|}

		\end{itemize}
	\end{itemize}

	\begin{alertblock}{\lstinline|std::vector<bool>| n'est pas un vecteur de booléen}
		\begin{itemize}
			\item Ne remplit pas tous les pré-requis des conteneurs
			\item \lstinline|operator[]| ne retourne pas le booléen mais un \textit{proxy} vers celui-ci
			\item Voir \cite{effStl} item 18

\note[item]{Impossible de prendre l'adresse de \lstinline|v[0]| d'un \lstinline|vector<bool>|}

		\end{itemize}
	\end{alertblock}

	\begin{exampleblock}{Le conteneur par défaut}
	\end{exampleblock}
\end{frame}

\begin{frame}
	\frametitle{STL Conteneurs - Conteneurs séquentiels\titlehfill{}2/3}
	\begin{itemize}
		\item \lstinline|std::list|
		\begin{itemize}
			\item Liste doublement chaînée
			\item Accès bidirectionnel non indexé
			\item Modification n'importe où à faible coût
			\item Plusieurs algorithmes membres (tri, fusion, suppression, \ldots)

\note[item]{Algorithmes membres pour la liste car accès non indexé}
		\end{itemize}

		\item \lstinline|std::deque|
		\begin{itemize}
			\item \textit{Double-ended queue}
			\item Proche de \lstinline|std::vector| mais extensible aux deux extrémités
			\item Accès indexé
			\item Éléments non nécessairement contigus
			\item Non compatible avec l'organisation mémoire des tableaux C
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{STL Conteneurs - Conteneurs séquentiels\titlehfill{}3/3}
	\begin{itemize}
		\item \lstinline|std::string|
		\begin{itemize}
			\item Alias de \lstinline|std::basic_string<char>|
			\item Stockage de chaînes de caractères
			\item Manipulation de \og \textit{bytes}\fg{} et non de caractères encodés

			\begin{alertblock}{\lstinline|std::string| et UTF-8}
				\lstinline|length()| et \lstinline|size()| retournent le nombre de \textit{bytes}, pas de caractères
			\end{alertblock}

			\item Contiguïté non garantie, mais respectée en pratique

\note[item]{Contiguïté garantie en C++11 et suivant}
\note[item]{Pas d'implémentation non contigüe connue}

			\item Un cousin peu utilisé pour les caractères larges : \lstinline|std::wstring|

			\begin{alertblock}{Une API trop riche}
				\begin{itemize}
					\item De nombreuses fonctions membres qui gagneraient à être libres et génériques
					\item Voir \href{http://www.gotw.ca/gotw/084.htm}{GotW \#84 : Monoliths "Unstrung"}
				\end{itemize}
			\end{alertblock}
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{STL Conteneurs - Conteneurs associatifs}
	\begin{itemize}
		\item Quatre saveurs
		\begin{itemize}
			\item \lstinline|std::map| : clés-valeurs, ordonné par la clé, unicité des clés
			\item \lstinline|std::multimap| : clés-valeurs, ordonné par la clé, multiplicité des clés
			\item \lstinline|std::set| : valeurs ordonnées et uniques
			\item \lstinline|std::multiset| : valeurs ordonnées et non-uniques
		\end{itemize}

		\begin{alertblock}{Pas des tables de hachage}
			Généralement implémentés sous forme d'arbres binaires de recherche balancés

\note[item]{\textit{red-black tree} le plus souvent}
		\end{alertblock}

		\item Critère d'ordre est configurable (strictement inférieur par défaut)

		\begin{alertblock}{Attention}
			Critère d'ordre strict
		\end{alertblock}

		\item Algorithmes membres (recherche) pour les performances
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{STL Conteneurs - Adaptateurs\titlehfill{}1/2}
	\begin{itemize}
		\item Basés sur un autre conteneur pour proposer une API simplifiée
		\item Avantages et inconvénients du conteneur sous-jacent
		\item \lstinline|std::stack|
		\begin{itemize}
			\item Pile LIFO
			\item Basée sur \lstinline|std::vector|, \lstinline|std::list| ou \lstinline|std::deque|
		\end{itemize} 
		\item \lstinline|std::queue|
		\begin{itemize}
			\item File FIFO
			\item Basée sur \lstinline|std::deque| ou \lstinline|std::list|
		\end{itemize} 
		\item \lstinline|std::priority_queue|
		\begin{itemize}
			\item File dont l'élément de tête est le plus grand
			\item Basée sur \lstinline|std::vector| ou \lstinline|std::deque|
			\item Critère d'ordre configurable (strictement inférieur par défaut)
		\end{itemize} 
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Conteneurs - Adaptateurs\titlehfill{}2/2}
	\begin{lstlisting}[language=C++]
stack<int, vector<int> > foo;
for(int i=0; i<5; ++i) foo.push(i);

// Affiche 4 3 2 1 0
while(!foo.empty()) {
  cout << ' ' << foo.top();
  foo.pop(); }\end{lstlisting}
\end{frame}

\begin{frame}
	\frametitle{STL Conteneurs - conteneurs non-STL}

\note[item]{\lstinline|std::valarray| laissé de côté, pas vraiment un conteneur}

	\begin{itemize}
		\item \lstinline|std::bitset| :
		\begin{itemize}
			\item Tableau de bits de taille fixe (paramètre template)
			\item Conçu pour réduite l'empreinte mémoire
			\item Pas d'itérateur ni d'interface \og STL\fg{}

			\begin{block}{\lstinline|std::bitset| et \lstinline|std::vector<bool>|}
				Objectif de gain mémoire déjà adressé par \lstinline|std::bitset| plus adapté, pourquoi \lstinline|std::vector<bool>| n'est-il pas un vrai conteneur de booléen ?
			\end{block}

		\end{itemize}
		\item Conteneurs non-standard :
		\begin{itemize}
			\item Listes simplement chaînées
			\item Tables de hachage
			\item Tableaux de taille fixe
			\item Tampons circulaires
			\item Arbres et graphes
			\item Variantes de conteneurs \og STL\fg{} (p.ex. \og \textit{ropes}\fg{})

\note[item]{\textit{Ropes} : chaîne découpée en morceaux reliés par une liste ou un arbre. Permet les modification à l'intérieur de la chaîne, résout des problème d'espace mémoire contigu trop faible}
\note[item]{\lstinline|std::string| peut être implémentée sous forme de \textit{ropes} en C++98/03, plus en C++11}
\note[item]{Variantes ciblant un autre compromis : listes en tableau, \textit{ropes}, \textit{map} \og à plat\fg{}, etc.}
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{STL Conteneurs - \lstinline|std::pair|}
	\begin{itemize}
		\item Couple de deux valeurs
		\item Pas un conteneur
		\begin{itemize}
			\item Type de retour de la recherche sur les \lstinline|std::map| (couple clé-valeur)
			\item Candidat pour construire des vecteurs indexés par un non-numérique
		\end{itemize}
		\item \lstinline|std::make_pair| construit une paire
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{STL Conteneurs - Choix du conteneur\titlehfill{}1/2}
	\begin{exampleblock}{Do, par défaut}
		\begin{itemize}
			\item \lstinline|std::string| pour les chaînes de caractères
			\item \lstinline|std::vector|
		\end{itemize}
	\end{exampleblock}		

	\begin{exampleblock}{Do, performances}
		Mesurez avec des données réelles sur la configuration cible
	\end{exampleblock}

	\begin{alertblock}{Flux d'octets}
		\lstinline|std::vector<unsigned char>|, pas \lstinline|std::vector<char>| encore moins \lstinline|std::string|
	\end{alertblock}
\end{frame}

\begin{frame}
	\frametitle{STL Conteneurs - Choix du conteneur\titlehfill{}2/2}
	\begin{block}{Conseils}
		\begin{itemize}
			\item Voir \cite{effStl} item 1
			\item Pensez à \lstinline|reserve()|
			\item Une insertion \og en vrac\fg{} suivie d'un tri peut être plus efficace qu'une insertion en place

\note[item]{Voir overload 134 (août 2016) sur big O et les performances \lstinline|std::vector|/\lstinline|std::string|. Et l'importance de la localité des données}

			\item Un vecteur de paires peut être un bon choix pour un ensemble de clés-valeurs
		\end{itemize}
	\end{block}
\end{frame}

\subsection*{STL - Itérateurs}
\begin{frame}
	\frametitle{STL Itérateurs - Généralités}
	\begin{itemize}
		\item Abstraction permettant le parcours des collections d'objets
		\item Interaction entre conteneurs et algorithmes
		\item Interface similaire à celle d'un pointeur
		\item Quatre types :
		\begin{itemize}
			\item \lstinline|iterator| et \lstinline|const_iterator|
			\item \lstinline|reverse_iterator| et \lstinline|const_reverse_iterator|

\note[item]{Les \lstinline|const_iterator| sont des itérateurs itérant sur des valeurs constantes, ils peuvent être utilisés pour lire des données mais pas pour les écrire}

		\end{itemize}
		\item Itérateurs sur un conteneur : \lstinline|begin()| et \lstinline|end()|
		\item Itérateurs inverses sur un conteneur : \lstinline|rbegin()| et \lstinline|rend()|
		\item Les itérateurs d'une paire doivent appartenir au même conteneur
	\end{itemize}

	\begin{alertblock}{Itérateurs de fin}
		Pointent un élément après le dernier\\
		Ne doivent pas être déréférencés ni incrémentés
	\end{alertblock}

\note[item]{Un élément après la fin permet de représenter des ensemble vide (si \lstinline|begin| et \lstinline|end| référence le même élément)}

\end{frame}

\begin{frame}
	\frametitle{STL Itérateurs - Catégories et opérations}
	\begin{columns}[T]
		\begin{column}{0.80\textwidth}
			\begin{itemize}
				\item Opérations communes : copie, affectation et incrémentation
				\item Hiérarchie de cinq catégories :
				\begin{itemize}
					\item \textit{Input} : égalité (\lstinline|==| et \lstinline|\!=|) et lecture
					\item \textit{Output} : écriture
					\item \textit{Forward} : Parcours multiples

\note[item]{I.e. \og l'incrément ne consomme pas de donnée\fg{}}
\note[item]{Plus formellement, \lstinline|a == b| implique \lstinline|++a == ++b| et utiliser un itérateur sur une séquence ne modifie pas ce que référence un autre itérateur indépendant, c'est à dire que \lstinline|b=a; ++b; *a;| est équivalent à \lstinline|*a|}

					\item \textit{Bidirectional} : décrémentation
					\item \textit{Random access} : 
					\begin{itemize}
						\item Déplacement d'un nombre arbitraire (\lstinline|+|, \lstinline|-|, \lstinline|+=|, \lstinline|-=| et \lstinline|[]|)
						\item Comparaison (\lstinline|<|, \lstinline|<=|, \lstinline|>|, \lstinline|>=|)
					\end{itemize} 
				\end{itemize}
			\end{itemize}
		\end{column}

		\begin{column}{0.20\textwidth}
			\centering
			\adjincludegraphics[height=0.5\textheight]{input_src/Iterator_hierarchie.png}
		\end{column}
	\end{columns}

	\begin{alertblock}{Attention}
		Seules les versions mutables de \textit{Forward}, \textit{Bidirectional} et \textit{Random access} itérateurs sont des \textit{Output} itérateurs.
	\end{alertblock}
\end{frame}

\begin{frame}
	\frametitle{STL Itérateurs - Catégories et conteneurs}
	\begin{tabular}{ | p{5cm} | p{5cm} |}
		\hline
		Conteneur & Catégorie \\ 
		\hline
		\lstinline{std::vector} & \textit{Random access} \\ 
		\hline
		\lstinline{std::deque} & \textit{Random access} \\ 
		\hline
		\lstinline{std::list} & \textit{Bidirectionnal} \\ 
		\hline
		\lstinline{std::map} et \lstinline{std::multimap} & \textit{Bidirectionnal} \\ 
		\hline
		\lstinline{std::set} et \lstinline{std::multiset} & \textit{Bidirectionnal} \\ 
		\hline
	\end{tabular} 
\end{frame}

\begin{frame}
	\frametitle{STL Itérateurs - Itérateur d'insertion}
	\begin{itemize}
		\item Itérateurs de type \textit{Output}

\note[item]{En fait, ce sont des adaptateurs d'itérateurs}

		\item Insertion de nouveaux éléments

\note[item]{Les itérateurs classiques pointent sur des éléments existants du conteneur}

		\item Trois types :
		\begin{itemize}
			\item Insertion en queue : \lstinline|back_inserter|
			\item Insertion en tête : \lstinline|front_inserter|
			\item Insertion à la position courante : \lstinline|inserter|

\note[item]{La disponibilité de tel ou tel itérateur d'insertion dépend du conteneur}

		\end{itemize}
	\end{itemize}
\end{frame}

\subsection*{STL - Algorithmes}
\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Function Object\titlehfill{}1/2}
	\begin{itemize}
		\item Instance de classe définissant \lstinline|operator()()|

\note[item]{Appelés \textit{functor} en anglais on foncteur en français}
		\end{itemize}

	\begin{lstlisting}[language=C++]
class LessThan {
public:
  explicit LessThan(int threshold)
    : m_threshold(threshold) {}
  bool operator() (int value) { 
    return value <= m_threshold;}

private:
  int const m_threshold; };

LessThan func(10);
cout << func(5) << "\n";   // 1\end{lstlisting}
\end{frame}

\begin{frame}
	\frametitle{STL Algorithmes - Function Object\titlehfill{}2/2}
	\begin{itemize}
		\item Possèdent données membres

\note[item]{Ce qui représente un avantage sur les fonctions libres}

		\item \textit{Function Objects} standard : \lstinline|plus|, \lstinline|minus|, \lstinline|equal|, \lstinline|less|, \ldots
		\item Constructibles
		\begin{itemize}
			\item Depuis des pointeurs de fonctions : \lstinline|prt_fun|
			\item Depuis des fonctions membres : \lstinline|mem_fun|, \lstinline|mem_fun1|, \ldots
			\item En niant d'autres \textit{Function Objects} : \lstinline|not1|, \lstinline|not2|
			\item En fixant des paramètres : \lstinline|bind1st|, \lstinline|bind2nd|
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{STL Algorithmes - Prédicats}
	\begin{itemize}
		\item \og Appelable\fg{} retournant un booléen (ou un type convertible en booléen)

\note[item]{Foncteur ou pointeur de fonction}

		\item Utilisés par de nombreux algorithmes
		\item De nombreux algorithmes utilisent un prédicat par défaut (p.ex. \lstinline|<| ou \lstinline|==|)

\note[item]{Prédicat par défaut qui peut être remplacé}

	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Parcours\titlehfill{}1/2}
	\begin{itemize}
		\item \lstinline|std::for_each()| parcourt un ensemble d'éléments
		\item \ldots{} et applique un traitement à chaque élément
	\end{itemize}

	\begin{lstlisting}[language=C++]
void print(int i) { cout << i << ' '; }

vector<int> foo{4, 5, 9 ,12};
for_each(foo.begin(), foo.end(), print);\end{lstlisting}

	\begin{alertblock}{Syntaxe}
		Les exemples utilisent une initialisation de conteneur introduite pas C++11
	\end{alertblock}

	\begin{itemize}
		\item Version du \textit{map/apply} fonctionnel
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Parcours\titlehfill{}2/2}
	\begin{itemize}
		\item Retourne le \textit{Function Object} passé en paramètre
	\end{itemize}

	\begin{lstlisting}[language=C++]
struct Aggregate {
  Aggregate() : m_sum(0) {}
  void operator() (int i) { m_sum += i;}
  int m_sum; };

vector<int> foo{4, 5, 9 ,12};
for_each(foo.begin(), foo.end(), Aggregate()).m_sum; // 30\end{lstlisting}

	\begin{itemize}
		\item Candidat pour le \textit{fold/reduce} fonctionnel
		\item Pas de sémantique, faible utilité

\note[item]{Pas de sémantique : simple parcours}
\note[item]{Gain limité par rapport à for, d'autant que le code est coupé en deux et encore plus par rapport aux algorithmes}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Recherche linéaire\titlehfill{}1/2}
	\begin{itemize}
		\item \lstinline|std::find()| recherche une valeur
		\item \ldots{} et retourne un itérateur sur celle-ci
		\item \ldots{} ou l'itérateur de fin si la valeur n'est pas présente
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{4, 5, 9 ,12};
vector<int>::iterator it1;
vector<int>::iterator it2

// it1 pointe sur foo[1]
it1 = find(foo.begin(), foo.end(), 5);
// Et it2 sur foo.end()
it2 = find(foo.begin(), foo.end(), 19);\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Recherche linéaire\titlehfill{}2/2}
	\begin{itemize}
		\item \lstinline|std::find_if()| recherche depuis un prédicat

		\begin{block}{Variante \og \lstinline|_if|\fg{}}
			Les algorithmes suffixés par \lstinline|_if| utilise un prédicat plutôt qu'une valeur
		\end{block}

		\item \lstinline|std::find_first_of()| recherche la première occurrence d'un élément
		\item \lstinline|std::search()| recherche la première occurrence d'un sous-ensemble
		\item \lstinline|std::find_end()| recherche la dernière occurrence d'un sous-ensemble
		\item \lstinline|std::adjacent_find()| recherche deux éléments consécutifs égaux
		\item \lstinline|std::search_n()| recherche la première suite de n éléments consécutifs égaux à une valeur

\note[item]{\lstinline|find_first_of()|, \lstinline|find_end()|, \lstinline|adjacent_find()|, \lstinline|search()| et \lstinline|search_n()| peuvent prendre un prédicat de comparaison, sinon c'est la comparaison par défaut qui s'applique}
\note[item]{Toutes retournent un itérateur sur l'élément (le premier dans le cas de la recherche d'un ensemble) recherché}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Recherche dichotomique\titlehfill{}1/3}
	\begin{itemize}
		\item Pré-requis : ensemble trié
		
\note[item]{Ensemble trié au sens du prédicat de comparaison}
		
		\item \lstinline|std::lower_bound()| retourne un itérateur sur le premier élément non strictement inférieur à la valeur recherchée

\note[item]{Formulation \og n'est pas strictement inférieur\fg{} semble être une tournure compliquée pour supérieur ou égal, mais c'est précisément ce que fait la fonction et c'est important si on fourni un prédicat de comparaison}
\note[item]{Un prédicat de comparaison peut être fourni, sinon c'est \lstinline|<| qui s'applique}

		\item \ldots{} et l'itérateur de fin si un tel élément n'existe pas
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{4, 5, 7, 9, 12};

*lower_bound(foo.begin(), foo.end(), 6);  // 7
*lower_bound(foo.begin(), foo.end(), 9);  // 9\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Recherche dichotomique\titlehfill{}2/3}
	\begin{itemize}
		\item \lstinline|std::upper_bound()| retourne un itérateur sur le premier élément strictement supérieur à la valeur recherchée 
		\item \lstinline|std::equal_range()| retourne la paire (\lstinline|lower_bound|, \lstinline|upper_bound|)

		\begin{alertblock}{Attention}
			Le résultat retourné peut ne pas être la valeur recherchée
		\end{alertblock}

		\item \lstinline|std::binary_search()| indique si l'élément cherché est présent
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Recherche dichotomique\titlehfill{}3/3}
	\begin{alertblock}{Attention}
		Pas de fonction de recherche dichotomique retournant l'élément cherché s'il existe, il faut bâtir cette recherche sur ces fonctions élémentaires
	\end{alertblock}

	\begin{lstlisting}[language=C++]
vector<int>::iterator foo(vector<int> vec, int val) {
  vector<int>::iterator it = 
    lower_bound(vec.begin(), vec.end(), val);
  if(it != vec.end() && *it == val) return it;
  else return vec.end(); }

vector<int> bar{1, 5, 8, 13, 25, 42};
foo(bar, 12);  // vec.end
foo(bar, 13);  // iterateur sur 13
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Comptage}
	\begin{itemize}
		\item \lstinline|std::count()| compte le nombre d'éléments égaux à la valeur fournie
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{4, 5, 3, 9, 5, 5 ,12};

count(foo.begin(), foo.end(), 5);  // 3
count(foo.begin(), foo.end(), 2);  // 0\end{lstlisting}

	\begin{itemize}
		\item \lstinline|std::count_if()| compte le nombre d'éléments satisfaisant le prédicat
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Comparaison\titlehfill{}1/3}
	\begin{itemize}
		\item \lstinline|std::equal()| teste l'égalité de deux ensembles (valeur et position)
	\end{itemize}

\note[item]{Possibilité de fournir un prédicat de comparaison (== sinon)}

	\begin{lstlisting}[language=C++]
vector<int> foo{4, 5, 9, 12};
vector<int> bar{4, 5, 12, 9};

equal(foo.begin(), foo.end(), foo.begin());  // true
equal(foo.begin(), foo.end(), var.begin());  // false\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Comparaison\titlehfill{}2/3}
	\begin{alertblock}{Attention}
		\lstinline|std::equal()| ne vérifie pas les tailles des deux ensembles
	\end{alertblock}

\note[item]{Il compare sur la taille du premier ensemble (pour lequel il y a un couple \textit{begin/end})}
\note[item]{Il faut donc s'assurer au préalable des tailles et vérifier les \textit{overflow}}
\note[item]{C++14 ajoute des surcharges de \lstinline|std::equal()| testant la taille}

	\begin{block}{Et \lstinline|operator==| ?}
		\lstinline|operator==()| sur des conteneurs teste la taille et le contenu
	\end{block}

	\begin{exampleblock}{Do}
		Préférez l'opérateur \lstinline|==| à \lstinline|std::equal()| pour comparer un conteneur complet
	\end{exampleblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Comparaison\titlehfill{}3/3}
	\begin{itemize}
		\item \lstinline|std::mistmatch()| retourne une paire d'itérateurs sur les premiers éléments différents
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{4, 5, 9, 13};
vector<int> var{4, 5, 12, 8};

mismatch(foo.begin(), foo.end(), bar.begin());  // 9 12\end{lstlisting}

	\begin{itemize}
		\item Ou l'itérateur de fin en cas d'égalité
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Remplissage\titlehfill{}1/2}
	\begin{itemize}
		\item \lstinline|std::fill()| remplit l'ensemble avec la valeur fournie
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo(4);

fill(foo.begin(), foo.end(), 12);  // 12 12 12 12\end{lstlisting}

	\begin{itemize}
		\item \lstinline|std::fill_n()| idem avec un ensemble défini par sa taille
	\end{itemize}

	\begin{block}{Constructeur et remplissage}
		Remplissage des conteneurs séquentiels à la construction : \lstinline|vector<int> foo(4, 12);|
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Remplissage\titlehfill{}2/2}
	\begin{itemize}
		\item \lstinline|std::generate()| valorise les éléments à partir d'un générateur
	\end{itemize}

	\begin{lstlisting}[language=C++]
int gen() {
  static int i = 0;
  i += 5;
  return i; }

vector<int> foo(4);
generate(foo.begin(), foo.end(), gen);  // 5 10 15 20\end{lstlisting}

	\begin{itemize}
		\item \lstinline|std::generate_n()| idem avec un ensemble défini par sa taille
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Copie}
	\begin{itemize}
		\item \lstinline|std::copy()| copie les éléments (du début vers la fin)
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{4, 5, 9, 12};
vector<int> bar;

copy(foo.begin(), foo.end(), back_inserter(bar));\end{lstlisting}

\note[item]{\lstinline|std::copy()| : l'itérateur du second ensemble est l'itérateur de début.}

	\begin{itemize}
		\item \lstinline|std::copy_backward()| copie les éléments (de la fin vers le début)
	\end{itemize}

\note[item]{\lstinline|std::copy_backward()| : l'itérateur du second ensemble est son itérateur de fin}
\note[item]{L'ordre relatif est préservé}

	\begin{alertblock}{Attention}
		\begin{itemize}
			\item À la taille du second ensemble

\note[item]{Il faut un second ensemble assez grand ou utiliser un itérateur d'insertion}

			\item Aux ensembles non-disjoints

\note[item]{L'itérateur du second ensemble ne doit pas pointé un élément du premier ensemble.}
		\end{itemize}
	\end{alertblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Échange}
	\begin{itemize}
		\item \lstinline|std::swap()| échange deux objets
	\end{itemize}

	\begin{lstlisting}[language=C++]
int x=10, y=20;   // x:10 y:20
swap(x,y);        // x:20 y:10\end{lstlisting}

	\begin{itemize}
		\item \lstinline|std::swap_ranges()| échange des éléments de deux ensembles
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo (5,10); // foo: 10 10 10 10 10
vector<int> bar (5,33); // bar: 33 33 33 33 33

swap_ranges(foo.begin()+1, foo.end()-1, bar.begin());
// foo : 10 33 33 33 10, bar : 10 10 10 33 33\end{lstlisting}

	\begin{itemize}
		\item \lstinline|std::iter_swap()| échange deux objets pointés par des itérateurs
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Remplacement\titlehfill{}1/2}
	\begin{itemize}
		\item \lstinline|std::replace()| remplace toutes les occurrences d'une valeur par une autre
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{4, 5, 7, 9 ,12, 5};

replace(foo.begin(), foo.end(), 5, 8);  // 4 8 7 9 12 8\end{lstlisting}

	\begin{itemize}
		\item \lstinline|std::replace_if()| remplace toutes les éléments vérifiant le prédicat par une valeur donnée
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Remplacement\titlehfill{}2/2}
	\begin{itemize}
		\item \lstinline|std::replace_copy()| copie les éléments d'un ensemble en remplaçant toutes les occurrences d'une valeur par une autre

		\begin{block}{Variante \og \lstinline|_copy|\fg{}}
			Les algorithmes suffixés par \lstinline|_copy| fonctionne comme l'algorithme de base en troquant la modification en place contre une copie du résultat
		\end{block}

		\item \lstinline|std::replace_copy_if()| copie les éléments d'un ensemble en remplaçant toutes les éléments vérifiant le prédicat par une valeur donnée
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Suppression\titlehfill{}1/2}
	\begin{itemize}
		\item \lstinline|std::remove()| \og élimine\fg{} les éléments égaux à une valeur donnée
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{4, 5, 5, 5, 7, 9, 9, 5};
remove(foo.begin(), foo.end(), 5);    // 4 7 9 9 ...\end{lstlisting}

\note[item]{La comparaison se fait via l'opérateur \lstinline|==| et n'est pas paramétrable}

	\pause

	\begin{alertblock}{Pas de suppression}
		\lstinline|std::remove()| ramène les éléments à conserver vers le début de l'ensemble et retourne l'itérateur correspond à la nouvelle fin
	\end{alertblock}

\note[item]{\lstinline|std::remove()| ne supprime pas car les algorithmes ne peuvent pas modifier le conteneur, en particulier sa taille, mais seulement le contenu de ses éléments}

	\pause

	\begin{block}{Idiome \textit{Erase-Remove}}
		Suppression via un appel à \lstinline|erase()| sur les éléments après le nouvel itérateur de fin
	
		\begin{lstlisting}[language=C++]
foo.erase(remove(foo.begin(),foo.end(),5),foo.end());\end{lstlisting}
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Suppression\titlehfill{}2/2}
	\begin{itemize}
		\item \lstinline|std::remove_if()| \og élimine\fg{} les éléments vérifiant le prédicat
		\item \lstinline|std::remove_copy()| copie les éléments différents d'une valeur donnée
		\item \lstinline|std::remove_copy_if()| copie les éléments ne vérifiant pas le prédicat
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Suppression des doublons}
	\begin{itemize}
		\item \lstinline|std::unique()| \og élimine\fg{} les éléments consécutifs égaux sauf le premier
	\end{itemize}

\note[item]{Tout comme \lstinline|remove|, les éléments ne sont pas supprimés du conteneur mais déplacé à la fin et l'itérateur correspondant est renvoyé}
\note[item]{Un prédicat de comparaison peut être fourni, sinon \lstinline|operator==| est utilisé}
\note[item]{L'ordre relatif est préservé, important si la comparaison ne se fait que sur une partie d'un élément composite}

	\begin{lstlisting}[language=C++]
vector<int> foo{4, 5, 5, 5, 7, 9, 9, 5};

unique(foo.begin(), foo.end());  // 4 5 7 9 5 ... \end{lstlisting}

	\begin{itemize}
		\item \lstinline|std::unique_copy()| copie l'ensemble en ne conservant que le premier des éléments consécutifs égaux
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Transformation\titlehfill{}1/2}
	\begin{itemize}
		\item \lstinline|std::transform()| applique une transformation aux éléments d'un ensemble
	\end{itemize}

	\begin{lstlisting}[language=C++]
int double_val(int i) { return 2 * i;}

vector<int> foo{4, 5, 7, 9};
vector<int> bar(4);
transform(foo.begin(), foo.end(), bar.begin(), double_val);
// 8 10 14 18\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Transformation\titlehfill{}2/2}
	\begin{itemize}
		\item Ou de deux ensembles en stockant le résultat dans un troisième
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{4, 5, 7, 9};
vector<int> bar{2, 3, 6, 1};
vector<int> baz(4);

transform(foo.begin(), foo.end(), bar.begin(), 
          baz.begin(), plus<int>());
// 6 8 13 10\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Rotation}
	\begin{itemize}
		\item \lstinline|std::rotate()| effectue une rotation de l'ensemble, le nouveau début étant fourni par un itérateur
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{4, 5, 7, 9, 12};

rotate(foo.begin(), foo.begin() + 2, foo.end());
// 7 9 12 4 5\end{lstlisting}

	\begin{itemize}
		\item \lstinline|std::rotate_copy()| effectue une rotation et copie le résultat
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Partitionnement\titlehfill{}1/3}
	\begin{itemize}
		\item \lstinline|std::partition()| réordonne l'ensemble pour que les éléments vérifiant le prédicat soit avant ceux ne le vérifiant pas \ldots
	\end{itemize}

	\begin{lstlisting}[language=C++]
bool is_odd(int i) { return (i%2)==1; }

vector<int> foo{4, 13, 28, 9 , 54};
partition(foo.begin(), foo.end(), is_odd);
// 9 13 28 4 54 ou 9 13 4 28 54 ou ...)\end{lstlisting}

\note[item]{Le prédicat \lstinline|is_odd| sera utilisé par la suite sans être redéfini à chaque fois}

	\begin{itemize}
		\item \ldots{} et retourne un itérateur sur le début de la seconde partie
	\end{itemize}

	\begin{alertblock}{Attention}
		Ordre relatif non conservé
	\end{alertblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Partitionnement\titlehfill{}2/3}
	\begin{itemize}
		\item \lstinline|std::stable_partition()| partitionne en conservant l'ordre relatif
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{4, 13, 28, 9 , 54};

stable_partition(foo.begin(), foo.end(), is_odd);
// 13 9 4 28 54\end{lstlisting}

	\pause

	\begin{block}{Pourquoi deux fonctions ?}
		Performance : la stabilité est couteuse en temps et pas toujours nécessaire
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Partitionnement\titlehfill{}3/3}
	\begin{itemize}
		\item \lstinline|std::nth_element()| réordonne les éléments :
		\begin{itemize}
			\item Élément sur l'itérateur pivot est celui qui serait à cette place si l'ensemble était trié
			\item Éléments avant ne sont pas supérieurs
			\item Éléments après ne sont pas inférieurs
			\item Pas d'ordre particulier au sein des deux sous-ensembles
		\end{itemize}
	\end{itemize}

\note[item]{Possibilité de fournir un prédicat de comparaison, \lstinline|operator<| par défaut}
\note[item]{Formulation \og pas supérieur\fg{} étrange mais gère le cas des égalités avec le pivot et la sémantique de l'opérateur fourni}

	\begin{lstlisting}[language=C++]
vector<int> foo{9, 8, 7, 6, 5, 4, 3, 2, 1};

nth_element(foo.begin(), foo.begin() + 3, foo.end());
// 2 1 3 4 5 9 6 7 8\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Tri\titlehfill{}1/2}

\note[item]{Possibilité de fournir un prédicat de comparaison, \lstinline|operator<| par défaut}

	\begin{itemize}
		\item \lstinline|std::sort()| trie un ensemble
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{4, 13, 28, 9 , 54};

sort(foo.begin(), foo.end());  // 4 9 13 28 54\end{lstlisting}

	\begin{alertblock}{Attention}
		Ordre relatif des éléments égaux non conservé

\note[item]{Utile si on test une partie des champs d'une structure par exemple}
	\end{alertblock}

	\begin{itemize}
		\item \lstinline|std::stable_sort()| trie l'ensemble en conservant l'ordre relatif
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Tri\titlehfill{}2/2}
	\begin{itemize}
		\item \lstinline|std::partial_sort()| réordonne l'ensemble de manière à ce que les éléments situés avant un itérateur pivot soient les plus petits éléments de l'ensemble ordonnés par ordre croissant\ldots
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{9, 8, 7, 6, 5, 4, 3, 2, 1};

partial_sort(foo.begin(), foo.begin() + 3, foo.end());
// 1 2 3 9 8 7 6 5 4\end{lstlisting}

	\begin{itemize}
		\item \ldots{} les autres éléments n'ont pas d'ordre particulier
		\item \lstinline|std::partial_sort_copy()| copie l'ensemble ordonné à l'image de \lstinline|std::partial_sort()|
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Mélange}
	\begin{itemize}
		\item \lstinline|std::random_shuffle()| réordonne aléatoirement l'ensemble
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{9, 8, 7, 6, 5, 4, 3, 2, 1};

random_shuffle(foo.begin(), foo.end());
// 1 8 3 7 9 4 2 6 5 ou ...\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Fusion}
	\begin{itemize}
		\item \lstinline|std::merge()| fusionne deux ensembles triés dans un troisième
	\end{itemize}

\note[item]{Ce troisième ensemble est bien entendu trié lui aussi}
\note[item]{Possibilité de fournir un prédicat de comparaison (\lstinline|operator<| par défaut)}

	\begin{lstlisting}[language=C++]
vector<int> foo{1, 5, 6, 8};
vector<int> bar{2, 5};
vector<int> baz;

merge(foo.begin(), foo.end(), 
      bar.begin(), bar.end(), 
      back_inserter(baz));
// 1 2 5 5 6 8\end{lstlisting}

	\begin{itemize}
		\item \lstinline|std::inplace_merge()| fusionne deux sous-ensembles "sur place"
	\end{itemize}

\note[item]{En fait il fusionne le début trié d'un ensemble avec le reste trié de ce même ensemble dans l'ensemble en question}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Opérations ensemblistes\titlehfill{}1/2}
	\begin{itemize}
		\item \lstinline|std::includes()| vérifie si tous les éléments d'un ensemble trié sont présents dans un autre ensemble

\note[item]{Ici, ensemble prend un sens plus \og mathématique\fg{}, et notamment sans répétition de valeur}
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{1, 5, 6, 8};
vector<int> bar{2, 5};
vector<int> baz{1, 6};

includes(foo.begin(), foo.end(), 
         bar.begin(), bar.end());   // faux
includes(foo.begin(), foo.end(), 
         baz.begin(), baz.end());   // vrai\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Opérations ensemblistes\titlehfill{}2/2}
	\begin{itemize}
		\item \lstinline|std::set_union()| : union de deux ensembles triés
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{1, 5, 6, 8};
vector<int> bar{2, 5};
vector<int> baz;

set_union(foo.begin(), foo.end(), bar.begin(),
          bar.end(), back_inserter(baz));
// 1 2 5 6 8\end{lstlisting}

	\begin{itemize}
		\item \lstinline|std::set_intersection()| : intersection de deux ensembles triés
		\item \lstinline|std::set_difference()| : différence de deux ensembles triés
		\item \lstinline|std::set_symmetric_difference()| : différence symétrique de deux ensembles triés

\note[item]{\lstinline|set_difference()| conserve les éléments présents dans le premier ensemble mais pas dans le second alors que \lstinline|set_symmetric_difference()| conserve les éléments présents dans un des ensembles mais pas dans l'autre}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Gestion de \og tas\fg{}}
	\begin{itemize}
		\item Tas (\textit{heap}) : structure permettant la récupération rapide de l'élément de plus grande valeur
		\item \lstinline|std::make_heap()| forme un tas depuis un ensemble
		\item \lstinline|std::pop_heap()| déplace l'élément de plus haute valeur en fin d'ensemble
		\item \lstinline|std::push_heap()| ajoute l'élément en fin d'ensemble au tas

		\begin{block}{\textit{push}, \textit{pop} et structure de tas}
			\lstinline|std::pop_heap()| et \lstinline|std::push_heap()| maintiennent la structure de tas
		\end{block}

		\item \lstinline|std::sort_heap()| tri le tas
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Min-max}

\note[item]{Possibilité de fournir la fonction de comparaison (\lstinline|operator<| par défaut)}

	\begin{itemize}
		\item \lstinline|std::min()| détermine le minimum de deux éléments
		\item \lstinline|std::max()| détermine le maximum de deux éléments
	\end{itemize}

	\begin{lstlisting}[language=C++]
min(52, 6);  // 6
max(52, 6);  // 52\end{lstlisting}

	\begin{itemize}
		\item \lstinline|std::min_element()| détermine le plus petit élément d'un ensemble
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{18, 5, 6, 8};
min_element(foo.begin(), foo.end()); // Sur 5 \end{lstlisting}

	\begin{itemize}
		\item \lstinline|std::max_element()| détermine le plus grand élément d'un ensemble
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Numérique\titlehfill{}1/4}
	\begin{itemize}
		\item \lstinline|std::accumulate()| \og ajoute\fg{} tous les éléments de l'ensemble
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{18, 5, 6, 8};

accumulate(foo.begin(), foo.end(), 1, multiplies<int>());
// 4320 \end{lstlisting}

	\begin{itemize}
		\item Opérateur et valeur initiale configurables
		\item \textit{Reduce/fold} fonctionnel
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Numérique\titlehfill{}2/4}
	\begin{itemize}
		\item \lstinline|std::adjacent_difference()| \og différence\fg{} entre chaque élément et son prédécesseur
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{18, 5, 6, 8};
vector<int> bar;

adjacent_difference(foo.begin(), foo.end(), 
                    back_inserter(bar), minus<int>());
// 18 -13 1 2\end{lstlisting}

	\begin{itemize}
		\item Opérateur configurable
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Numérique\titlehfill{}3/4}
	\begin{itemize}
		\item \lstinline|std::inner_product()| \og produit scalaire\fg{} de deux ensembles
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{1, 2, 3, 4};
vector<int> bar{2, 3, 4, 5};

inner_product(foo.begin(), foo.end(), bar.begin(), 0);
// 40\end{lstlisting}

	\begin{itemize}
		\item Opérateurs et valeur configurables
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Numérique\titlehfill{}4/4}
	\begin{itemize}
		\item \lstinline|std::partial_sum()| \og somme\fg{} partielle d'un ensemble
		\item Chaque élément résultant est la somme des éléments d'indice inférieur ou égal de l'ensemble de départ
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{1, 2, 3, 4};
vector<int> bar;

partial_sum(foo.begin(), foo.end(), back_inserter(bar));
// 1 3 6 10\end{lstlisting}

	\begin{itemize}
		\item Opérateur configurable
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{STL Algorithmes - Au delà des conteneurs\titlehfill{}1/3}
	\begin{itemize}
		\item Itérateurs définissables hors des conteneurs
		\begin{itemize}
			\item Abstraction du parcours
			\item Sémantique de pointeurs
		\end{itemize}
		\item Algorithmes indépendants du conteneur
		\item Utilisables sur d'autres ensembles de données
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Au delà des conteneurs\titlehfill{}2/3}
	\begin{itemize}
		\item Tableaux C
		\begin{itemize}
			\item Pas un conteneur :

\note[item]{Il contient mais est très différent des conteneurs classiques : frustre, minimaliste, rudimentaire, pas de réelle sémantique, peu d'intelligence}
\note[item]{Un tableau bas niveau}

			\begin{itemize}
				\item Sémantique : Tableau ou pointeur ? Statique ou dynamique ?
				\item Service : Taille ? Copie ?
			\end{itemize}
			\item Simple pointeur comme itérateur
			\begin{itemize}
				\item Début : adresse du premier élément
				\item Fin : adresse suivant le dernier élément
			\end{itemize}
		\end{itemize}
	\end{itemize}

	\begin{lstlisting}[language=C++]
int foo[4];

fill(foo, foo + 4, 5);  // 5 5 5 5\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Au delà des conteneurs\titlehfill{}3/3}
	\begin{itemize}
		\item Flux
		\begin{itemize}
			\item \lstinline|istream_iterator| : \textit{input} itérateur
			\begin{itemize}
				\item Début : depuis un flux entrant
				\item Fin : constructeur par défaut
			\end{itemize}
			\item \lstinline|ostream_iterator| : \textit{output} itérateur
			\begin{itemize}
				\item Depuis un flux sortant, séparateur configurable
			\end{itemize}
		\end{itemize}
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{5, 6, 12, 89};
ostream_iterator<int> out_it (cout, ", ");

copy(foo.begin(), foo.end(), out_it); // 5, 6, 12, 89,\end{lstlisting}

	\begin{alertblock}{Attention}
		Séparateur ajouté après chaque élément, y compris le dernier
	\end{alertblock}

	\begin{itemize}
		\item Buffers de flux : \lstinline|istreambuf_iterator| et \lstinline|ostreambuf_iterator|
	\end{itemize}
\end{frame}

\subsection*{STL - Conclusion}
\begin{frame}
	\frametitle{STL Conclusion \titlehfill{}1/4}
	\begin{exampleblock}{Do}
		Préférez les conteneurs aux tableaux C
	\end{exampleblock}

	\begin{alertblock}{Attention}
		\lstinline|operator[]| ne vérifie pas les bornes

\note[item]{Une implémentation peut mettre une assertion dessus et produire une erreur à l'exécution en debug, p.ex. sur les TU. Et une implémentation de qualité devrait le faire}
	\end{alertblock}

	\begin{alertblock}{Don't}
		N'utilisez pas d'itérateur invalidé

\note[item]{Certaines opérations, par exemple l'ajout dans un vecteur, peuvent invalider les itérateurs sur le conteneur}
	\end{alertblock}

	\begin{alertblock}{Attention}
		Pas objets polymorphiques dans les conteneurs ou via des pointeurs intelligents
	\end{alertblock}
\end{frame}

\begin{frame}
	\frametitle{STL Conclusion \titlehfill{}2/4}
	\begin{exampleblock}{Do, performances}
		Mesurez !
	\end{exampleblock}

	\begin{block}{Conseils, performances}
		\begin{itemize}
			\item Réfléchissez à votre utilisation des données

\note[item]{Utilisation des données : zone critique/non critique, découpage d'algorithmes, données particulières (triées, lourdes à copier), compromis temps/mémoire, stabilité (tri), mise en cache, \ldots}
\note[item]{La première interrogation étant : ce traitement est-il nécessaire ?}

			\item Méfiez-vous des complexités brutes

\note[item]{La complexité n'est pas ou peu significative pour de petits volumes de données, p.ex. les tris par insertion ou sélection (O($n^{2}$)) plus efficaces que des tris en O($n\ln n$)}
\note[item]{Les complexités moyennes ne sont pas pertinentes pour des données particuliers, p.ex. tri par insertion efficace sur ensembles presque triés, peu de permutation du tri par sélection donc efficace pour des données lourdes à déplacer}
		\end{itemize}
	\end{block}

	\begin{exampleblock}{Do}
		Préférez les algorithmes standard aux algorithmes tierces, aux algorithmes \og maisons\fg{} et aux boucles

\note[item]{Exception à l'usage d'algorithmes standard : exception inopportune et initialisation à zéro}
	\end{exampleblock}

	\begin{block}{Un petit bémol performance}
		Les algorithmes standard sont généralement très bons mais, étant génériques, pas forcément optimaux dans une situation particulière
	\end{block}
\end{frame}

\begin{frame}
	\frametitle{STL Conclusion \titlehfill{}3/4}
	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Faites vos propres algorithmes plutôt que des boucles
			\item Faites des algorithmes génériques et compatibles
		\end{itemize}
	\end{exampleblock}

	\begin{exampleblock}{Do}
		Respectez la sémantique des algorithmes :
		\begin{itemize}
			\item Le bon algorithme pour la bonne opération
			\item Définissez la sémantique de vos algorithmes et choisissez un nom explicite
		\end{itemize}
	\end{exampleblock}

	\begin{exampleblock}{Do}
		Préférez les prédicats \og purs\fg{}
	\end{exampleblock}
\end{frame}

\begin{frame}
	\frametitle{STL Conclusion \titlehfill{}4/4}
	\begin{exampleblock}{Do}
		Vérifiez que les ensembles de destination aient une taille suffisante
	\end{exampleblock}

	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Vérifiez les pré-conditions des algorithmes (p.ex. ensemble trié)
			\item Vérifiez le type d'itérateur requis
			\item Vérifiez les complexités garanties
		\end{itemize}
	\end{exampleblock}

	\begin{block}{Aller plus loin}
		Voir \href{https://github.com/CppCon/CppCon2016/blob/master/Presentations/STL\%20Algorithms/STL\%20Algorithms\%20-\%20Marshall\%20Clow\%20-\%20CppCon\%202016.pdf}{STL Algorithms (Marshall Clow)}

\note[item]{Conf cppcon 2016 sur les algorithmes en général et sur comment faire ces propres algorithmes}
	\end{block}
\end{frame}
\end{document}