\documentclass[C++.tex]{subfiles}
\begin{document}

\section{Retour sur C++98/C++03}
\subsection*{Rappels}
\begin{frame}
	\frametitle{Rappels historiques}
	\begin{itemize}
		\item Années 80 : \og C with classes\fg{} par Bjarne Stroustrup aux Bell Labs
		\item 1983 : renommé C++
		\item 1985 : première version publique de CFront 
		\item 1985 : première version de \textit{The C++ Programming Language} 
		\item 1998 : première normalisation
		\item 2003 : amendement
		\item 2007 : publication du premier \textit{Technical Report} (TR1)
		
\note[item]{Les Technical Report (TR) ne sont pas normatifs}
\note[item]{Définition des TR par l'ISO : \textit{An informative document containing information of a different kind from that normally published in a normative document}}
		
		\begin{itemize}
			\item Partiellement implémenté par certains compilateurs ou Boost
			\item Repris en partie dans les normes suivantes et TS
			
\note[item]{\textit{Les Technical Specification} (TS) sont des documents normatifs ayant vocation a être intégrés dans la norme, ce sont essentiellement des \textit{preview}}
\note[item]{Définition des TS par l'ISO : \textit{A normative document representing the technical consensus within an ISO committee}}
			
		\end{itemize}
		\item Un projet de TR2 finalement transposé en \textit{Technical Specification}
		
\note[item]{Pas de publication de TR2 car changement des procédures au sein du comité ISO C++.}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{La \og philosophie\fg{} du C++}
	\begin{itemize}
		\item Langage multi-paradigme

\note[item]{Procédural, objet, générique et \textit{Template metaprogramming}}

		\item Typage statique déclaratif
		\item Généraliste
		\item Initialement, ajout des classes au C

\note[item]{Classes issues de Simula}

		\item Forte compatibilité avec le C : vaste sous-ensemble commun proche du C

\note[item]{Meilleur typage que C (à l'origine d'incompatibilités : caractères littéraux de type \lstinline|char|, pas de conversion implicite depuis \lstinline|void|)}

		\item \textit{Zero-overhead abstraction}
		\item Compatibilité ascendante forte mais pas absolue
		\item Évolutions par les bibliothèques plutôt que par le langage
		\item Pas de \og magie\fg{} dans la bibliothèque standard
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Normalisation}
	\begin{itemize}
		\item Normalisé par l'ISO : \url{http://www.open-std.org/JTC1/SC22/WG21/}

\note[item]{Sous-comité 22, Working group 21}

		\item Comité distinct de celui du C

\note[item]{C : Working group 14}

		\item \ldots mais des membres en commun
		\item Pas de propriétaire du C++

\note[item]{Donc libre de droit, mais la norme ISO définitive est payante}

		\item Actualité de normalisation, et du C++ en général, sur \href{https://isocpp.org/}{isocpp.org}

\note[item]{Également une FAQ plutôt bien sur C++, ainsi qu'un guide de bonnes pratiques, les brouillons de la norme et des propositions}
	\end{itemize}

	\begin{alertblock}{isocpp.org n'est pas le site du comité}
		Site de \textit{Standard C++ Foundation} dont le but est la promotion du C++\\
		Les deux sont cependant très proches et partagent de nombreux membres
		
\note[item]{Membres communs entre isocpp.org et comité : Bjarne Stroustrup, Herb Sutter (président de isocpp et secrétaire du comité)}
	\end{alertblock}

	\begin{itemize}
		\item Un repo GIT (brouillons et propositions) : https://github.com/cplusplus
		\item Une conférence annuelle : \href{http://cppcon.org/}{cppcon}
		\item Sites de référence sur C++
		\begin{itemize}
			\item \href{https://en.cppreference.com/w/}{cppreference.com}
			\item \href{https://hackingcpp.com/}{hacking C++}
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Norme \& support}
	\begin{itemize}
		\item Compilateur
		\begin{itemize}
			\item GCC : \href{https://gcc.gnu.org/projects/cxx-status.html}{C++ Standards Support in GCC}
			\item Clang (LLVM) : \href{http://clang.llvm.org/cxx_status.html}{C++ Support in Clang}
			\item Visual studio : \href{https://docs.microsoft.com/fr-fr/cpp/overview/visual-cpp-language-conformance?view=msvc-160}{Tableau de conformité du langage Microsoft C++}
		\end{itemize}
		\item Bibliothèque standard
		\begin{itemize}
			\item GCC : \href{https://gcc.gnu.org/onlinedocs/libstdc++/manual/status.html}{status.html}
			\item Clang : \href{https://libcxx.llvm.org/}{C++ Standard Library}
		\end{itemize}
		\item Vision globale \href{http://en.cppreference.com/w/cpp/compiler_support}{C++ compiler support}
	\end{itemize}
\end{frame}

\subsection*{Gestion des erreurs}
\begin{frame}
	\frametitle{Erreurs - Code retour}
	\begin{itemize}
		\item Plusieurs variantes
		\begin{itemize}
			\item Type de retour dédié
			\item Valeur particulière notant un échec (\lstinline|NULL|, \lstinline|-1|)
			\item Récupération de la dernière erreur (\lstinline|errno|, \lstinline|GetLastError()|)
		\end{itemize}
		\item Nécessite \og un test toutes les deux lignes\fg{}
		\item Gestion manuelle de la remontée de la pile d'appel
		\item Adapté au traitement local des erreurs, pas au traitement \og plus haut\fg{}
	\end{itemize}

	\pause

	\begin{alertblock}{Problèmes et limites}
		\begin{itemize}
			\item Impact négatif sur la lisibilité
			\item Souvent délaissé dans un contexte d'enseignement ou de formation
			\item Beaucoup de code avec une gestion d'erreur déficiente
		\end{itemize}
	\end{alertblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Erreurs - Exception}
	\begin{itemize}
		\item Lancée par \lstinline|throw|
		\item Attrapée par \lstinline|catch()| depuis un bloc \lstinline|try|
	\end{itemize}

	\begin{lstlisting}[language=C++]
try {
  ...
  // Lancement d'une exception
  throw logic_error("Oups !");
  ... }
catch(logic_error& e) {
  // Traitement de l'exception 
  ... }\end{lstlisting}
\end{frame}

\begin{frame}
	\frametitle{Erreurs - Exception}
	\begin{itemize}
		\item Type quelconque
		\item Idéalement héritant de \lstinline|std::exception| (via \lstinline|std::logic_error|, \lstinline|std::runtime_error| ou autres)
		\item \lstinline|catch(...)| pour attraper les exceptions de tout type
		\item Compatibles avec le \textit{stack unwinding}

\note[item]{Objets sur la pile détruits lors de la sortie d'une fonction même sur exception}
\note[item]{Destruction dans l'ordre inverse de la création des objets}

		\item Pas de \lstinline[keywordstyle=\color{black}]|finally|
		\item Les exceptions non attrapées provoquent l'appel de \lstinline|std::terminate()|

\note[item]{Sortie du programme sans \textit{stack unwinding}}

		\item Utilisées par la bibliothèque standard (p.ex. \lstinline|std::bad_alloc|)
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Erreurs - Critiques des exceptions}
	\begin{itemize}
		\item Critiquées, voire interdites, par certaines normes de codage (p.ex. : \href{https://google.github.io/styleguide/cppguide.html}{Google C++ Style Guide)}
		\item Arguments très variés :
		\begin{itemize}
			\item \og Je ne comprends pas\fg{}, \og Ça ne sert à rien\fg{}, \ldots
			\item Impact négatif sur les performances
		\end{itemize}

		\pause

		\begin{block}{Pas vraiment}
			\begin{itemize}
				\item Initialement vrai
				\item Actuellement une exception non levée ne coute quasiment rien
				\item Souvent comparée à une non gestion d'erreur. Est-ce pertinent ? 
			\end{itemize}
		\end{block}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Erreurs - Critiques des exceptions}
	\begin{itemize}
		\item [] \begin{itemize}
			\item Mauvais support par les différents outils
		\end{itemize}
	\end{itemize}

	\begin{block}{Très variable}
		\begin{itemize}
			\item Correctement supportées par les compilateurs actuels
			\item Inégalement gérées par les outils d'analyse, de documentation, \ldots
		\end{itemize}
	\end{block}

	\begin{itemize}
		\item [] \begin{itemize}
			\item Code plus complexe à analyser

\note[item]{Complexité discutable : il faut une vision plus globale, donc plus complexe, pour suivre un programme. Mais le code local est plus simple vu qu'il n'est noyé de code dédié à la gestion d'erreur}

			\item Difficiles à introduire dans une large base de code sans exception

\note[item]{Argument de la difficulté d'introduction à nuancer toutefois avec la levée d'exception par la bibliothèque standard qui a lieu dans tous les cas (hors options particulières du compilateur)}

			\item Absence d'ABI normalisée

\note[item]{Le problème d'ABI est plus large que les seules exceptions}
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Erreurs - Exception safety}
	\begin{itemize}
		\item \textit{No-throw guarantee} : l'opération ne peut pas échouer
	\end{itemize}

	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Destructeurs et \lstinline|swap()| ne doivent pas lever d'exception

\note[item]{Aussi le cas pour le déplacement en C++11}
		\end{itemize}
	\end{exampleblock}

	\begin{itemize}
		\item \textit{Strong exception safety} : pas d'effet de bord, pas de fuite, état conservé
		\item \textit{Basic exception safety} : pas de fuite, invariants conservés
		\item \textit{No exception safety} : aucune garantie
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Erreurs - Exception safety}
	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Privilégiez les garanties les plus fortes possibles
		\end{itemize}
	\end{exampleblock}

	\begin{alertblock}{Don't}
		\begin{itemize}
			\item Évitez la garantie faible
			\item Évitez absolument le \textit{No exception safety}
		\end{itemize}
	\end{alertblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Erreurs - Exception safety}
	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Utilisez l'idiome \textit{copy-and-swap} pour la \textit{Strong exception safety}
		\end{itemize}
	\end{exampleblock}

	\pause 

	\begin{lstlisting}[language=C++]
class A {
public:
  A(const A&);
  A& operator=(A);
  friend void swap(A& lhs, A& rhs); };  // Nothrow

A& A::operator=(A other) {              // Copy
  swap(*this, other);                   // Swap
  return *this; }\end{lstlisting}
\end{frame}

\begin{frame}
	\frametitle{Erreurs - Exceptions et bonnes pratiques}
	\begin{exampleblock}{Do}
		\begin{itemize}
			\item \textit{Throw by value, catch by const reference} (\cite{coding} chap. 73)
		\end{itemize}
	\end{exampleblock}

	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Utilisez des types dédiés héritant de \lstinline|std::exception|

\note[item]{Idéalement via \lstinline|std::runtime_error|}

			\item Définissez des hiérarchies d'exceptions
		\end{itemize}
	\end{exampleblock}

	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Capturez uniquement là où vous savez traiter l'erreur
		\end{itemize}
	\end{exampleblock}
\end{frame}

\begin{frame}
	\frametitle{Erreurs - Exceptions et bonnes pratiques}
	\begin{alertblock}{Don't}
		\begin{itemize}
			\item N'utilisez jamais les exceptions pour contrôler le flux d'exécution
			\item Ni pour gérer les \og échecs attendus\fg{}

\note[item]{P. ex. l'absence d'un élément dans une collection lors de la recherche}

			\item Réservez les exceptions au signalement d'erreurs
		\end{itemize}
	\end{alertblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Erreurs - \lstinline|assert|}
	\begin{itemize}
		\item Arrête le programme si l'expression est évalué à 0
		\item Affiche au moins l'expression, le fichier et la ligne
	\end{itemize}

	\begin{lstlisting}[language=C++]
assert(expression);\end{lstlisting}

	\begin{itemize}
		\item Sans effet lorsque \lstinline|NDEBUG| est défini
		\begin{itemize}
			\item Coût nul en \textit{Release}
			\item Inutilisable pour les erreurs d'exécution et le contrôle des entrées
		\end{itemize}
	\end{itemize}

	\begin{block}{Objectifs}
		\begin{itemize}
			\item Traquer les erreurs de programmation et les violations de contrat interne
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}
	\frametitle{Erreurs - Conclusion}
	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Utilisez exceptions et codes retour pour les erreurs d'exécution et la vérification des données externes
			\item Réservez \lstinline|assert| aux erreurs de programmation et à la vérification des contrats internes
		\end{itemize}
	\end{exampleblock}

	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Préférez les exceptions aux codes retour (\cite{coding} chap. 72)
		\end{itemize}
	\end{exampleblock}

	\begin{alertblock}{Don't}
		\begin{itemize}
			\item Jamais d'\lstinline|assert| pour les erreurs d'exécution et le contrôle des entrées
		\end{itemize}
	\end{alertblock}
\end{frame}

\subsection*{Gestion des ressources}
\begin{frame}[fragile]
	\frametitle{Ressources - Gestion manuelle}
	\begin{alertblock}{}
		Comment gérer les erreurs ?
	\end{alertblock}

	\begin{itemize}
		\item Solution C : \textit{Single Entry Single Exit}, bloc unique de libération

		\begin{lstlisting}[language=C++]
char* memory = malloc(50);
if(!memory) goto err;
...
err:
free(memory);\end{lstlisting}

		\pause

		\begin{itemize}
			\item Laborieux
			\item Difficile à mettre en place en présence d'exceptions
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Ressources - Gestion manuelle}
	\begin{block}{Quiz : Comment éviter les fuites mémoires ?}
		\begin{lstlisting}[language=C++]
char* memory1 = NULL;
char* memory2 = NULL;
...
memory1 = new char[50];
...
memory2 = new char[200];
...
delete[] memory1;
delete[] memory2;\end{lstlisting}
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Ressources - Gestion manuelle}
	\begin{alertblock}{}
		Comment copier des classes possédant des ressources ?
	\end{alertblock}

	\begin{itemize}
		\item Constructeurs et opérateurs générés copient les adresses des pointeurs
		\item La double libération est une erreur
	\end{itemize}

	\begin{lstlisting}[language=C++]
struct Foo {
public:
  Foo() : bar(new char[50]) {}
  ~Foo() { delete[] bar; }

private:
  char* bar; };\end{lstlisting}
\end{frame}

\begin{frame}
	\frametitle{Ressources - Gestion manuelle et bonnes pratiques}
	\begin{exampleblock}{Do}
		Si une classe manipule une ressource brute, elle doit
		\begin{itemize}
			\item Soit définir constructeur de copie et opérateur d'affectation
			\item Soit les déclarer privés sans les définir (classe non copiable)
		\end{itemize}
	\end{exampleblock}

	\begin{exampleblock}{\textit{Big Rule of three}}
		Si vous devez définir l'une des trois fonctions de base que sont le constructeur de copie, l'opérateur d'affectation ou le destructeur, alors vous devriez définir les trois

\note[item]{Forme canonique orthodoxe de Coplien}
\note[item]{Thèse de Coplien : \textit{Multi-paradigm Design}}
	\end{exampleblock}
\end{frame}

\begin{frame}
	\frametitle{Ressources - RAII}

\note[item]{\textit{Resource Acquisition Is Initialization}}

	\begin{itemize}
		\item Acquisition des ressources lors de l'initialisation de l'objet
		\item Libération automatique lors de sa destruction

\note[item]{Proche du try with resources de Java ou du with de Python}

		\item Propriété intrinsèque des objets \og par design\fg{}

\note[item]{Contrairement à Java ou Python où c'est une propriété de l'usage}

		\item Fonctionnement de la bibliothèque standard (conteneurs, fichiers, \ldots)
		\item Conséquences
		\begin{itemize}
			\item Objets créés dans un état cohérent, testable et utilisable
			\item Ressources automatiquement libérées à la destruction de l'objet

\note[item]{Et de façon déterministe}
			
			\item Capsules RAII copiables sans effort
		\end{itemize}
	\end{itemize}

	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Utilisez RAII pour vos objets
		\end{itemize}
	\end{exampleblock}
\end{frame}

\begin{frame}
	\frametitle{Ressources - RAII}
	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Faites des constructeurs qui construisent des objets
			\begin{itemize}
				\item Cohérents
				\item Utilisables
				\item Complètement initialisés
			\end{itemize}
		\end{itemize}
	\end{exampleblock}

	\begin{alertblock}{Don't}
		\begin{itemize}
			\item Évitez les couples constructeur vide et fonction d'initialisation
		\end{itemize}
	\end{alertblock}

	\begin{alertblock}{Don't}
		\begin{itemize}
			\item Évitez les couples constructeur vide et ensemble de mutateurs
		\end{itemize}
	\end{alertblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Ressources - Limites du RAII}
	\begin{alertblock}{Gestion des erreurs}
		\begin{itemize}
			\item Pas d'erreur ni d'exception dans les destructeurs
			\item La libération peut échouer (p.ex. \lstinline|flush| lors de la fermeture de fichier)
		\end{itemize}
	\end{alertblock}

	\begin{lstlisting}[language=C++]
{
  ifstream src("input.txt");
  ofstream dst("output.txt");
  copy_files(src, dst);
}

remove_file(src);
// Potentielle perte de donnees\end{lstlisting}

\note[item]{Le problème se résout en forçant l'écriture (\lstinline|flush|) en fin de la fonction \lstinline|copy_files()| et en remontant une exception en cas d'erreur}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Ressources - Limites du RAII}
	\begin{alertblock}{\lstinline|std::auto_ptr|}
		\begin{itemize}
			\item Copiable
			\item Cette copie transfère la responsabilité de la ressource
		\end{itemize}
	\end{alertblock}

	\begin{lstlisting}[language=C++]
void foo(auto_ptr<int> bar) {}

auto_ptr<int> bar(new int(5));
foo(bar);
// Erreur : bar n'est plus utilisable
cout << *bar << "\n";\end{lstlisting}

\note[item]{\lstinline|std::auto_ptr| déprécié en C++11 et remplacé par \lstinline|std::unique_ptr| qui fonctionne mieux (sémantique de déplacement)}

\end{frame}

\begin{frame}
	\frametitle{Ressources - Loi de Déméter}

\note[item]{À strictement parler, gestion de l'accès aux ressources pas de la libération}

	\begin{itemize}
		\item Principe de connaissance minimale
		\item Un objet \lstinline|A| peut utiliser les services d'un deuxième objet \lstinline|B|
		\item Mais ne doit pas utiliser \lstinline|B| pour accéder à un troisième objet
		\item En particulier, une classe n'expose pas ses données
	\end{itemize}

	\begin{block}{Exceptions}
		\begin{itemize}
			\item Agrégats et conteneurs dont le rôle est de contenir des données
		\end{itemize}

\note[item]{Agrégat désigne ici des classes, ou structures, qui agrège un ensemble de données ensembles sans comportement ni invariant. Ce n'est pas exactement la même chose que l'\textit{aggregate} du standard}
\note[item]{Certains (p.ex. Loïc Joly) utilisent aussi le terme d'agglomérat, ce qui évite la confusion}
	\end{block}

	\begin{block}{Objectifs}
		\begin{itemize}
			\item Mise en place du RAII
			\item Meilleure encapsulation
			\item Respect des \textit{patterns} SOLID et GRASP

\note[item]{Notamment le principe ouvert-fermé, l'inversion de dépendance et le couplage faible}

			\item Meilleure lisibilité, maintenabilité et réutilisabilité
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}
	\frametitle{Ressources - Loi de Déméter}
	\begin{exampleblock}{Do, agrégats}
		\begin{itemize}
			\item Préférez les structures aux classes
			\item Laissez les membres publics
			\item Fournissez, éventuellement, des constructeurs initialisant les données
		\end{itemize}

\note[item]{Pas de fonction de services dans les agrégats, éventuellement des fonctions techniques}
	\end{exampleblock}

	\begin{exampleblock}{Do, conteneurs}
		\begin{itemize}
			\item Respectez l'interface et la logique des conteneurs standards
		\end{itemize}
	\end{exampleblock}

	\begin{exampleblock}{Do, classes de service}
		\begin{itemize}
			\item Exposez des services, pas des données
			\item Pas de données publiques
			\item Limitez les accesseurs et les mutateurs
		\end{itemize}
	\end{exampleblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Ressources - Loi de Déméter}
	\begin{block}{Conseil}
		\begin{itemize}
			\item N'hésitez pas à étendre l'interface de classe avec des fonctions libres
			\item Pensez à l'amitié pour cette interface étendue
			\item Implémentez-la en terme de fonctions membres (p.ex. \lstinline|+| à partir de \lstinline|+=|)
		\end{itemize}
	\end{block}

	\begin{lstlisting}[language=C++]
class Foo {
public:
  Foo& operator+=(const Foo& other); };

Foo operator+(Foo lhs, const Foo& rhs) {
  return lhs += rhs; }\end{lstlisting}
\end{frame}

\begin{frame}
	\frametitle{Ressources - Et le Garage Collector ?}
	\begin{itemize}
		\item Pas de GC dans le langage ni dans la bibliothèque standard
		\item Au moins un GC en bibliothèque tierce (\href{http://www.hboehm.info/gc/}{Hans Boehm})
		\item \ldots{} mais limité par manque de support par le langage
		\item Non déterministe : adapté à la mémoire pas aux autres ressources
		\item Particulièrement adapté à la gestion des structures cycliques
		\item D'autres avantages pour la mémoire (compactage, recyclage, \ldots)

\note[item]{Mais ces fonctionnalités évoluées des GC ne sont probablement pas compatibles avec le fonctionnement du C++}
	\end{itemize}

	\begin{block}{Wait and see}
		\begin{itemize}
			\item Un complément à RAII, pas un concurrent ni un remplaçant
			\item Indisponible à ce jour
		\end{itemize}

\note[item]{Et visiblement, pas près d'arriver, le support minimal de C++11 n'a été implémenté par aucun compilateur et a été supprimé en C++23, et pas de travaux sur le sujet}
	\end{block}
\end{frame}

\begin{frame}
	\frametitle{Ressources - Conclusion}
	\begin{exampleblock}{Do, RAII}
		\begin{itemize}
			\item Préférez les classes RAII de la bibliothèque standard aux ressources brutes
			\item Encapsulez les ressources dans des capsules RAII standards
			\item Concevez vos classes en respectant le RAII
		\end{itemize}
	\end{exampleblock}

	\begin{exampleblock}{Do, Déméter}
		\begin{itemize}
			\item Respectez Déméter
		\end{itemize}
	\end{exampleblock}
\end{frame}

\begin{frame}
	\frametitle{Ressources - Conclusion}
	\begin{alertblock}{Don't}
		\begin{itemize}
			\item Pas de \lstinline|delete| dans le code applicatif
		\end{itemize}

\note[item]{\lstinline|delete| dans les classes bas niveau qui définissent des capsules RAII}
	\end{alertblock}

	\begin{alertblock}{Attention}
		\begin{itemize}
			\item Sous Linux, méfiez-vous de l'\textit{Optimistic Memory Allocator}

\note[item]{Retourne une adresse lors d'un \lstinline|new| ou d'un \lstinline|malloc()| sans allocation et avec peu de contrôle}
\note[item]{Allocation uniquement lors de l'usage de la mémoire}
\note[item]{Si manque de mémoire à ce moment : une application est tuée (probablement le demandeur ou la plus gourmande, influence du \textit{uptime}, de la priorité ou du propriétaire ?) mais jamais \lstinline|init|}
\note[item]{Pourquoi OMA : les logiciels demandent plus de mémoire que ce qu'ils utilisent réellement}

			\item Pensez à paramétrer correctement l'OS
		\end{itemize}
	\end{alertblock}
\end{frame}

\subsection*{STL}
\begin{frame}
	\frametitle{STL - Standard Template Library}
	\begin{itemize}
		\item Partie de la bibliothèque standard comprenant

\note[item]{Formellement, la STL n'existe plus dans la norme C++ actuelle}

		\begin{itemize}
			\item Conteneurs et \lstinline|std::basic_string| : données

\note[item]{\lstinline|std::basic_string| contient, est template et a une interface \og conteneurs\fg{}. Mais a une sémantique particulière et n'est pas remplaçable de ce fait et possède des algorithmes spécifiques}

			\item Itérateurs : parcours des conteneurs
			\item Algorithmes : manipulation des données via les itérateurs
		\end{itemize}
	\end{itemize}

	\begin{block}{Note}
		\begin{itemize}
			\item Quelques algorithmes manipulant directement des données (p.ex. \lstinline|std::min()|)
		\end{itemize}
	\end{block}

	\begin{itemize}
		\item Conçue initialement par Alexander Stepanov
		\begin{itemize}
			\item Promoteur de la programmation générique

\note[item]{Programmation générique : template en C++, \lstinline|generic| en Java}
\note[item]{Programmation générique = polymorphisme paramétrique}

			\item Sceptique vis à vis de la POO

\note[item]{Pour Stepanov : POO = hoax (canular)}
\note[item]{Stepanov a de vrais arguments et cible davantage le marketing survendeur (\textit{silver bullet}) et les promesses non tenues que la POO elle-même}
\note[item]{Stepanov ne s'oppose pas à l'abstraction et à encapsulation mais à la façon dont la POO prétend y répondre}

		\end{itemize}
		\item Basée sur les templates, pas sur la POO

\note[item]{Pas de POO dans la STL : utilisation de classes (abstraction, modularité) mais ni polymorphisme de sous-typage ni \textit{dynamic dispatch}}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{STL - Standard Template Library}
	\begin{block}{Intérêts}
		\begin{itemize}
			\item $n$ conteneurs et $m$ algorithmes, seulement $m$ implémentations

\note[item]{$m$ implémentations vs. $n * m$ pour modèle objet avec algorithme sous forme de fonctions membres}

			\item Tout nouvel algorithme est disponible sur tous les conteneurs compatibles
			\item Tout nouveau conteneur bénéficie de tous les algorithmes compatibles

\note[item]{Compatible : conteneur fournit un itérateur permettant les opérations requises par l'algorithme}

			\item Changement de conteneur à effort réduit
		\end{itemize}
	\end{block}

	\begin{block}{Pour aller plus loin}
		\begin{itemize}
			\item \cite{effStl} de Scott Meyers
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}
	\frametitle{STL - Standard Template Library}
	\begin{block}{À nuancer}
		Algorithmes membres sur certains conteneurs
		\begin{itemize}
			\item Accès par itérateurs insuffisant (p.ex. \lstinline|std::list|)
			\item Habitudes et historiques (p.ex. \lstinline|std::string|)
			\item Performances (p.ex. \lstinline|map.find()|)
		\end{itemize}
	\end{block}
\end{frame}

\subsection*{STL - Conteneurs}
\begin{frame}[fragile]
	\frametitle{STL Conteneurs - Généralités}
	\begin{itemize}
		\item Contiennent des objets copiables et non constants

\note[item]{En C++11 et suivante : copiables ou déplaçable}
\note[item]{On peut avoir des conteneurs \lstinline|const| et donc ne pas pouvoir modifier les éléments, mais on ne peut pas avoir de conteneur de \lstinline|const|}

		\item \ldots{} qui peuvent être les adresses d'autres objets
	\end{itemize}

	\begin{alertblock}{Conteneurs de pointeurs}
		\begin{itemize}
			\item Pas de libération automatique des objets \og pointés\fg{}
		\end{itemize}
	\end{alertblock}

	\begin{itemize}
		\item \ldots{} accessibles via un itérateur
		\item Fourniture possible d'une politique d'allocation
		\item Vu des algorithmes, ce qui fournit une paire d'itérateurs, est un conteneur
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Conteneurs - Conteneurs séquentiels}
	\begin{itemize}
		\item \lstinline|std::vector|
		\begin{itemize}
			\item Tableau de taille variable d'éléments contigus
			\item Accès indexé
			\item Croissance en temps amorti
			\item Modifications en fin de vecteur (couteux ailleurs)

\note[item]{Couteux d'insérer/retirer ailleurs qu'en fin car il faut déplacer les données}
\note[item]{Possible d'échanger puis de retirer à la fin (si l'ordre n'est pas important)}

			\item Compatible avec l'organisation mémoire des tableaux C

\note[item]{Passage à un tableau C en prenant l'adresse du premier élément : \lstinline|T* ptr = &vec[0];|}
		\end{itemize}
	\end{itemize}

	\begin{alertblock}{\lstinline|std::vector<bool>| n'est pas un vecteur de booléen}
		\begin{itemize}
			\item Ne remplit pas tous les pré-requis des conteneurs
			\item \lstinline|operator[]| ne retourne pas le booléen mais un \textit{proxy} vers celui-ci
			\item Voir \cite{effStl} item 18

\note[item]{Impossible de prendre l'adresse de \lstinline|v[0]| d'un \lstinline|vector<bool>|}
		\end{itemize}
	\end{alertblock}
\end{frame}

\begin{frame}
	\frametitle{STL Conteneurs - Conteneurs séquentiels}
	\begin{itemize}
		\item \lstinline|std::list|
		\begin{itemize}
			\item Liste doublement chaînée
			\item Accès bidirectionnel non indexé
			\item Modification n'importe où à faible coût
			\item Plusieurs algorithmes membres (tri, fusion, suppression, \ldots)

\note[item]{Algorithmes membres pour la liste car accès non indexé}
		\end{itemize}

		\item \lstinline|std::deque|
		\begin{itemize}
			\item \textit{Double-ended queue}
			\item Proche de \lstinline|std::vector| mais extensible aux deux extrémités
			\item Accès indexé
			\item Éléments non nécessairement contigus
			\item Non compatible avec l'organisation mémoire des tableaux C
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{STL Conteneurs - Conteneurs séquentiels}
	\begin{itemize}
		\item \lstinline|std::string|
		\begin{itemize}
			\item Alias de \lstinline|std::basic_string<char>|
			\item Stockage de chaînes de caractères
			\item Manipulation de \textit{bytes} et non de caractères encodés
		\end{itemize}
	\end{itemize}

	\begin{alertblock}{\lstinline|std::string| et UTF-8}
		\begin{itemize}
			\item \lstinline|length()| et \lstinline|size()| retournent le nombre de \textit{bytes}, pas de caractères
		\end{itemize}
	\end{alertblock}

	\begin{itemize}
		\item [] \begin{itemize}
			\item Contiguïté non garantie, mais respectée en pratique

\note[item]{Contiguïté garantie en C++11 et suivant}
\note[item]{Pas d'implémentation non contigüe connue}

			\item Un cousin peu utilisé pour les caractères larges : \lstinline|std::wstring|
		\end{itemize}
	\end{itemize}

	\begin{alertblock}{Une API trop riche}
		\begin{itemize}
			\item De nombreuses fonctions membres qui gagneraient à être libres et génériques
			\item Voir \href{http://www.gotw.ca/gotw/084.htm}{GotW \#84 : Monoliths "Unstrung"}
		\end{itemize}
	\end{alertblock}
\end{frame}

\begin{frame}
	\frametitle{STL Conteneurs - Conteneurs associatifs}
	\begin{itemize}
		\item Quatre saveurs
		\begin{itemize}
			\item \lstinline|std::map| : clés-valeurs, ordonné par la clé, unicité des clés
			\item \lstinline|std::multimap| : clés-valeurs, ordonné par la clé, multiplicité des clés
			\item \lstinline|std::set| : valeurs ordonnées et uniques
			\item \lstinline|std::multiset| : valeurs ordonnées et non-uniques
		\end{itemize}
	\end{itemize}

	\begin{block}{Implémentation}
		\begin{itemize}
			\item Pas des tables de hachage
			\item Généralement des arbres binaires de recherche balancés
		\end{itemize}

\note[item]{\textit{red-black tree} le plus souvent}
	\end{block}

	\begin{itemize}
		\item Critère d'ordre est configurable (strictement inférieur par défaut)
	\end{itemize}

	\begin{alertblock}{Attention}
		\begin{itemize}
			\item Critère d'ordre strict
		\end{itemize}
	\end{alertblock}

	\begin{itemize}
		\item Algorithmes membres (recherche) pour les performances
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Conteneurs - Adaptateurs}
	\begin{itemize}
		\item Basés sur un autre conteneur pour proposer une API simplifiée
		\item Avantages et inconvénients du conteneur sous-jacent
		\item \lstinline|std::stack|
		\begin{itemize}
			\item Pile LIFO
			\item Basée sur \lstinline|std::vector|, \lstinline|std::list| ou \lstinline|std::deque|
		\end{itemize} 
		\item \lstinline|std::queue|
		\begin{itemize}
			\item File FIFO
			\item Basée sur \lstinline|std::deque| ou \lstinline|std::list|
		\end{itemize} 
		\item \lstinline|std::priority_queue|
		\begin{itemize}
			\item File dont l'élément de tête est le plus grand
			\item Basée sur \lstinline|std::vector| ou \lstinline|std::deque|
			\item Critère d'ordre configurable (strictement inférieur par défaut)
		\end{itemize} 
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Conteneurs - Adaptateurs}
	\begin{lstlisting}[language=C++]
stack<int, vector<int> > foo;
for(int i=0; i<5; ++i) foo.push(i);

// Affiche 4 3 2 1 0
while(!foo.empty()) {
  cout << ' ' << foo.top();
  foo.pop(); }\end{lstlisting}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:19,positionColumn:1,positionLineNumber:19,selectionStartColumn:1,selectionStartLineNumber:19,startColumn:1,startLineNumber:19),source:'%23include+%3Ciostream%3E%0A%23include+%3Cvector%3E%0A%23include+%3Cstack%3E%0A%0Aint+main()%0A%7B%0A++std::stack%3Cint,+std::vector%3Cint%3E+%3E+foo%3B%0A++for(int+i%3D0%3B+i%3C5%3B+%2B%2Bi)%0A++%7B%0A++++foo.push(i)%3B%0A++%7D%0A%0A++while(!!foo.empty())%0A++%7B%0A++++std::cout+%3C%3C+!'+!'+%3C%3C+foo.top()%3B%0A++++foo.pop()%3B%0A++%7D%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B98+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}
	\frametitle{STL Conteneurs - conteneurs non-STL}

\note[item]{\lstinline|std::valarray| laissé de côté, pas vraiment un conteneur}

	\begin{itemize}
		\item \lstinline|std::bitset|
		\begin{itemize}
			\item Tableau de bits de taille fixe (paramètre template)
			\item Conçu pour réduite l'empreinte mémoire
			\item Pas d'itérateur ni d'interface STL

			\begin{block}{\lstinline|std::bitset| et \lstinline|std::vector<bool>|}
				Objectif de gain mémoire déjà adressé par \lstinline|std::bitset| plus adapté, pourquoi \lstinline|std::vector<bool>| n'est-il pas un vrai conteneur de booléen ?
			\end{block}

		\end{itemize}
		\item Conteneurs non-standard
		\begin{itemize}
			\item Listes simplement chaînées
			\item Tables de hachage
			\item Tableaux de taille fixe
			\item Tampons circulaires
			\item Arbres et graphes
			\item Variantes de conteneurs STL (p.ex. \textit{ropes})

\note[item]{\textit{Ropes} : chaîne découpée en morceaux reliés par une liste ou un arbre. Permet les modification à l'intérieur de la chaîne, résout des problème d'espace mémoire contigu trop faible}
\note[item]{\lstinline|std::string| peut être implémentée sous forme de \textit{ropes} en C++98/03, plus en C++11}
\note[item]{Variantes ciblant un autre compromis : listes en tableau, \textit{ropes}, \textit{map} \og à plat\fg{}, etc.}
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{STL Conteneurs - \lstinline|std::pair|}
	\begin{itemize}
		\item Couple de deux valeurs
		\item Pas un conteneur
		\begin{itemize}
			\item Type de retour de la recherche sur les \lstinline|std::map| (couple clé-valeur)
			\item Candidat pour construire des vecteurs indexés par un non-numérique
		\end{itemize}
		\item \lstinline|std::make_pair| construit une paire
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{STL Conteneurs - Choix du conteneur}
	\begin{exampleblock}{Do, par défaut}
		\begin{itemize}
			\item \lstinline|std::string| pour les chaînes de caractères
			\item \lstinline|std::vector|
		\end{itemize}
	\end{exampleblock}		

	\begin{exampleblock}{Do, performances}
		\begin{itemize}
			\item Mesurez avec des données réelles sur la configuration cible
		\end{itemize}
	\end{exampleblock}

	\begin{alertblock}{Flux d'octets}
		\begin{itemize}
			\item Utilisez \lstinline|std::vector<unsigned char>|
			\item Pas \lstinline|std::vector<char>| encore moins \lstinline|std::string|
		\end{itemize}
	\end{alertblock}
\end{frame}

\begin{frame}
	\frametitle{STL Conteneurs - Choix du conteneur}
	\begin{block}{Conseils}
		\begin{itemize}
			\item Voir \cite{effStl} item 1
			\item Voir \href{https://hackingcpp.com/cpp/design/which_std_sequence_container.png}{Which C++ Standard Sequence Container should I use?}
			\item Pensez à \lstinline|reserve()|
			\item Une insertion en vrac suivie d'un tri peut être plus efficace qu'une insertion en place

\note[item]{Voir overload 134 (août 2016) sur big O et les performances \lstinline|std::vector|/\lstinline|std::string|. Et l'importance de la localité des données}

			\item Un vecteur de paires peut être un bon choix pour un ensemble de clés-valeurs
		\end{itemize}
	\end{block}
\end{frame}

\subsection*{STL - Itérateurs}
\begin{frame}
	\frametitle{STL Itérateurs - Généralités}
	\begin{itemize}
		\item Abstraction permettant le parcours des collections d'objets
		\item Interaction entre conteneurs et algorithmes
		\item Interface similaire à celle d'un pointeur
		\item Quatre types
		\begin{itemize}
			\item \lstinline|iterator| et \lstinline|const_iterator|
			\item \lstinline|reverse_iterator| et \lstinline|const_reverse_iterator|

\note[item]{Les \lstinline|const_iterator| sont des itérateurs itérant sur des valeurs constantes, ils peuvent être utilisés pour lire des données mais pas pour les écrire}

		\end{itemize}
		\item Itérateurs sur un conteneur : \lstinline|begin()| et \lstinline|end()|
		\item Itérateurs inverses sur un conteneur : \lstinline|rbegin()| et \lstinline|rend()|
		\item Les itérateurs d'une paire doivent appartenir au même conteneur
	\end{itemize}

	\begin{alertblock}{Itérateurs de fin}
		\begin{itemize}
			\item Pointent un élément après le dernier
			\item Ne doivent pas être déréférencés ni incrémentés
		\end{itemize}
	\end{alertblock}

\note[item]{Un élément après la fin permet de représenter des ensemble vide (si \lstinline|begin| et \lstinline|end| référence le même élément)}
\end{frame}

\begin{frame}
	\frametitle{STL Itérateurs - Catégories et opérations}
	\begin{columns}[T]
		\begin{column}{0.80\textwidth}
			\begin{itemize}
				\item Opérations communes : copie, affectation et incrémentation
				\item Hiérarchie de cinq catégories
				\begin{itemize}
					\item \textit{Input} : égalité (\lstinline|==| et \lstinline|\!=|) et lecture
					\item \textit{Output} : écriture
					\item \textit{Forward} : Parcours multiples

\note[item]{I.e. \og l'incrément ne consomme pas de donnée\fg{}}
\note[item]{Plus formellement, \lstinline|a == b| implique \lstinline|++a == ++b| et utiliser un itérateur sur une séquence ne modifie pas ce que référence un autre itérateur indépendant, c'est à dire que \lstinline|b=a; ++b; *a;| est équivalent à \lstinline|*a|}

					\item \textit{Bidirectional} : décrémentation
					\item \textit{Random access} 
					\begin{itemize}
						\item Déplacement d'un nombre arbitraire (\lstinline|+|, \lstinline|-|, \lstinline|+=|, \lstinline|-=| et \lstinline|[]|)
						\item Comparaison (\lstinline|<|, \lstinline|<=|, \lstinline|>|, \lstinline|>=|)
					\end{itemize} 
				\end{itemize}
			\end{itemize}
		\end{column}

		\begin{column}{0.20\textwidth}
			\begin{picture}(0,10)
				% Boites
				\put(0,0){\framebox(32,12)[c]{Input}}
				\put(36,0){\framebox(32,12)[c]{Output}}
				\put(0,-30){\framebox(68,12)[c]{Forward}}
				\put(0,-60){\framebox(68,12)[c]{Bidirectional}}
				\put(0,-90){\framebox(68,12)[c]{Random Access}}

				%Fleches
				\put(52,-9){\vector(0,1){9}}
				\put(16,-9){\vector(0,1){9}}
				\put(16,-9){\line(1,0){36}}
				\put(34,-18){\line(0,1){9}}
				\put(34,-48){\vector(0,1){18}}
				\put(34,-78){\vector(0,1){18}}
			\end{picture}
		\end{column}
	\end{columns}

	\begin{alertblock}{Attention}
		Seules les versions mutables de \textit{Forward}, \textit{Bidirectional} et \textit{Random access} itérateurs sont des \textit{Output} itérateurs.
	\end{alertblock}
\end{frame}

\begin{frame}
	\frametitle{STL Itérateurs - Catégories et conteneurs}
	\begin{tabular}{ | p{5cm} | p{5cm} |}
		\hline
		Conteneur & Catégorie \\ 
		\hline
		\lstinline{std::vector} & \textit{Random access} \\ 
		\hline
		\lstinline{std::deque} & \textit{Random access} \\ 
		\hline
		\lstinline{std::list} & \textit{Bidirectionnal} \\ 
		\hline
		\lstinline{std::map} et \lstinline{std::multimap} & \textit{Bidirectionnal} \\ 
		\hline
		\lstinline{std::set} et \lstinline{std::multiset} & \textit{Bidirectionnal} \\ 
		\hline
	\end{tabular} 
\end{frame}

\begin{frame}
	\frametitle{STL Itérateurs - Itérateur d'insertion}
	\begin{itemize}
		\item Adaptateur d'itérateurs
		\item De type \textit{Output}
		\item Insertion de nouveaux éléments

\note[item]{Les itérateurs classiques pointent sur des éléments existants du conteneur}

		\begin{itemize}
			\item En queue : \lstinline|back_inserter|
			\item En tête : \lstinline|front_inserter|
			\item À la position courante : \lstinline|inserter|

\note[item]{La disponibilité de tel ou tel itérateur d'insertion dépend du conteneur}
		\end{itemize}
	\end{itemize}
\end{frame}

\subsection*{STL - Algorithmes}
\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Foncteur}
	\begin{itemize}
		\item Instance de classe définissant \lstinline|operator()|
	\end{itemize}

	\begin{lstlisting}[language=C++]
class LessThan {
public:
  explicit LessThan(int threshold)
    : m_threshold(threshold) {}
  bool operator() (int value) { 
    return value <= m_threshold;}

private:
  int const m_threshold; };

LessThan func(10);
cout << func(5) << "\n";   // 1\end{lstlisting}
\end{frame}

\begin{frame}
	\frametitle{STL Algorithmes - Foncteur}
	\begin{itemize}
		\item Possèdent données membres

\note[item]{Ce qui représente un avantage sur les fonctions libres}

		\item Foncteur standards : \lstinline|plus|, \lstinline|minus|, \lstinline|equal|, \lstinline|less|, \ldots
		\item Constructibles
		\begin{itemize}
			\item Depuis des pointeurs de fonctions : \lstinline|prt_fun|
			\item Depuis des fonctions membres : \lstinline|mem_fun|, \lstinline|mem_fun1|, \ldots
			\item En niant d'autres foncteurs : \lstinline|not1|, \lstinline|not2|
			\item En fixant des paramètres : \lstinline|bind1st|, \lstinline|bind2nd|
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{STL Algorithmes - Prédicats}
	\begin{itemize}
		\item Appelable retournant un booléen (ou un type convertible en booléen)
		\item Utilisés par de nombreux algorithmes
		\item De nombreux algorithmes utilisent un prédicat par défaut (p.ex. \lstinline|<| ou \lstinline|==|)
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Parcours}
	\begin{itemize}
		\item \lstinline|std::for_each()| parcourt un ensemble d'éléments
		\item \ldots{} et applique un traitement à chaque élément
	\end{itemize}

	\begin{lstlisting}[language=C++]
void print(int i) { cout << i << ' '; }

vector<int> foo{4, 5, 9 ,12};
for_each(foo.begin(), foo.end(), print);\end{lstlisting}

	\begin{alertblock}{Syntaxe}
		\begin{itemize}
			\item Les exemples utilisent une initialisation de conteneur introduite en C++11
		\end{itemize}
	\end{alertblock}

	\begin{itemize}
		\item Version du \textit{map/apply} fonctionnel
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Parcours}
	\begin{itemize}
		\item Retourne le foncteur passé en paramètre
	\end{itemize}

	\begin{lstlisting}[language=C++]
struct Aggregate {
  Aggregate() : m_sum(0) {}
  void operator() (int i) { m_sum += i;}
  int m_sum; };

vector<int> foo{4, 5, 9 ,12};
for_each(foo.begin(), foo.end(), Aggregate()).m_sum; // 30\end{lstlisting}

	\begin{itemize}
		\item Candidat pour le \textit{fold/reduce} fonctionnel
		\item Pas de sémantique, faible utilité
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Recherche linéaire}
	\begin{itemize}
		\item \lstinline|std::find()| recherche une valeur
		\item \ldots{} et retourne un itérateur sur celle-ci
		\item \ldots{} ou l'itérateur de fin si la valeur n'est pas présente
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{4, 5, 9 ,12};
vector<int>::iterator it1;
vector<int>::iterator it2

// it1 pointe sur foo[1]
it1 = find(foo.begin(), foo.end(), 5);
// Et it2 sur foo.end()
it2 = find(foo.begin(), foo.end(), 19);\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Recherche linéaire}
	\begin{itemize}
		\item \lstinline|std::find_if()| recherche depuis un prédicat
	\end{itemize}

	\begin{block}{Variantes \og \lstinline|_if|\fg{}}
		\begin{itemize}
			\item Les algorithmes suffixés par \lstinline|_if| utilise un prédicat plutôt qu'une valeur
		\end{itemize}
	\end{block}

	\begin{itemize}
		\item \lstinline|std::find_first_of()| recherche la première occurrence d'un élément
		\item \lstinline|std::search()| recherche la première occurrence d'un sous-ensemble
		\item \lstinline|std::find_end()| recherche la dernière occurrence d'un sous-ensemble
		\item \lstinline|std::adjacent_find()| recherche deux éléments consécutifs égaux
		\item \lstinline|std::search_n()| recherche la première suite de n éléments consécutifs égaux à une valeur
	\end{itemize}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:8,positionColumn:1,positionLineNumber:8,selectionStartColumn:1,selectionStartLineNumber:8,startColumn:1,startLineNumber:8),source:'%23include+%3Ciostream%3E%0A%23include+%3Cvector%3E%0A%23include+%3Calgorithm%3E%0A%0Aint+main()%0A%7B%0A++std::vector%3Cint%3E+foo%7B2,+5,+2,+1,+8,+8,+6,+2,+8,+8,+8,+2%7D%3B%0A%0A++std::vector%3Cint%3E::iterator+it+%3D+find(foo.begin(),+foo.end(),+6)%3B%0A++std::cout+%3C%3C+*it+%3C%3C+!'+!'+%3C%3C+*(it%2B1)+%3C%3C+!'%5Cn!'%3B%0A%0A++std::vector%3Cint%3E::iterator+it2+%3D+std::adjacent_find(foo.begin(),+foo.end())%3B%0A++std::cout+%3C%3C+*it2+%3C%3C+!'+!'+%3C%3C+*(it2+-+1)+%3C%3C+!'+!'+%3C%3C+*(it2+%2B+2)+%3C%3C+!'%5Cn!'%3B%0A%0A++std::vector%3Cint%3E::iterator+it3+%3D+std::search_n(foo.begin(),+foo.end(),+3,+8)%3B%0A++std::cout+%3C%3C+*it3+%3C%3C+!'+!'+%3C%3C+*(it3+-+1)+%3C%3C+!'+!'+%3C%3C+*(it3+%2B+3)+%3C%3C+!'%5Cn!'%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Recherche dichotomique}
	\begin{itemize}
		\item Pré-requis : ensemble trié
		
\note[item]{Ensemble trié au sens du prédicat de comparaison}
		
		\item \lstinline|std::lower_bound()| retourne un itérateur sur le premier élément non strictement inférieur à la valeur recherchée

\note[item]{Formulation \og n'est pas strictement inférieur\fg{} semble être une tournure compliquée pour supérieur ou égal, mais c'est précisément ce que fait la fonction et c'est important si on fourni un prédicat de comparaison}

		\item \ldots{} et l'itérateur de fin si un tel élément n'existe pas
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{4, 5, 7, 9, 12};

*lower_bound(foo.begin(), foo.end(), 6);  // 7
*lower_bound(foo.begin(), foo.end(), 9);  // 9\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Recherche dichotomique}
	\begin{itemize}
		\item \lstinline|std::upper_bound()| retourne un itérateur sur le premier élément strictement supérieur à la valeur recherchée 
		\item \lstinline|std::equal_range()| retourne la paire (\lstinline|lower_bound|, \lstinline|upper_bound|)
	\end{itemize}

	\begin{alertblock}{Attention}
		\begin{itemize}
			\item Le résultat retourné peut ne pas être la valeur recherchée
		\end{itemize}
	\end{alertblock}

	\begin{itemize}
		\item \lstinline|std::binary_search()| indique si l'élément cherché est présent
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Recherche dichotomique}
	\begin{alertblock}{Attention}
		\begin{itemize}
			\item Pas de fonction de recherche dichotomique retournant l'élément cherché
		\end{itemize}
	\end{alertblock}

	\begin{lstlisting}[language=C++]
vector<int>::iterator foo(vector<int> vec, int val) {
  vector<int>::iterator it = 
    lower_bound(vec.begin(), vec.end(), val);
  if(it != vec.end() && *it == val) return it;
  else return vec.end(); }

vector<int> bar{1, 5, 8, 13, 25, 42};
foo(bar, 12);  // vec.end
foo(bar, 13);  // iterateur sur 13
\end{lstlisting}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1DIApACYAQuYukl9ZATwDKjdAGFUtAK4sGe1wAyeAyYAHI%2BAEaYxCBmAJykAA6oCoRODB7evnrJqY4CQSHhLFEx8baY9vkMQgRMxASZPn5cFVXptfUEhWGR0bEJCnUNTdmtQ109xaUDAJS2qF7EyOwc5gDMwcjeWADUJutuTkPEmKwH2CYaAIIbWzuY%2B4cAbpgOJBdXt2abDNteewObjEwBIhAQLE%2BNy%2BwQIuxYTGCEFmXxMAHYrDddrshugQCBXu9iEDYRddvxUOiLNJdgBWUi7NEMhK7LhmdEAEQOmNuWP2GK%2B2OxuPxhKIxMOpPW2HxhGiTHFu0ITw5OIIeJAtFQAHdogB9CKLBjoaioVAAOiiwCR83JZvNrmRDIAbCj1jyhWqNWgvHCgUDdgAqZX%2Bw67MBrWluBgR7mC/lc6F8qnx4Xq0VvcUkwQXWUEeWKkPrVUizU6/WGrzG00Wq02hkUh3V21xN0eoWln1%2Bw4B4PdtwB2NRmNrd3xzmo5MCvlpjVij6SnPSvMFkhK7sl9MgLyJRIVo0mxt1hhOu0Wx0ttupr34rtPAdhvv3weR6OxsdTxO867YlMzm8gIkiISm4pbziBUoyiAcrEAqJAMmBmYLkcS5QTBcEStguynAoKoAZgACOXhiHqsFGJgNaWpg1onrajYXi6V7/p2iz9r2EA4eaNDEEMszPmGEbhhw/FuEGHGYAo5pKGgxp8aGolDm%2Bo7thO0Jol%2BHDzLQnC0rwfgcFopCoJwA6WNYOKLMsjwbDwpAEJomnzAA1iAtIaPonCSHpDlGZwvAKCA7n2QZmmkHAsBIJgqhvL68EUBA9TAAoyiGJUQgIDq%2Bm2WgLCJHQCrpClIS0OlmU%2BTleX0DEwBsmYpAVXQ0ShKwqy8A1VUAPK%2BqV2r6YZUVvNcxBJX5pADcgtT4PpvD8IIIhiOwUgyIIigqOoIWkLorQGEYKDWNY%2Bh4BEAWwMwbAgIaKQEKQrwxNwaK6bM8yoIk1QBRwAC0uIHByphmZYXBcLsH0AOpiLQwMg1FBCwf5lkrHouLBEVaUZb1nC2TDmCrLZ2qwYkDlaTp3kbcZHDYNFyCxcQuyqAAHM6H3OpIuzAMgyCsmY5pmLsECmVYlgMrghBrjZsy8MFWhPaQCBnFgMROi5bkeRwXmkH1vBk/5gV2YTRMcGYJOGVrushdLt2pM4khAA%3D}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Comptage}
	\begin{itemize}
		\item \lstinline|std::count()| compte le nombre d'éléments égaux à la valeur fournie
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{4, 5, 3, 9, 5, 5 ,12};

count(foo.begin(), foo.end(), 5);  // 3
count(foo.begin(), foo.end(), 2);  // 0\end{lstlisting}

	\begin{itemize}
		\item \lstinline|std::count_if()| compte le nombre d'éléments satisfaisant le prédicat
	\end{itemize}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:62,endLineNumber:15,positionColumn:62,positionLineNumber:15,selectionStartColumn:62,selectionStartLineNumber:15,startColumn:62,startLineNumber:15),source:'%23include+%3Ciostream%3E%0A%23include+%3Cvector%3E%0A%23include+%3Calgorithm%3E%0A%0Abool+compare(int+nb)%0A%7B%0A++return+nb+%3E%3D+5%3B%0A%7D%0A%0Aint+main()%0A%7B%0A++std::vector%3Cint%3E+foo%7B2,+5,+2,+1,+8,+8,+6,+2,+8,+8,+8,+2%7D%3B%0A%0A++std::cout+%3C%3C+std::count(foo.begin(),+foo.end(),+8)+%3C%3C+!'%5Cn!'%3B%0A++std::cout+%3C%3C+std::count(foo.begin(),+foo.end(),+7)+%3C%3C+!'%5Cn!'%3B%0A%0A++std::cout+%3C%3C+std::count_if(foo.begin(),+foo.end(),+compare)+%3C%3C+!'%5Cn!'%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Comparaison}
	\begin{itemize}
		\item \lstinline|std::equal()| teste l'égalité de deux ensembles (valeur et position)
	\end{itemize}

\note[item]{Possibilité de fournir un prédicat de comparaison (\lstinline|==| sinon)}

	\begin{lstlisting}[language=C++]
vector<int> foo{4, 5, 9, 12};
vector<int> bar{4, 5, 12, 9};

equal(foo.begin(), foo.end(), foo.begin());  // true
equal(foo.begin(), foo.end(), var.begin());  // false\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Comparaison}
	\begin{alertblock}{Attention}
		\begin{itemize}
			\item \lstinline|std::equal()| ne vérifie pas les tailles des deux ensembles
		\end{itemize}
	\end{alertblock}

\note[item]{Comparaison sur la taille du premier ensemble (couple \lstinline|begin| - \lstinline|end|)}
\note[item]{C++14 ajoute des surcharges de \lstinline|std::equal()| testant la taille}

	\begin{block}{Et \lstinline|operator==| ?}
		\begin{itemize}
			\item \lstinline|operator==| sur des conteneurs teste la taille et le contenu
		\end{itemize}
	\end{block}

	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Préférez \lstinline|operator==| à \lstinline|std::equal()| pour comparer un conteneur complet
		\end{itemize}
	\end{exampleblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Comparaison}
	\begin{itemize}
		\item \lstinline|std::mistmatch()| retourne une paire d'itérateurs sur les premiers éléments différents
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{4, 5, 9, 13};
vector<int> var{4, 5, 12, 8};

mismatch(foo.begin(), foo.end(), bar.begin());  // 9 12\end{lstlisting}

	\begin{itemize}
		\item Ou l'itérateur de fin en cas d'égalité
	\end{itemize}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1DIApACYAQuYukl9ZATwDKjdAGFUtAK4sGISQDspK4AMngMmAByPgBGmMQgZtIADqgKhE4MHt6%2B/kGp6Y4CYRHRLHEJSbaY9kUMQgRMxATZPn6S0naYDpkNTQQlUbHxiZ2Nza25HbbjA%2BFD5SNJAJS2qF7EyOwc5gDM4cjeWADUJrtuTgoExJisZ9gmGgCCewdHmKfnAG7dRMT3jxeZn2DEOXhOZzcYmAJEICBYAOegPCBGOLCY4Qgy0BJgCVmex2OV3QIBAPwcJEhKPux34qFxFi4pGOAFZmQAOZlmXEAETO%2BJeBNOeMBhMJxNJ5L%2BVMENJiTQZTNZHK5vP5orFEpQ61RkMhRIIJJAMVQnjEyQQTE%2Bbn1WswAEcvGJqKaAHRxYCY1a0t2uLHM%2BXEd2YT0MLHLa36sA7FluBjR9VC8WG0loLy6862lPG00GWgWq1687HF2oT583Y846BiNFtzHBOx%2BM7XYCwlqpFChka5NGqWU87U3bYasKvFK3Zc5kBNWtnsGo1pjM24tak1m/OWyOr7MOp20UvB0P%2Bn2oV1%2B72Bo9e2uZ4uNuMJudJhepnXb%2Btr3Pmrd1kt08szirGsPwbGNHxbNthT5TsnnbEUXy1ft/kHWVh1Hf5x2ZNljk5Y4zGZSRZyg3s33TUCvw3AsKN3R1nTpa8w29BiLwDJpGPDUCH2bRM4M1bMlxoo11zzai/1LQDKww28V3rbinygjtBT47tEOzZCZQIOUx0ZZlJ3w6diPnLVkgxFC3CQ34BwuNDsFJQh4iYP5mUsilzKHOyQAc4gnIHEcbgUctXxAFg8AUdECGQBBDw9L1mRYhh0BPK9YqY7Fnz40jtXIv8ACoIAC10aGIK4ZKjDgwNA/LCqUNBErK%2B9wJ4jL4Jgl4AjajhVloTgWV4PwOC0UhUE4G1LGsIl1k2D49h4UgCE0LrVgAaxAFkNH0ThJH6xbhs4XgFBADaFsGrrSDgWAkEwVRunTEhyEoJpgAUZRDBqIQEFQAB3Aa5rQFhkjoJzMleiJaA%2B76BqG/7AfoBJgC4MwCJhuh4kiVhtl4FG4YAeXTCGft267uieYhnv24IbuQBp8AG3h%2BEEEQxHYKQZEERQVHUU7SF0JkDCMFBrGsfQ8BiQ7YGYNgczSAhSB%2BBJuACPrllWVBkjqQ6OAAWmJIDTHGywuC4Y4tYAdTEWgTdN67riYA6pq2PRiXCUH3s%2BwnuF4a5MG2Oavp85JFu63qdu5kaOGwKm7uIY5VHZAA2LX48kY5gGQZBjkR10zBLMarEsZlcEIEhTmBLhli9oPVgQW4sASf1VvWzaOG20god4cODqO%2Baq%2BbsxQ6Gzue9OlW5fidJnEkIA%3D%3D%3D}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Remplissage}
	\begin{itemize}
		\item \lstinline|std::fill()| remplit l'ensemble avec la valeur fournie
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo(4);

fill(foo.begin(), foo.end(), 12);  // 12 12 12 12\end{lstlisting}

	\begin{itemize}
		\item \lstinline|std::fill_n()| idem avec un ensemble défini par sa taille
	\end{itemize}

	\begin{block}{Constructeur}
		\begin{itemize}
			\item Remplissage des conteneurs séquentiels à la construction
		\end{itemize}

		\begin{lstlisting}[language=C++]
vector<int> foo(4, 12);\end{lstlisting}
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Remplissage}
	\begin{itemize}
		\item \lstinline|std::generate()| valorise les éléments à partir d'un générateur
	\end{itemize}

	\begin{lstlisting}[language=C++]
int gen() {
  static int i = 0;
  i += 5;
  return i; }

vector<int> foo(4);
generate(foo.begin(), foo.end(), gen);  // 5 10 15 20\end{lstlisting}

	\begin{itemize}
		\item \lstinline|std::generate_n()| idem avec un ensemble défini par sa taille
	\end{itemize}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1DIApACYAQuYukl9ZATwDKjdAGFUtAK4sGe1wAyeAyYAHI%2BAEaYxCAAzAAcpAAOqAqETgwe3r56KWmOAkEh4SxRMQm2mPYFDEIETMQEWT5%2BXJXVGXUNBEVhkdF6CvWNzTltQ929JWUSAJS2qF7EyOwc5rHByN5YANQmsW5OQ8SYrPvYJhoAguub25h7BwBumA4k55c3ZhsMW167%2BzcYmAJEICBYH2unwmjmQO2CBB2wEYEFmnxMAHYrNcdjsYXg4Qj4Y8ACI7DT7bFXXF4PaWfZkgCslM%2BuJOBCWDHhLKhGJJ6OuRJYTGCqPRWNZewlONxeII6BAIBeb2IgIR5x2/FQEEkaNiVNlcoVIBotFo1FQqAAdFFgKL5prLVbXKjSDtJGY9QbZUNjWgvIjAYDHagTIyLBTGWSgwcdmAOHGEzG3CGwxYuGHowdg/HE483MGtWmzJn8zmE7nk6nw7FS1X42G3AwG/rJZj%2BVCZZjvbjfYrlURVQd1bFsKnWzLe/LFabaAB9BgQPsgCJMZAAaznwSUjWiFtQDuk7tiXslU79i0D2djRfDkazBdjucr15Tt/TddfeZfj7fluLn6/t%2BSZfu%2BtZRmWT5rIyTYtt67YCtSUo9ka/avIOaqCBqWo6m6ki6jySHnoq/pXkB773pBKbPiB5H/uGGYQfWFa0YW9EWCWTFfjRVHVhY4EPuWjbNmsE5IQhnbidKRGoUq6HvMOWGjiGOqnpOsnIiExBMAQmD7jamB2ouDpas6DDoK6SKMF6uIAPS2TsjI7FwGjOU5ZgUupy6kbxFGAeWeZVu%2BjGCVBgWgexnGhdRLG%2BexAm8Q2MEiYRuISTcvIdlcHDzLQnCMrwfgcFopCoJwBb0pYeKLMsDzrDwpAEJoOXzOuICMho%2BicJIhXNaVnC8AoICdU1xU5aQcCwEgmCqK8AYkOQlANMACjKIYVRCAgqAAO5FQ1aAsEkdA6Rka0hLQm07UVJUHUd9AxMAXBmGYpC3XQ0ShKwqy8G990APIBpdu19TNrxXMQK0DaQoPIHU%2BBFbw/CCCIYjsFIMiCIoKjqGNpC6G0BhGCg1jWPoeARENsDMGwK6WkMpAvDE3AYgVszzKgSQ1ENHAALS%2BgypiVRYACc8Q7DzADqYi0OLEszQQ2mDTVKyDPKwRnRtW3A9wvAK5gqwNdt2lJM1uX5b1uNlRw2Czcg83EDsqjxAAbDzzuSEiyBwk9VpmDsEAVVYlhurghAkHSsRcLMuum/MCCnFgMSum1HVdRwPWkNdvBW4Nw2NbHadmBbJU5/nY1swz0RpM4khAA%3D%3D%3D}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Copie}
	\begin{itemize}
		\item \lstinline|std::copy()| copie les éléments (du début vers la fin)
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{4, 5, 9, 12};
vector<int> bar;

copy(foo.begin(), foo.end(), back_inserter(bar));\end{lstlisting}

	\begin{itemize}
		\item \lstinline|std::copy_backward()| copie les éléments (de la fin vers le début)
	\end{itemize}

	\begin{alertblock}{Attention}
		\begin{itemize}
			\item À la taille du second ensemble

\note[item]{Il faut un second ensemble assez grand ou utiliser un itérateur d'insertion}

			\item Aux ensembles non-disjoints

\note[item]{L'itérateur du second ensemble ne doit pas pointé un élément du premier ensemble.}
		\end{itemize}
	\end{alertblock}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1DIApACYAQuYukl9ZATwDKjdAGFUtAK4sGe1wAyeAyYAHI%2BAEaYxCBmZqQADqgKhE4MHt6%2BekkpjgJBIeEsUTFxtpj2eQxCBEzEBBk%2BflzllWk1dQQFYZHRsfEKtfWNWS2Dnd1FJf0AlLaoXsTI7BzmAMzByN5YANQma25Og8SYrPvYJhoAguub25h7BwBumA4k55c3ZhsMW167%2BzcYmAJEICBYH2un2CBB2LCYwQgM0%2BJgA7FZrjsdoN0CAQC83sRATDzjt%2BKg0RYAKykHZmABstNRtK4ZjRABF9hibpi9ujPlisTi8QSiESDiS1tgdhE6lyBYLhShUAkAJ7UVCoAB0UWAiLmZM1WtcSNpStlyAA1gB9YJKerRCCy4gzZFrbmC7EEXHKrywwGAmVyqkWDQmKnsx5uQNgDg7WNRwPO8MWLjhyMBg7xuMJzNuINEkNsiOJrMJ3MHJPBixrdOl/Ox8NuBiN90Kjko3mUhVC70i15i4mCUnOiAADjdHsVfeVautFstAHc6ugNdrdfraeTjQxVwbnTu95Oe16fWg/fWCymwyW89n73fkyG07fK2Wc3HH9Xixm3w2P5eT41nWd6NlSzatlOvZngs/p/leIaSCB8Hlp%2B8FAVSyHRu%2BD7odW9JYTGAFfoWFiooR75Ni2qxtl2qKclC9GfBwcy0JwVK8H4HBaKQqCcNGljWNiCxLA86w8KQBCaCxcyWiAVIaPonCSJx0m8ZwvAKCAilSdxLGkHAsBIJgqivH6JDkJQdTAAoyiGBUQgIKgi5cRJaAsAkdBMFUdkhLQjnOVxPHuZ59AxMArLxCFdDRKErArLw0VhQA8n6AUuWpJmvFcxA2RppBZcgNT4FxvD8IIIhiOwUgyIIigqOoemkLoLQGEYKDWNY%2Bh4BEWmwMwbAgBEmqDKQLwxNwqIca6vEJFUWkcAAtDi%2BzsqYgmWFwXA7ItADqYi0Dtu0mQQxBMJpInLHoOLBL5DlORl3C8KdmArBJi5nQk0msexqlNXxHDYKZyDmcQOyqGO9KLfSkg7MAyDIDsrJamYOwQAJViWLSuCECQezfFwMzPd9cwIKcWAxKackKUpHAqaQQW8ADmnaZJJO02Yf08czbN6TN40pM4khAA%3D%3D%3D}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Échange}
	\begin{itemize}
		\item \lstinline|std::swap()| échange deux objets
	\end{itemize}

	\begin{lstlisting}[language=C++]
int x=10, y=20;   // x:10 y:20
swap(x,y);        // x:20 y:10\end{lstlisting}

	\begin{itemize}
		\item \lstinline|std::swap_ranges()| échange des éléments de deux ensembles
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo (5,10); // foo: 10 10 10 10 10
vector<int> bar (5,33); // bar: 33 33 33 33 33

swap_ranges(foo.begin()+1, foo.end()-1, bar.begin());
// foo : 10 33 33 33 10
// bar : 10 10 10 33 33\end{lstlisting}

	\begin{itemize}
		\item \lstinline|std::iter_swap()| échange deux objets pointés par des itérateurs
	\end{itemize}

	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:3,endLineNumber:12,positionColumn:3,positionLineNumber:12,selectionStartColumn:3,selectionStartLineNumber:12,startColumn:3,startLineNumber:12),source:'%23include+%3Ciostream%3E%0A%23include+%3Cvector%3E%0A%23include+%3Calgorithm%3E%0A%0Aint+main()%0A%7B%0A++std::vector%3Cint%3E+foo+(5,10)%3B%0A++std::vector%3Cint%3E+bar+(5,33)%3B%0A%0A++std::cout+%3C%3C+bar%5B0%5D+%3C%3C+%22+%22+%3C%3C+bar%5B1%5D+%3C%3C+%22+%22+%3C%3C+bar%5B2%5D+%3C%3C+%22+%22+%3C%3C+bar%5B3%5D+%3C%3C+%22+%22+%3C%3C+bar%5B4%5D+%3C%3C+%22%5Cn%22%3B%0A++std::swap_ranges(foo.begin()+%2B+1,+foo.end()+-+1,+bar.begin())%3B%0A++std::cout+%3C%3C+bar%5B0%5D+%3C%3C+%22+%22+%3C%3C+bar%5B1%5D+%3C%3C+%22+%22+%3C%3C+bar%5B2%5D+%3C%3C+%22+%22+%3C%3C+bar%5B3%5D+%3C%3C+%22+%22+%3C%3C+bar%5B4%5D+%3C%3C+%22%5Cn%22%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B98+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Remplacement}
	\begin{itemize}
		\item \lstinline|std::replace()| remplace toutes les occurrences d'une valeur par une autre
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{4, 5, 7, 9 ,12, 5};

replace(foo.begin(), foo.end(), 5, 8);  // 4 8 7 9 12 8\end{lstlisting}

	\begin{itemize}
		\item \lstinline|std::replace_if()| remplace toutes les éléments vérifiant le prédicat par une valeur donnée
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Remplacement}
	\begin{itemize}
		\item \lstinline|std::replace_copy()| copie les éléments d'un ensemble en remplaçant toutes les occurrences d'une valeur par une autre
	\end{itemize}

	\begin{block}{Variantes \og \lstinline|_copy|\fg{}}
		\begin{itemize}
			\item Les algorithmes suffixés par \lstinline|_copy| fonctionne comme l'algorithme de base en troquant la modification en place contre une copie du résultat
		\end{itemize}
	\end{block}

	\begin{itemize}
		\item \lstinline|std::replace_copy_if()| copie les éléments d'un ensemble en remplaçant toutes les éléments vérifiant le prédicat par une valeur donnée
	\end{itemize}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1DIApACYAQuYukl9ZATwDKjdAGFUtAK4sGe1wAyeAyYAHI%2BAEaYxCCSAJykAA6oCoRODB7evnrJqY4CQSHhLFEx8baY9vkMQgRMxASZPn5cFVXptfUEhWGR0XoKdQ1N2a2DXT3FpRIAlLaoXsTI7BzmAMzByN5YANQma25Og8SYrPvYJhoAguub25h7BwBumA4k55c3ZhsMW167%2BzcYmAJEICBYH2un3GjmQOwiqE8O2QCFeAGsIMECDsmDNPiYAOxWa47HYnAiLBg4x4XNYAER2BP2xJuBLp%2BOuWJ2LCYwQgeKhRM%2BpMJLNJpMG6BAIBeb2IgKx5x2/FQoukOwArKRGdq4jtSFwzNqNYT2WsxeLJdKTokDMtqIiAHRRYB8ubKp2ufnG7UADjx5uF4v4xAgqQAXpgAPrYnZ4R4MjTMuOPNwe1COiOYfnJ6zWPACq7ivZCknFnZWlALbGAwHpkwaix4BsM2sHHZgDgd1aBssitlBiUEKVVrw1g51zsNtwMKe9osl9lQsuiwcV4fS2VEeUHRVrbD1onqrU6nZ6g1GzWm5lrys2u3RvBUB0Zl1u7Uqx1e90o9F%2BgMWqSIZhngkYxqS8b7ImyaQe2n5Zjm5p7JY%2BaFsWq59paG6juObh1iqDZNi2qaTl2c6AYut7YWgY4ke2U4ajO5FBtey4LhhC5DiOW7vLughKgRR4%2Bqe56Gsa17zsWlY8Tuhz8fu8L1DemF3pgtpMMsUZoIkACeL7OpgroMN66Zfgw6AmZWEQaWiUbBEoDTRBA1nEO6J7%2BspnEeqGWbgSmUE7EmSGwWm8GgdmAHIVYlgFmuHHluuI40bh%2BGIoRzYaq2E70WRPYUaxXmVsldFpgxTF5RyXnAb5sawdBwWpopxCZuFiEWFFqFxaWXlcdKxVtmmLnpcRA3dt2nnoQOKnUdWJXjYxs4VSuU2skuVwcHMtCcBqvB%2BBwWikKgnB4ShlgVgsSwPOsPCkAQmgbXMaIgBqGj6Jwki7fdh2cLwCggK9d37RtpBwLASCYKorxjiQ5CUPUwAKMohiVEICCoAA7ntN1oCwiR0Ew1RIyEtCoxje0HTjeP0DEwCGkalN0NEoSsCsvAM9TADyY6k5jX0Q68VzEAjP2kPzyC1Pge28PwggiGI7BSDIgiKCo6hA6QuitAYRgoHmlj6HgER/bAzBsCACIpAQpAvDE3AEjtMxzKgiTVH9HAALSSlBpinRYXBcDs7sAOpiLQgdBxDBDEEwv0XcsAzDsERMo2jvPcLwUeYCsN3o9HiT3Zt22ferR0cNgkPINDxA7KovoAGzu3Xkg7MAyBwoajpmDsEAndFNg7LghAkMhaxcDMGcF3MqJMFgMTek9L1vRwH2kOTvCl79/23ZPS9mMXB0b9vQOO9b0SpM4khAA%3D%3D%3D}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Suppression}
	\begin{itemize}
		\item \lstinline|std::remove()| \og élimine\fg{} les éléments égaux à une valeur donnée
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{4, 5, 5, 5, 7, 9, 9, 5};
remove(foo.begin(), foo.end(), 5);    // 4 7 9 9 ...\end{lstlisting}

\note[item]{La comparaison se fait via l'opérateur \lstinline|==| et n'est pas paramétrable}

	\pause

	\begin{alertblock}{Pas de suppression}
		\begin{itemize}
			\item Ramène les éléments à conserver vers le début de l'ensemble
			\item Retourne l'itérateur correspond à la nouvelle fin
		\end{itemize}
	\end{alertblock}

\note[item]{\lstinline|std::remove()| ne supprime pas car les algorithmes ne peuvent pas modifier le conteneur, en particulier sa taille, mais seulement le contenu de ses éléments}

	\pause

	\begin{block}{Idiome \textit{Erase-Remove}}
		Suppression via un appel à \lstinline|erase()| sur les éléments après le nouvel itérateur de fin
	
		\begin{lstlisting}[language=C++]
foo.erase(remove(foo.begin(),foo.end(),5),foo.end());\end{lstlisting}
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Suppression}
	\begin{itemize}
		\item \lstinline|std::remove_if()| \og élimine\fg{} les éléments vérifiant le prédicat
		\item \lstinline|std::remove_copy()| copie les éléments différents d'une valeur donnée
		\item \lstinline|std::remove_copy_if()| copie les éléments ne vérifiant pas le prédicat
	\end{itemize}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:26,positionColumn:1,positionLineNumber:26,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%23include+%3Cvector%3E%0A%23include+%3Calgorithm%3E%0A%0Astatic+void+print(int+a)%0A%7B%0A++std::cout+%3C%3C+a+%3C%3C+!'+!'%3B%0A%7D%0A%0Aint+main()%0A%7B%0A++std::vector%3Cint%3E+foo%7B4,+5,+5,+5,+7,+9,+9,+5%7D%3B%0A%0A++std::vector%3Cint%3E::iterator+it+%3D+std::remove(foo.begin(),+foo.end(),+5)%3B%0A++std::for_each(foo.begin(),+it,+print)%3B%0A++std::cout+%3C%3C+!'%5Cn!'%3B%0A%0A%23if+0%0A++for(size_t+i++%3D+0%3B+i+%3C+foo.size()%3B+%2B%2Bi)%0A++%7B%0A++++std::cout+%3C%3C+foo%5Bi%5D+%3C%3C+!'+!'%3B%0A++%7D%0A++std::cout+%3C%3C+!'%5Cn!'%3B%0A%23endif%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:16,positionColumn:1,positionLineNumber:16,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%23include+%3Cvector%3E%0A%23include+%3Calgorithm%3E%0A%0Aint+main()%0A%7B%0A++std::vector%3Cint%3E+foo%7B4,+5,+5,+5,+7,+9,+9,+5%7D%3B%0A%0A++foo.erase(std::remove(foo.begin(),+foo.end(),+5),+foo.end())%3B%0A++for(size_t+i++%3D+0%3B+i+%3C+foo.size()%3B+%2B%2Bi)%0A++%7B%0A++++std::cout+%3C%3C+foo%5Bi%5D+%3C%3C+!'+!'%3B%0A++%7D%0A++std::cout+%3C%3C+!'%5Cn!'%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Suppression des doublons}
	\begin{itemize}
		\item \lstinline|std::unique()| \og élimine\fg{} les éléments consécutifs égaux sauf le premier
	\end{itemize}

\note[item]{Tout comme \lstinline|remove|, les éléments ne sont pas supprimés du conteneur mais déplacé à la fin et l'itérateur correspondant est renvoyé}
\note[item]{Un prédicat de comparaison peut être fourni, sinon \lstinline|operator==| est utilisé}
\note[item]{L'ordre relatif est préservé, important si la comparaison ne se fait que sur une partie d'un élément composite}

	\begin{lstlisting}[language=C++]
vector<int> foo{4, 5, 5, 5, 7, 9, 9, 5};

unique(foo.begin(), foo.end());  // 4 5 7 9 5 ... \end{lstlisting}

	\begin{itemize}
		\item \lstinline|std::unique_copy()| copie l'ensemble en ne conservant que le premier des éléments consécutifs égaux
	\end{itemize}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:26,positionColumn:1,positionLineNumber:26,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%23include+%3Cvector%3E%0A%23include+%3Calgorithm%3E%0A%0Astatic+void+print(int+a)%0A%7B%0A++std::cout+%3C%3C+a+%3C%3C+!'+!'%3B%0A%7D%0A%0Aint+main()%0A%7B%0A++std::vector%3Cint%3E+foo%7B4,+5,+5,+5,+7,+9,+9,+5%7D%3B%0A%0A++std::vector%3Cint%3E::iterator+it+%3D+std::unique(foo.begin(),+foo.end())%3B%0A++std::for_each(foo.begin(),+it,+print)%3B%0A++std::cout+%3C%3C+!'%5Cn!'%3B%0A%0A%23if+0%0A++for(size_t+i++%3D+0%3B+i+%3C+foo.size()%3B+%2B%2Bi)%0A++%7B%0A++++std::cout+%3C%3C+foo%5Bi%5D+%3C%3C+!'+!'%3B%0A++%7D%0A++std::cout+%3C%3C+!'%5Cn!'%3B%0A%23endif%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Transformation}
	\begin{itemize}
		\item \lstinline|std::transform()| applique une transformation aux éléments d'un ensemble
	\end{itemize}

	\begin{lstlisting}[language=C++]
int double_val(int i) { return 2 * i;}

vector<int> foo{4, 5, 7, 9};
vector<int> bar(4);
transform(foo.begin(), foo.end(), bar.begin(), double_val);
// 8 10 14 18\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Transformation}
	\begin{itemize}
		\item Ou de deux ensembles en stockant le résultat dans un troisième
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{4, 5, 7, 9};
vector<int> bar{2, 3, 6, 1};
vector<int> baz(4);

transform(foo.begin(), foo.end(), bar.begin(), 
          baz.begin(), plus<int>());
// 6 8 13 10\end{lstlisting}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1DIApACYAQuYukl9ZATwDKjdAGFUtAK4sGe1wAyeAyYAHI%2BAEaYxCAAzADspAAOqAqETgwe3r56KWmOAkEh4SxRMQm2mPYFDEIETMQEWT5%2BXJXVGXUNBEVhkdF6CvWNzTltQ929JWUSAJS2qF7EyOwc5rHByN5YANQmsW5OQ8SYrPvYJhoAguub25h7BwBumA4k55c3ZhsMW167%2BzcYmAJEICBYH2unwmjmQO2CBB26EWEXoAH0nmIIAj4bNPiZ4lZrjsdicCEsGDszDsAFTw/ZEm7xAAi%2BOuOJYTGCEDxUMJnxJBMZJJJQ3QIBALzexEBCPOO34qCF0h2AFZSDtEjsAJwE1mxYUisUSqVEGUHOWxbA7CINCCSPEGtlXEU7Y0gAjEQwKfjEFjUVCoAB0UWA3PmCsDQdcPI1tuIIcwYYYsaRKPRmNojsNJN9EDSAC9MGjEXhHsydhoGfDHm4bQ0g4XMDzq9ZrHheS6RUKBa63QRxShFojAYD6zLVRY8CZVRXRwcdmAOIu1k7id2Wb3RQOJWgvCODmOlzO3Axj2uu3rnYL%2Bevt4PTe8LYJ5YrlRr1ZqNbrNxfXe7H3NQ4XytcchTMDVYg1AA2DUuCvP8jR3SVXjNWUQOtW0C3tbNryQwdPW9X1/UVRNk1TUiYwjeMyPDOMmALWiUwjd0km8BR0IIc4eVwu9I2IfM8CLEsa32CsqwNUSFywxshObbM9ksdtO1dHs%2BPvXdh1rMcsJnKcZznQ8FyXFcGS3PZNz4909wPNwjzWVVT3PQ0rz5Vlrg4eZaE4VVeD8DgtFIVBODspTLDdRZlgedYeFIAhNE8%2BYAGsQFVDR9E4SQ/ISoLOF4BQQHS%2BKAs80g4FgJBMFUV59xIchKAaYAFGUQwqiEBBUAAd382K0BYJI6CYGoWpCWh2q6/zAr6gb6BiYAuDMCDproaJQlYVZeGW2aAHl93G7qcqq14rmIJq8tII7kDqfB/N4fhBBEMR2CkGRBEUFR1BK0hdDaAwjBQNtLH0PAIgK2BmDYEAIkDIZSBeGJuHiXzZnmVAkhqAqOAAWjFMTTDCiwuC4HYsYAdTEWgSdJqrCPyyKVkGAdghGtqOoO7heE9TBVlizqvSSBKvJ87KvuCjhsGq5BauIHZVAADmgrHoMkHZgGQOEFqDakIFCqwgZ2XBCBIRTYi4WZOcF%2BYEFOLAYljFK0oyjgstISbeDF/LCriy2nbMEXAo972SpRuHojSZxJCAA%3D%3D%3D}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Rotation}
	\begin{itemize}
		\item \lstinline|std::rotate()| effectue une rotation de l'ensemble, le nouveau début étant fourni par un itérateur
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{4, 5, 7, 9, 12};

rotate(foo.begin(), foo.begin() + 2, foo.end());
// 7 9 12 4 5\end{lstlisting}

	\begin{itemize}
		\item \lstinline|std::rotate_copy()| effectue une rotation et copie le résultat
	\end{itemize}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:3,endLineNumber:14,positionColumn:3,positionLineNumber:14,selectionStartColumn:3,selectionStartLineNumber:14,startColumn:3,startLineNumber:14),source:'%23include+%3Ciostream%3E%0A%23include+%3Cvector%3E%0A%23include+%3Calgorithm%3E%0A%0Aint+main()%0A%7B%0A++std::vector%3Cint%3E+foo%7B4,+5,+7,+9,+12%7D%3B%0A%0A++std::rotate(foo.begin(),+foo.begin()+%2B+2,+foo.end())%3B%0A++for(size_t+i+%3D+0%3B+i+%3C+foo.size()%3B+%2B%2Bi)%0A++%7B%0A++++std::cout+%3C%3C+foo%5Bi%5D+%3C%3C+!'+!'%3B%0A++%7D%0A++std::cout+%3C%3C+!'%5Cn!'%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Partitionnement}
	\begin{itemize}
		\item \lstinline|std::partition()| réordonne l'ensemble pour que les éléments vérifiant le prédicat soit avant ceux ne le vérifiant pas \ldots
	\end{itemize}

	\begin{lstlisting}[language=C++]
bool is_odd(int i) { return (i % 2) == 1; }

vector<int> foo{4, 13, 28, 9 , 54};
partition(foo.begin(), foo.end(), is_odd);
// 9 13 28 4 54 ou 9 13 4 28 54 ou ...)\end{lstlisting}

\note[item]{Le prédicat \lstinline|is_odd| sera utilisé par la suite sans être redéfini à chaque fois}

	\begin{itemize}
		\item \ldots{} et retourne un itérateur sur le début de la seconde partie
	\end{itemize}

	\begin{alertblock}{Attention}
		\begin{itemize}
			\item Ordre relatif non conservé
		\end{itemize}
	\end{alertblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Partitionnement}
	\begin{itemize}
		\item \lstinline|std::stable_partition()| partitionne en conservant l'ordre relatif
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{4, 13, 28, 9 , 54};

stable_partition(foo.begin(), foo.end(), is_odd);
// 13 9 4 28 54\end{lstlisting}

	\pause

	\begin{block}{Deux fonctions ?}
		\begin{itemize}
			\item Stabilité couteuse en temps et pas toujours nécessaire
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Partitionnement}
	\begin{itemize}
		\item \lstinline|std::nth_element()| réordonne les éléments :
		\begin{itemize}
			\item Élément sur l'itérateur pivot est celui qui serait à cette place si l'ensemble était trié
			\item Éléments avant ne sont pas supérieurs
			\item Éléments après ne sont pas inférieurs
			\item Pas d'ordre particulier au sein des deux sous-ensembles
		\end{itemize}
	\end{itemize}

\note[item]{Formulation \og pas supérieur\fg{} étrange mais gère le cas des égalités avec le pivot et la sémantique de l'opérateur fourni}

	\begin{lstlisting}[language=C++]
vector<int> foo{9, 8, 7, 6, 5, 4, 3, 2, 1};

nth_element(foo.begin(), foo.begin() + 3, foo.end());
// 2 1 3 4 5 9 6 7 8\end{lstlisting}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1DIApACYAQuYukl9ZATwDKjdAGFUtAK4sGe1wAyeAyYAHI%2BAEaYxCCSAKykAA6oCoRODB7evnrJqY4CQSHhLFEx8baY9vkMQgRMxASZPn5cFVXptfUEhWGR0bEJCnUNTdmtQ109xaUDAJS2qF7EyOwc5gDMwcjeWADUJutuTkPEmKwH2CYaAIIbWzuY%2B4cAbpgOJBdXt2abDNteewObjEwBIhAQLE%2BNy%2BE0cyF2EVQnl2eAUAH0MOgIMECCjZl8TAB2Kw3Xa7U4EJYMXbY8xxMz49YAEQOTK4BxJt0JLOhNxxuxYTGCEHx0OJXzJRM5ZLJQ3QIBAr3exCBOIuu34qCl0l2XHWpF2ZgAHAaAJy7A1xSRElnrTkSmVyhWJLppATUJEAOiiwGF8w1XtcIoNqIx6HQjOlMv4xAgqQAXpg0bi8E8mbsNByUU83AHUJ6E5gRVnrNY8KLrjL9uLSVXdk6UItcUCgXmTHELHh2%2BmW4ddmAOP21naHZLuaP6wR5Y2vM3Dq2B%2B23AxFyPazaCeua5XHVOFUqiCrDmr1tg28SdXqDcazRbdlaN2vbrXZXuQBMIvQ0S6Gm6GB78x9P0DU1T0g39UNMUjCcYzjPBE2TbNWQzLNU1bUDC2LO19ksMsKyrKUJ1fac0FnHN0KRdtO27ci%2BwHIcOQnDcX0nEim1o3NFziZdVyjZjnx3QiWIbA8PmPQR1U1KVTQNE1dkJA0ADZLQNHV9UNA12XHJ8JwbQQEDRSpMDYQQAO9TBfX/f1QKAqycIsXZ1NA8DoJY2DC0QtDmRQ7CvNzDD4KLSN7LwpjtzrViFVIuc3AorUOy7OIe3nOjB14sKeR3YiovY3tOLWbiV2HPjxzFTKOHmWhODiXg/A4LRSFQThYtwyx60WZZHg2HhSAITQKvmABrEA4g0fROEkWr%2BsazheAUEAxr6%2BqKtIOBYCQTBVDeWcSHISh6mABRlEMSohAQVAAHc6p6tAWESOgmGqY6QloM7Lrqhrbvu%2BgYmANBBGIJgHAAWgMKJaAUYGCGILwGEG0gvroaJQlYVZeERn6AHlZzeq7ps2t5rmIQ7ZtIAnkFqfA6t4fhBBEMR2CkGRBEUFR1GW0hdFaAwjBQUtLH0PAInm2BmDYEBERSAhSFeGJuEJGrZnmVBEmqeaOGBuVWVMVqLC4LhdmBgB1MRaENo3Nuhpg5o6lY9DlYJntO868e4XhocwVYeouwHEn6yrqqmjmmo4bAtuQHbiF2VQjUU4HFMkXY/vhCB/qthxdjByoFFmGkWqsAXdlwQgSBw9YuFmd3/fmBAziwGJg2G0bxo4SbSA%2B3gQ7mhbeurluzCDhqu975alZl6JUmcSQgA%3D}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Tri}
	\begin{itemize}
		\item \lstinline|std::sort()| trie un ensemble
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{4, 13, 28, 9 , 54};

sort(foo.begin(), foo.end());  // 4 9 13 28 54\end{lstlisting}

	\begin{alertblock}{Attention}
		\begin{itemize}
			\item Ordre relatif non conservé
		\end{itemize}

\note[item]{Utile si on test une partie des champs d'une structure par exemple}
	\end{alertblock}

	\begin{itemize}
		\item \lstinline|std::stable_sort()| trie l'ensemble en conservant l'ordre relatif
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Tri}
	\begin{itemize}
		\item \lstinline|std::partial_sort()| réordonne l'ensemble de manière à ce que les éléments situés avant un itérateur pivot soient les plus petits éléments de l'ensemble ordonnés par ordre croissant\ldots
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{9, 8, 7, 6, 5, 4, 3, 2, 1};

partial_sort(foo.begin(), foo.begin() + 3, foo.end());
// 1 2 3 9 8 7 6 5 4\end{lstlisting}

	\begin{itemize}
		\item \ldots{} les autres éléments n'ont pas d'ordre particulier
		\item \lstinline|std::partial_sort_copy()| copie l'ensemble ordonné à l'image de \lstinline|std::partial_sort()|
	\end{itemize}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:29,positionColumn:1,positionLineNumber:29,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%23include+%3Cvector%3E%0A%23include+%3Calgorithm%3E%0A%0Aint+main()%0A%7B%0A++%7B%0A++++std::vector%3Cint%3E+foo%7B4,+13,+28,+9+,+54%7D%3B%0A%0A++++std::sort(foo.begin(),+foo.end())%3B%0A++++for(size_t+i+%3D+0%3B+i+%3C+foo.size()%3B+%2B%2Bi)%0A++++%7B%0A++++++std::cout+%3C%3C+foo%5Bi%5D+%3C%3C+!'+!'%3B%0A++++%7D%0A++++std::cout+%3C%3C+!'%5Cn!'%3B%0A++%7D%0A%0A++%7B%0A++++std::vector%3Cint%3E+foo%7B9,+8,+7,+6,+5,+4,+3,+2,+1%7D%3B%0A%0A++++std::partial_sort(foo.begin(),+foo.begin()+%2B+3,+foo.end())%3B%0A++++for(size_t+i+%3D+0%3B+i+%3C+foo.size()%3B+%2B%2Bi)%0A++++%7B%0A++++++std::cout+%3C%3C+foo%5Bi%5D+%3C%3C+!'+!'%3B%0A++++%7D%0A++++std::cout+%3C%3C+!'%5Cn!'%3B%0A++%7D%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Mélange}
	\begin{itemize}
		\item \lstinline|std::random_shuffle()| réordonne aléatoirement l'ensemble
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{9, 8, 7, 6, 5, 4, 3, 2, 1};

random_shuffle(foo.begin(), foo.end());
// 1 8 3 7 9 4 2 6 5
// ou ...\end{lstlisting}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:15,positionColumn:1,positionLineNumber:15,selectionStartColumn:1,selectionStartLineNumber:15,startColumn:1,startLineNumber:15),source:'%23include+%3Ciostream%3E%0A%23include+%3Cvector%3E%0A%23include+%3Calgorithm%3E%0A%0Aint+main()%0A%7B%0A++std::vector%3Cint%3E+foo%7B9,+8,+7,+6,+5,+4,+3,+2,+1%7D%3B%0A%0A++std::random_shuffle(foo.begin(),+foo.end())%3B%0A++for(size_t+i+%3D+0%3B+i+%3C+foo.size()%3B+%2B%2Bi)%0A++%7B%0A++++std::cout+%3C%3C+foo%5Bi%5D+%3C%3C+!'+!'%3B%0A++%7D%0A++std::cout+%3C%3C+!'%5Cn!'%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Fusion}
	\begin{itemize}
		\item \lstinline|std::merge()| fusionne deux ensembles triés dans un troisième
	\end{itemize}

\note[item]{Ce troisième ensemble est bien entendu trié lui aussi}

	\begin{lstlisting}[language=C++]
vector<int> foo{1, 5, 6, 8};
vector<int> bar{2, 5};
vector<int> baz;

merge(foo.begin(), foo.end(), 
      bar.begin(), bar.end(), 
      back_inserter(baz));
// 1 2 5 5 6 8\end{lstlisting}

	\begin{itemize}
		\item \lstinline|std::inplace_merge()| fusionne deux sous-ensembles "sur place"
	\end{itemize}

\note[item]{En fait il fusionne le début trié d'un ensemble avec le reste trié de ce même ensemble dans l'ensemble en question}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1DIApACYAQuYukl9ZATwDKjdAGFUtAK4sGe1wAyeAyYAHI%2BAEaYxCAAzFykAA6oCoRODB7evnrJqY4CQSHhLFEx8baY9vkMQgRMxASZPn4JdpgO6bX1BIVhkdF6CnUNTdmtwz3BfSUDXACUtqhexMjsHOaxwcjeWADUJrFuTkPEmKwH2CYaAIIbWzuY%2B4cAbu1ExBdXt2abDNteewObjEwBIhAQLE%2BNy%2BwQIuxYTGCEDmXxMAHYrDddvsMV9sdihugQCBXg4SEDYRddvxUOiLAldgBWUi7ABsLIAHOiACIHTHXfG7QnE0nvCmCKkRep0swsxk8vl4/HCklvcmHSmxbC7KUAL0V0KxyoIRJAbGIwEw1FQqAAdFFgEiFtSbbbXMiWVLiPbMI6GB6dfU3Qx0AGVVLkABrAD6wSUDWiED1cxRsX5gv4xAgqV1mGjcLwT25uw0fN2haBgd1tpzVtTFn2lmseBRRuxdKVgpVaC8cKBlb1JkZFjwQ%2BL/cOuzAHCn6zTnZxvLbQpNxJ7fcOlenQ7cDG386NCsNApx6eNptF6qOEq1LtpGIZzLZnJZsqZCoPt2XKuCiQMq2jc1LWtO0HSdFkaR9P1kUbBtpDvYNQxTA0T2xTNszwXN83LIsSzLCtJ0g2tkTLaxm1bVDTwXAlVxQJYNzcSsaSHEcxyeRjJ2nWcUMFI9KO7ej2K3dZGV3fczz4viOAWWhOEZXg/A4LRSFQThGKbSwhSWFZHg2HhSAITRpIWSMQEZDR9E4SQFKMlTOF4BQQAswylOk0g4FgJBMFUdpexIchKHqYAFGUQxKiEBBUAAd0U/S0BYRI6CYapQpCWgIuixTlPixL6BiYAuDMWUcroaJQlYNZeBKvKAHlewymLbO89prgtRyOF4ZrkFqfBFN4fhBBEMR2CkGRBEUFR1Fc0hdASAwjBQMjLH0PAIkc2BmDYEAIhtIZSFeGJuDReSUxUxJqnagBaQkDm5UwNPpLhdkugB1MRaGel7vIIYgmAc7TVkGE1glS8LIsa7heB%2BzA1n0qLfsSIyZLkmzptUjhsB85A/OIXZVA5VlLtZSRdmAZBkF2QrbTMXYIHUqxlt2XBCBIRt4jmKGkYWBAziwGIPVM8zLI4azSCy3h0YcpyDK54WzFR5TJZl1zToO1JnEkIA%3D%3D%3D}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Opérations ensemblistes}
	\begin{alertblock}{Attention}
		\begin{itemize}
			\item Ensemble sans répétition de valeur
			\item Uniquement des ensembles triés
		\end{itemize}
	\end{alertblock}
		
	\begin{itemize}
		\item \lstinline|std::includes()| vérifie si tous les éléments sont présents dans un autre ensemble
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{1, 5, 6, 8};
vector<int> bar{2, 5};
vector<int> baz{1, 6};

includes(foo.begin(), foo.end(), 
         bar.begin(), bar.end());   // faux
includes(foo.begin(), foo.end(), 
         baz.begin(), baz.end());   // vrai\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Opérations ensemblistes}
	\begin{itemize}
		\item \lstinline|std::set_union()| : union de deux ensembles
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{1, 5, 6, 8};
vector<int> bar{2, 5};
vector<int> baz;

set_union(foo.begin(), foo.end(), bar.begin(),
          bar.end(), back_inserter(baz));
// 1 2 5 6 8\end{lstlisting}

	\begin{itemize}
		\item \lstinline|std::set_intersection()| : intersection de deux ensembles
		\item \lstinline|std::set_difference()| : différence de deux ensembles
		\item \lstinline|std::set_symmetric_difference()| : différence symétrique de deux ensembles

\note[item]{\lstinline|set_difference()| conserve les éléments présents dans le premier ensemble mais pas dans le second alors que \lstinline|set_symmetric_difference()| conserve les éléments présents dans un des ensembles mais pas dans l'autre}
	\end{itemize}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1DIApACYAQuYukl9ZATwDKjdAGFUtAK4sGe1wAyeAyYAHI%2BAEaYxCAAbAAcpAAOqAqETgwe3r56KWmOAkEh4SxRMQm2mPYFDEIETMQEWT5%2BXJXVGXUNBEVhkdF6CvWNzTltQ929JWUSAJS2qF7EyOwc5gDMwcjeWADUJutuTkPEmKwH2CYaAIIbWzuY%2B4cAbpgOJBdXt2abDNteewObjEwBIhAQLE%2BNy%2BwQIuxYTGCEFmXxMAHYrDddvsMV9sdihugQCBXu9iEDYRddvxUOiLG1dgBWUi7WIs%2BLogAiB0x13xu0JxNJRHJh0p62wuwiDTpZhZjK5PLx%2BMFJLeIopgip0oAXnSGbFFetecqCQQiShFnCgUCBebiRFUJ4xEkEEwnm5bar7gDMApqE6AHRRYBI%2BbUoOuZEs6XEYOYUMMaNShqBqOzWYe21gNaMtwMHNKrEq%2B2WrzWw5e0uO520V3um2HO0Wn1Yf00%2BOJ5Md9Mxpg6zthvsD9OZxtuXaFvMFtbG5WK6HFumm5tC9UfMVaiUR2kYhnM1nso28/mq4Ubo5byWx2Xy48rs/r0WXgja/tF27Fs0WpQEAD6XgMBkAaoIOSbhj2DDoMmsZgTBqa9imyAANZ/sESiNNEEC6hmH78vwxAQGkOqYH%2BcJ4E8nK7BoPK7BRtq6oGxGYMitHWNYeAol%2BOInvyq5lhWnpNrqJiMhYeCiVR46ThwMl4fiC58iWFpoOWWZNlO%2BaFnOS5otyi5Kcu3GPmSmqvtuNL6vKLJsrsHJ6fJ35rqZm7mdeMoYnKTL3sZpbns%2B4ruXqOmfkpTkgL%2BaGCNESgOMBHYhkOO5plB8Fxol4F9nGiHSihUUYQQWE4SiIX4SQRF4CRZF0ZR1G0fRwn9kxlUsSVFj7JYHFcWFPEruFqmCQx75iRJjJSZWGmydpvHYopp6lgN6kTppM7yYp864r5Fr%2BWZVKWXu1mHnZPk9SZGquW%2B5KeXeDmlcpznnS%2Bb7BSaW3EpF%2BBUFQ0SMCsIFwRBkapeGsEZWlKXQSDTB5eh0SFYRxWORGhHMdVDVUTRxo1UNA7MaxWPsZYnErkZPX9VaS0pnqI2SZTOZyXds0OW9Al07mWmzrx626TN/E7RdFlOlZTI2Uet282dF6BSmV0WF5Criw%2BflPrt24iSFSs/pg/4KAAniwbAEMQeDIH%2Bn3facfwsQlCZJZBkNZQDjs5dDqGw5hCP9rhjPIxVVXkbVmPtQ1E6MXjbUdVYRPdfypN8fxi3SSJNNjWzDO83N92s9JK3TRt%2Bm3Mz1wcPMtCcIyvB%2BBwWikKgnCep1lgCosyyPBsPCkAQmgl/MyEgIyGj6JwkiV93tecLwCggIPXfVyXpBwLASCYKobzliQ5CUA0wAKMohhVEICCoAA7lXHdoCwSR0EwNR7yEtCHyfVc1xfV/0DEwBcGYcqv3Q0ShKwVYvBf7vwAPLlkfqfMeK83jXGIDvCepAYHIDqPgKuvB%2BCCBEGIdgUgZCCEUCodQc9SC6DaAYIwKBCY2FoHgCIU9YDMDYCAGsQxSCvBiNwNEFcMy1ySDUKeHAAC0hIDiclMI3ekXBdhCIAOpiFoDI2RK8jZMEni3FYgxzTBDvgfI%2BUDuC8CNpgVYHdj7ECYEkbupdy6jxIXXDg2BV7IHXsQXYqh4ixCEbESQuxgDIGQLsL%2BgYzC7AgA3KONhdi4EICQDq6wuCzCMdY%2BYCAzhYBiNGPuA8h4cBHqQZ%2BvAHGT2np3FJuSzB2JrsUspc9eEcLSM4SQQA%3D}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Gestion de tas}
	\begin{block}{Tas}
		\begin{itemize}
			\item Structure permettant la récupération de l'élément de plus grande valeur
		\end{itemize}
	\end{block}
	
	\begin{itemize}
		\item \lstinline|std::make_heap()| forme un tas depuis un ensemble
		\item \lstinline|std::pop_heap()| déplace l'élément de plus haute valeur en fin d'ensemble
		\item \lstinline|std::push_heap()| ajoute l'élément en fin d'ensemble au tas
	\end{itemize}

	\begin{block}{Structure de tas}
		\begin{itemize}
			\item \lstinline|std::pop_heap()| et \lstinline|std::push_heap()| maintiennent la structure de tas
		\end{itemize}
	\end{block}

	\begin{itemize}
		\item \lstinline|std::sort_heap()| tri le tas
	\end{itemize}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:27,positionColumn:1,positionLineNumber:27,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%23include+%3Cvector%3E%0A%23include+%3Calgorithm%3E%0A%0Aint+main()%0A%7B%0A++std::vector%3Cint%3E+foo%7B10,20,30,5,15%7D%3B%0A%0A++std::make_heap(foo.begin(),+foo.end())%3B%0A++std::cout+%3C%3C+foo.front()+%3C%3C+!'%5Cn!'%3B%0A%0A++std::pop_heap(foo.begin(),+foo.end())%3B%0A++foo.pop_back()%3B%0A++std::cout+%3C%3C+foo.front()+%3C%3C+!'%5Cn!'%3B%0A%0A++foo.push_back(99)%3B%0A++std::push_heap(foo.begin(),+foo.end())%3B%0A++std::cout+%3C%3C+foo.front()+%3C%3C+!'%5Cn!'%3B%0A%0A++std::sort_heap(foo.begin(),+foo.end())%3B%0A++for(size_t+i+%3D+0%3B+i+%3C+foo.size()%3B+%2B%2Bi)%0A++%7B%0A++++std::cout+%3C%3C+foo%5Bi%5D+%3C%3C+!'+!'%3B%0A++%7D%0A++std::cout+%3C%3C+!'%5Cn!'%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Min-max}

\note[item]{Possibilité de fournir la fonction de comparaison (\lstinline|operator<| par défaut)}

	\begin{itemize}
		\item \lstinline|std::min()| détermine le minimum de deux éléments
		\item \lstinline|std::max()| détermine le maximum de deux éléments
	\end{itemize}

	\begin{lstlisting}[language=C++]
min(52, 6);  // 6
max(52, 6);  // 52\end{lstlisting}

	\begin{itemize}
		\item \lstinline|std::min_element()| détermine le plus petit élément d'un ensemble
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{18, 5, 6, 8};
min_element(foo.begin(), foo.end()); // Sur 5 \end{lstlisting}

	\begin{itemize}
		\item \lstinline|std::max_element()| détermine le plus grand élément d'un ensemble
	\end{itemize}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:10,positionColumn:1,positionLineNumber:10,selectionStartColumn:1,selectionStartLineNumber:10,startColumn:1,startLineNumber:10),source:'%23include+%3Ciostream%3E%0A%23include+%3Cvector%3E%0A%23include+%3Calgorithm%3E%0A%0Aint+main()%0A%7B%0A++std::vector%3Cint%3E+foo%7B18,+5,+6,+8%7D%3B%0A%0A++std::cout+%3C%3C+*std::min_element(foo.begin(),+foo.end())+%3C%3C+%22%5Cn%22%3B%0A++std::cout+%3C%3C+*std::max_element(foo.begin(),+foo.end())+%3C%3C+%22%5Cn%22%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Numérique}
	\begin{itemize}
		\item \lstinline|std::accumulate()| \og ajoute\fg{} tous les éléments de l'ensemble
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{18, 5, 6, 8};

accumulate(foo.begin(), foo.end(), 1, multiplies<int>());
// 4320 \end{lstlisting}

	\begin{itemize}
		\item Opérateur et valeur initiale configurables
		\item \textit{Reduce/fold} fonctionnel
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Numérique}
	\begin{itemize}
		\item \lstinline|std::adjacent_difference()| \og différence\fg{} entre chaque élément et son prédécesseur
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{18, 5, 6, 8};
vector<int> bar;

adjacent_difference(foo.begin(), foo.end(), 
                    back_inserter(bar), minus<int>());
// 18 -13 1 2\end{lstlisting}

	\begin{itemize}
		\item Opérateur configurable
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Numérique}
	\begin{itemize}
		\item \lstinline|std::inner_product()| \og produit scalaire\fg{} de deux ensembles
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{1, 2, 3, 4};
vector<int> bar{2, 3, 4, 5};

inner_product(foo.begin(), foo.end(), bar.begin(), 0);
// 40\end{lstlisting}

	\begin{itemize}
		\item Opérateurs et valeur configurables
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Numérique}
	\begin{itemize}
		\item \lstinline|std::partial_sum()| \og somme\fg{} partielle d'un ensemble
		\item Chaque élément résultant est la somme des éléments d'indice inférieur ou égal de l'ensemble de départ
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{1, 2, 3, 4};
vector<int> bar;

partial_sum(foo.begin(), foo.end(), back_inserter(bar));
// 1 3 6 10\end{lstlisting}

	\begin{itemize}
		\item Opérateur configurable
	\end{itemize}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1DIApACYAQuYukl9ZATwDKjdAGFUtAK4sGe1wAyeAyYAHI%2BAEaYxCAArAAcpAAOqAqETgwe3r56KWmOAkEh4SxRMQm2mPYFDEIETMQEWT5%2BXJXVGXUNBEVhkdF6CvWNzTltQ929JWUSAJS2qF7EyOwc5gDMwcjeWADUJutuTkPEmKwH2CYaAIIbWzuY%2B4cAbpgOJBdXt2abDNteewObgYPmieFM60uNy%2BwQIuxYTGCEFmXxMAHYrDddvsMV9sdihugQCBXu9iEDYRddvxUOiLFxErtYqRdgA2FnxdEAEQOmOu%2BN2hOJaC8cKBQMFBCJICYyGQPi8BgImGoqFQADoosAkfNqWr1a5kSy2pLpSxFY4krQ8JgFBTBBdkbMnm4JWA1rFge7eXicTzoVicXyBUKSW8iOTDpTIXraRiGSzmWyOdyfYGCVLiaSI/aCFSIg007d06biUx0NpZYwCAB9fBUKjRRgrVUarU6lk0g0MdBG3YF5AAaxrwSUjWiEALxF1oZYwS8dqjDshTqLAv4xAgaQAXpga3C8E8ubsNLzdoeJVP1TuVSj1hZ9pZrHgUSW6b6Q5mUIsxYdL4XYgsPATFiY9xUOXZ3UgtZ7w/P04NDEVf1dCDvU9BhvVgwNUwDfkgwQr9sw%2BJc8xjGk6RNMwWXWFlJFTLC8IzaUiMjI5l2wftCwxKjdho3ZpCZei%2BQI6UkJdCVQ2CEJiBrJJiAwLwHFbTVMG1Bg%2By7Q1dSvdt1N1DRnXAtxoJAr0YODeDcOxd8S1DFjcypcj4xZHi%2BLotEeQYz9mPDYi2NIjipyLETiSSbo8DEGsFB8ZTdI0/UtJZAdh1HaJlU3KdZjvCzsQ3Lc8F3fdzyPE8zwvCCrxvZEz2sZ9X0Y/CSyY4Uf3EiqAKAkCwL/VCOBMrz8RwhrENaoyTPQzCLKG1EfjwKhSsDAB6RbdgAMVlCMbVoehfRs4bCN81jow4pz6Rc6jaKEkKwzJByYyChjrrCxoItoKKYq7OLdU0ns%2B2SkcGDHdLJwaGcv3NWhLWtW07uwVcBtykh8sKg8StPe9iv/YhrwK28aqfSwXzgvaBWa79RTa4ygsA4DQMp6D%2Bpyyz9tE0aeuMtCzLXZmNlcObUQ8r4OHmWhOFiXg/A4LRSFQThXQJh8FEWZZHg2HhSAITRhfmQc4g0fROEkCWtZlzheAUEB9c1qXhdIOBYCQTBVDeUUSHISgGmABRlEMKohAQVAAHdJfVtAWCSOgmBqH2Qlof2g8l6Ww4j%2BgYmALgzCo5O6GiUJWFWXhs9TgB5UV4%2BDk2nbea5iC9s3SCr5A6nwSXeH4QQRDEdgpBkQRFBUdQbdIXQ2gMIwUFqyx9DwCILdgZg2BACI1SGUhXhibg0XFrKZaSGoLY4ABaQkDi5UwFa4LhdkPgB1MRaGvm%2BnYIYgmHN5WVkGKVghjv2A4r7gvAX6YFWOrQOr8khaxFmLY2Q9ZYcGwM7eUEZdiqHiKyQ%2BrJJC7GAHKXYGd1RmF2BAeWVgp67FwIQEgj51hcFmEAqB8wEBnCwDEI0utYj61FhwI2pBE68HgebS2GtGEGw4GYWB0tBEiJtjvdeaRnCSCAA%3D%3D}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}
	\frametitle{STL Algorithmes - Au delà des conteneurs}
	\begin{itemize}
		\item Itérateurs définissables hors des conteneurs
		\begin{itemize}
			\item Abstraction du parcours
			\item Sémantique de pointeurs
		\end{itemize}
		\item Algorithmes indépendants du conteneur
		\item Utilisables sur d'autres ensembles de données
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Au delà des conteneurs}
	\begin{itemize}
		\item Tableaux C
		\begin{itemize}
			\item Pas un conteneur

\note[item]{Il contient mais est très différent des conteneurs classiques : frustre, minimaliste, rudimentaire, pas de réelle sémantique, peu d'intelligence}

			\begin{itemize}
				\item Sémantique : Tableau ou pointeur ? Statique ou dynamique ?
				\item Service : Taille ? Copie ?
			\end{itemize}
			\item Simple pointeur comme itérateur
			\begin{itemize}
				\item Début : adresse du premier élément
				\item Fin : adresse suivant le dernier élément
			\end{itemize}
		\end{itemize}
	\end{itemize}

	\begin{lstlisting}[language=C++]
int foo[4];

fill(foo, foo + 4, 5);  // 5 5 5 5\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{STL Algorithmes - Au delà des conteneurs}
	\begin{itemize}
		\item Flux
		\begin{itemize}
			\item \lstinline|istream_iterator| : \textit{input} itérateur
			\begin{itemize}
				\item Début : depuis un flux entrant
				\item Fin : constructeur par défaut
			\end{itemize}
			\item \lstinline|ostream_iterator| : \textit{output} itérateur
			\begin{itemize}
				\item Depuis un flux sortant, séparateur configurable
			\end{itemize}
		\end{itemize}
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{5, 6, 12, 89};
ostream_iterator<int> out_it (cout, ", ");

copy(foo.begin(), foo.end(), out_it); // 5, 6, 12, 89,\end{lstlisting}

	\begin{alertblock}{Attention}
		\begin{itemize}
			\item Séparateur ajouté après chaque élément, y compris le dernier
		\end{itemize}
	\end{alertblock}

	\begin{itemize}
		\item Buffers de flux : \lstinline|istreambuf_iterator| et \lstinline|ostreambuf_iterator|
	\end{itemize}

	\hfill \href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:13,positionColumn:1,positionLineNumber:13,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%23include+%3Citerator%3E%0A%23include+%3Cvector%3E%0A%23include+%3Calgorithm%3E%0A%0Aint+main()%0A%7B%0A++std::vector%3Cint%3E+foo%7B5,+6,+12,+89%7D%3B%0A++std::ostream_iterator%3Cint%3E+out_it+(std::cout,+%22,+%22)%3B%0A%0A++std::copy(foo.begin(),+foo.end(),+out_it)%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\subsection*{STL - Conclusion}
\begin{frame}
	\frametitle{STL Conclusion}
	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Préférez les conteneurs aux tableaux C
		\end{itemize}
	\end{exampleblock}

	\begin{alertblock}{Attention}
		\begin{itemize}
			\item \lstinline|operator[]| ne vérifie pas les bornes
		\end{itemize}

\note[item]{Une implémentation peut mettre une assertion dessus et produire une erreur à l'exécution en debug, p.ex. sur les TU. Et une implémentation de qualité devrait le faire}
	\end{alertblock}

	\begin{alertblock}{Don't}
		\begin{itemize}
			\item N'utilisez pas d'itérateur invalidé
		\end{itemize}

\note[item]{Certaines opérations, par exemple l'ajout dans un vecteur, peuvent invalider les itérateurs sur le conteneur}
	\end{alertblock}

	\begin{alertblock}{Attention}
		\begin{itemize}
			\item Pas objets polymorphiques dans les conteneurs
			\item Ou via des pointeurs intelligents
		\end{itemize}
	\end{alertblock}
\end{frame}

\begin{frame}
	\frametitle{STL Conclusion}
	\begin{exampleblock}{Do, performances}
		\begin{itemize}
			\item Mesurez !
		\end{itemize}
	\end{exampleblock}

	\begin{block}{Conseils, performances}
		\begin{itemize}
			\item Réfléchissez à votre utilisation des données

\note[item]{Utilisation des données : zone critique/non critique, découpage d'algorithmes, données particulières (triées, lourdes à copier), compromis temps/mémoire, stabilité (tri), mise en cache, \ldots}
\note[item]{La première interrogation étant : ce traitement est-il nécessaire ?}

			\item Méfiez-vous des complexités brutes

\note[item]{La complexité n'est pas ou peu significative pour de petits volumes de données, p.ex. les tris par insertion ou sélection (O($n^{2}$)) plus efficaces que des tris en O($n\ln n$)}
\note[item]{Les complexités moyennes ne sont pas pertinentes pour des données particuliers, p.ex. tri par insertion efficace sur ensembles presque triés, peu de permutation du tri par sélection donc efficace pour des données lourdes à déplacer}
		\end{itemize}
	\end{block}

	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Préférez les algorithmes standard aux algorithmes tierces et \og maisons\fg{}
		\end{itemize}

\note[item]{Exception à l'usage d'algorithmes standard : exception inopportune et initialisation à zéro}
	\end{exampleblock}

	\begin{block}{Bémol, performance}
		\begin{itemize}
			\item Algorithmes standard généralement très bons
			\item Mais pas forcément optimaux dans une situation particulière

\note[item]{Prix de leur généricité}
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}
	\frametitle{STL Conclusion}
	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Faites vos propres algorithmes plutôt que des boucles
			\item Faites des algorithmes génériques et compatibles
		\end{itemize}
	\end{exampleblock}

	\begin{exampleblock}{Do, sémantique}
		\begin{itemize}
			\item Le bon algorithme pour la bonne opération
			\item Définissez la sémantique de vos algorithmes et choisissez un nom explicite
		\end{itemize}
	\end{exampleblock}

	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Préférez les prédicats \og purs\fg{}
		\end{itemize}
	\end{exampleblock}
\end{frame}

\begin{frame}
	\frametitle{STL Conclusion}
	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Vérifiez que les ensembles de destination aient une taille suffisante
		\end{itemize}
	\end{exampleblock}

	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Vérifiez les pré-conditions des algorithmes (p.ex. ensemble trié)
			\item Vérifiez le type d'itérateur requis
			\item Vérifiez les complexités garanties
		\end{itemize}
	\end{exampleblock}

	\begin{block}{Aller plus loin}
		\begin{itemize}
			\item Voir \href{https://github.com/CppCon/CppCon2016/blob/master/Presentations/STL\%20Algorithms/STL\%20Algorithms\%20-\%20Marshall\%20Clow\%20-\%20CppCon\%202016.pdf}{STL Algorithms (Marshall Clow)}
		\end{itemize}

\note[item]{Conf cppcon 2016 sur les algorithmes en général et sur comment faire ces propres algorithmes}
	\end{block}
\end{frame}
\end{document}