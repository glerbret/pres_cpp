\documentclass[C++.tex]{subfiles}
\begin{document}

\section{C++11}
\subsection*{Présentation}
\begin{frame}
	\frametitle{Présentation}
	\begin{itemize}
		\item Approuvé le 12 août 2011
		\item Dernier \textit{Working Draft} : \href{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf}{N3337}
		\item Standardisation laborieuse
		\begin{itemize}
			\item Sortie tardive (C++0x)
			\item Périmètre initial trop ambitieux (retrait des concepts en 2009)
		\end{itemize}
		\item Changement de fonctionnement du comité
		\begin{itemize}
			\item Utilisation de \textit{Technical Specification} et de groupes de travail dédiés
			\item Pilotage par les dates plutôt que les fonctionnalités (\textit{train model})
			\item Des versions fréquentes (3 ans : 2011, 2014, 2017, 2020, \ldots)
			\item Voir \href{https://herbsutter.com/2016/03/11/trip-report-winter-iso-c-standards-meeting/}{Trip report: Winter ISO C++ standards meeting}
		\end{itemize}
		\item Support quasi-complet par GCC, Clang et Visual C++

\note[item]{La seule fonctionnalité non supportée par GCC, Clang et Visual C++ est le \og support minimal pour les GC\fg{} qui n'est supporté par personne et disparait en C++23}

		\item Objectifs : plus sûr, plus simple, aussi rapide que possible, meilleure détection d'erreur en \textit{compile-time}

\note[item]{Pas complet, je laisse de côté \lstinline|system_error|, \lstinline|codecvt|, \lstinline|typeindex| et deux-trois nouvelles fonctions dans la bibliothèque standard}
	\end{itemize}
\end{frame}

\subsection*{Dépréciations et suppressions}
\begin{frame}[fragile]
	\frametitle{Dépréciations et suppressions}
	\begin{itemize}
		\item Dépréciation de \lstinline|register|

\note[item]{\lstinline|register| est supprimé en C++17}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Suppression des export templates}
	\begin{itemize}
		\item Suppression des \textit{export templates}
		\item \lstinline|export| reste un mot-clé réservé
	\end{itemize}

	\begin{block}{\lstinline|export| et compatibilité}
		\begin{itemize}
			\item Rupture de comptabilité ascendante
			\item Implémenté sur un unique compilateur et inutilisé en pratique
		\end{itemize}

\note[item]{Un seul front end EDG, utilisé par deux compilateurs (Comeau et ICC) mais la fonctionnalité n'était pas active chez Intel}
\note[item]{Suppression soutenue par l'équipe d'EDG}
	\end{block}

	\begin{block}{Motivations}
		\begin{itemize}
			\item Voir \href{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1426.pdf}{N1426}
		\end{itemize}

\note[item]{En gros les motivations sont : peu utile, peu demandé, compliqué à implémenter et compliqué à utiliser}
	\end{block}
\end{frame}

\subsection*{Nouveaux types}
\begin{frame}[fragile]
	\frametitle{Nouveaux types entiers}
	\begin{itemize}
		\item Hérités de C99 (\lstinline[keywordstyle=\color{black}]|cstdint| et \lstinline|cinttypes|)
	\end{itemize}

	\begin{block}{Depuis C99}
	\begin{itemize}
		\item Ainsi que \textit{variadic macro}, \lstinline|__func__|, concaténation de chaînes littérales, \ldots
	\end{itemize}
	\end{block}

	\begin{itemize}
		\item \lstinline|long long int| et \lstinline|unsigned long long int|
		\begin{itemize}
			\item Au moins aussi grand que \lstinline|long int|
			\item Plages garanties : [$-(2^{63}-1)$, $2^{63}-1$] et [$0$, $2^{64}$]
			\item Extension de nombreux compilateurs bien avant C++11
		\end{itemize}
		\item \lstinline|intmax_t| et \lstinline|uintmax_t| : types entiers le plus grand disponibles
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Nouveaux types entiers}
	\begin{itemize}
		\item \lstinline|int<N>_t|, \lstinline|uint<N>_t| : entiers de N bits
		\begin{itemize}
			\item N = 8, 16, 32 ou 64
			\item \lstinline|int<N>_t| obligatoirement en complément à 2

\note[item]{En C++, pas de contrainte sur les autres types entiers signés avant C++20}
\note[item]{En C (avant C23), d'autres représentations possibles : signe + valeur (avec deux codages de 0, algorithme d'addition/ multiplication non canonique) et complément à 1 où chaque bit du positif est inversé pour donner le négatif, là encore deux valeurs de 0}
\note[item]{Complément à 2 : inversion de chaque bit (complément à 1) puis ajout de 1}

			\item Pas de bit de \textit{padding}
			\item Optionnels
		\end{itemize}
		\item \lstinline|int_least<N>_t|, \lstinline|uint_least<N>_t| : plus petits entiers d'au moins N bits
		\item \lstinline|int_fast<N>_t|, \lstinline|uint_fast<N>_t| : plus rapides entiers d'au moins N bits
		\item \lstinline|intptr_t| et \lstinline|uintptr_t| : entier capable de contenir une adresse
		\begin{itemize}
			\item Doit pouvoir être reconvertit en \lstinline|void*| avec une valeur égale au pointeur original
			\item Optionnels
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Nouveaux types entiers}
	\begin{itemize}
		\item Macros de définition des plages correspondantes
		\item Macros de construction depuis des entiers \og classiques\fg{}
		\item Macros des spécificateurs pour \lstinline|printf| et \lstinline|scanf|
		\item Fonctions de manipulation de \lstinline|intmax_t| et \lstinline|uintmax_t| (\lstinline|imaxabs|, \lstinline|imaxdiv|, \lstinline|strtoimax|, \lstinline|strtoumax|, \lstinline|wcstrtoimax| et \lstinline|wcstrtoumax|)
		\item Surcharges de \lstinline|abs| et \lstinline|div| pour \lstinline|intmax_t| si nécessaire
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{POD Généralisé - Rappels}
	\begin{itemize}
		\item Types POD (\textit{Plain Old Data}) : classes et structures POD, unions POD, types scalaires et tableaux de ces types
		\item Certaines constructions ne sont permises que pour les types POD

\note[item]{Permises \textbf{uniquement} sur les POD vue de la norme tout du moins. En pratique, certaines opérations peuvent fonctionner sur des types non-POD sur une implémentation particulière}

		\begin{itemize}
			\item Utilisation de \lstinline|memcpy()| ou \lstinline|memmove()|
			\item Utilisation de \lstinline|goto| au-delà de la déclaration d'une variable

\note[item]{C'est à dire depuis un point où la variable n'est pas dans le scope vers un point où la variable est déjà dans le scope}

			\item Utilisation de \lstinline|reinterpret_cast|
			\item Accès au début commun d'une union par un membre non actif
			\item Utilisation des fonctions C \lstinline|qsort()| ou \lstinline|bsearch()|
			\item \ldots
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{POD Généralisé - Classe agrégat}
	\begin{itemize}
		\item C++98
		\begin{itemize}
			\item Pas de constructeur déclaré par l'utilisateur
			\item Pas de donnée membre non-statique privée ou protégée
			\item Pas de classe de base
			\item Pas de fonction virtuelle
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{POD Généralisé - Classe agrégat}
	\begin{itemize}
		\item C++11
		\begin{itemize}
			\item Pas de constructeur \underline{fourni} par l'utilisateur

\note[item]{Les constructeurs déclarés \lstinline|=default| par l'utilisateur sont autorisés}

			\item Pas d'initialisation \textit{brace-or-equal-initializers} des données membres non-statiques
			\item Pas de donnée membre non-statique privée ou protégée
			\item Pas de classe de base
			\item Pas de fonction virtuelle
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{POD Généralisé - Classe POD C++98}
	\begin{itemize}
		\item Classe agrégat
		\item Sans donnée membre non-statique de type non-POD
		\item Sans référence
		\item Sans opérateur d'assignation défini par l'utilisateur
		\item Sans destructeur défini par l'utilisateur
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{POD Généralisé - Classe POD C++11}
	\begin{itemize}
		\item Contraintes réparties en trois sous-notions
		\item \textit{trivially copyable}
		\begin{itemize}
			\item Pas de constructeur de copie ou de déplacement non triviaux
			\item Pas d'opérateur d'affectation non trivial
			\item Destructeur trivial
		\end{itemize}
	\end{itemize}

	\pause

	\begin{block}{Trivial}
		\begin{itemize}
			\item Pas fournie par l'utilisateur
			\item Pas de fonction virtuelle ni de classe de base virtuelle
			\item Opération des classes de bases et des membres non-statiques est triviale
		\end{itemize}
	\end{block}

	\pause

	\begin{block}{Autre formulation}
		\begin{itemize}
			\item Copie, déplacement, affectation et destruction générés implicitement
			\item Pas de fonction ni de classe de base virtuelle
			\item Classes de base et membres non-statiques \textit{trivially copyable}
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{POD Généralisé - Classe POD C++11}
	\begin{itemize}
		\item \textit{trivial}
		\begin{itemize}
			\item \textit{trivially copyable}
			\item Constructeur par défaut trivial
			\begin{itemize}
				\item Pas fourni par l'utilisateur
				\item Pas de fonction virtuelle ni de classe de base virtuelle
				\item Constructeur par défaut des classes de base et des membres non-statiques trivial
				\item Pas d'initialisation \textit{brace-or-equal-initializers} des données membres non-statiques
			\end{itemize}
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{POD Généralisé - Classe POD C++11}
	\begin{itemize}
		\item \textit{Standard-layout}
		\begin{itemize}
			\item Pas de donnée membre non-statique non-\textit{Standard-layout} 
			\item Pas de référence
			\item Pas de classe de base non-\textit{Standard-layout}
			\item Pas de fonction virtuelle 
			\item Pas de classe de base virtuelle
			\item Même accessibilité de toutes les données membres non-statique
			\item Données membres non-statiques dans une unique classe de l'arbre d'héritage

\note[item]{Formellement : pas de données membres non-statiques dans la classe la plus dérivée et au plus une classe de base avec des données membres non-statiques ou pas de classe de base avec des données membres non-statiques}

			\item Pas de classe de base du type de la première donnée membre non-statique
		\end{itemize}
	\end{itemize}

	\pause

	\begin{block}{En résumé}
		\begin{itemize}
			\item Organisation mémoire similaire aux structures C
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{POD Généralisé - Classe POD C++11}
	\begin{itemize}
		\item POD
		\begin{itemize}
			\item \textit{trivial}
			\item \textit{standard layout}
			\item Pas de donnée membre non-statique non-POD
		\end{itemize}
		\item Ajout des traits correspondants : \lstinline|std::is_trivial|, \lstinline|std::is_trivially_copyable| et \lstinline|std::is_standard_layout|
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{POD Généralisé - Objectifs}
	\begin{itemize}
		\item Opérations POD deviennent accessibles à la sous-notion correspondante
		\item Relâchement et adaptation de certaines contraintes
		\begin{itemize}
			\item Constructeurs ou destructeurs déclarés \lstinline|=default| autorisés
			\item Données membres non-statiques plus nécessairement publiques

\note[item]{Mais doivent toutes avoir la même portée, car en C++, le compilateur peut réordonner les données de portées différentes}

			\item Classes de base non virtuelles autorisées

\note[item]{A condition de respecter les contraintes de type et de localité des données membre}
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{POD Généralisé - Conséquences}
	\begin{itemize}
		\item \textit{standard layout}
		\begin{itemize}
			\item Utilisation de \lstinline|reinterpret_cast|
			\item Utilisation de \lstinline|offsetof|
			\item Accès au début commun d'une union par un membre non actif
		\end{itemize}
	
		\item \textit{trivially copyable}
		\begin{itemize}
			\item Utilisation de \lstinline|memcpy()| ou \lstinline|memmove()|
		\end{itemize}

		\item \textit{trivial}
		\begin{itemize}
			\item Utilisation de \lstinline|goto| au-delà de la déclaration d'une variable
			\item Utilisation de \lstinline|qsort()| ou \lstinline|bsearch()|
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Unions généralisées}
	\begin{itemize}
		\item Constructeurs, opérateurs d'assignation ou destructeurs définis par l'utilisateur acceptés sur les types membres d'une union
		\item \ldots{} mais les fonctions équivalentes de l'union sont supprimées

\note[item]{Il est donc impossible de copier une union si un des membres est un type possédant un constructeur de copie défini par l'utilisateur}

		\item Toujours impossible d'utiliser des types avec des fonctions virtuelles, des références ou des classes de base
	\end{itemize}
\end{frame}

\subsection*{Namespace}
\begin{frame}[fragile]
	\frametitle{inline namespace}
	\begin{itemize}
		\item Injection des déclarations du namespace imbriqué dans le namespace parent
	\end{itemize}

	\begin{lstlisting}[language=C++]
namespace V1 { void foo() { cout << "V1\n"; } }

inline namespace V2 { void foo() { cout << "V2\n"; } }

V1::foo();  // Affiche V1
V2::foo();  // Affiche V2
foo();      // Affiche V2\end{lstlisting}

	\begin{block}{Motivation}
		\begin{itemize}
			\item Évolution de bibliothèque et conservation des versions précédentes
		\end{itemize}
	\end{block}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:26,positionColumn:1,positionLineNumber:26,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%0Anamespace+V1%0A%7B%0A++static+void+foo()%0A++%7B%0A++++std::cout+%3C%3C+%22V1%5Cn%22%3B%0A++%7D%0A%7D%0A%0Ainline+namespace+V2%0A%7B%0A++static+void+foo()%0A++%7B%0A++++std::cout+%3C%3C+%22V2%5Cn%22%3B%0A++%7D%0A%7D%0A%0Aint+main()%0A%7B%0A++V1::foo()%3B%0A++V2::foo()%3B%0A%0A++foo()%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\subsection*{nullptr}
\begin{frame}[fragile]
	\frametitle{\lstinline|0| ou \lstinline|NULL| ?}
	\begin{itemize}
		\item C++ 98 : \lstinline|0| ou \lstinline|NULL|

\note[item]{En C++, \lstinline|NULL| est un \lstinline|define| sur \lstinline|0| (ou équivalent), ne peut pas être \lstinline|(void*)0| comme en C}

		\item Cohabite mal avec les surcharges
	\end{itemize}

	\onslide<2>
	\begin{block}{Quiz : Quelle surcharge est éligible ?}
		\begin{lstlisting}[language=C++]
void foo(char*) { cout << "chaine\n"; }
void foo(int) { cout << "entier\n"; }

foo(0);
foo(NULL);\end{lstlisting}
	\end{block}

\note[item]{GCC 8.1 en C++2a - avec \lstinline|0| :  entier, avec \lstinline|NULL| : erreur de compilation (ambiguïté)}
\end{frame}

\begin{frame}[fragile]
	\frametitle{\lstinline|0| ou \lstinline|NULL| ? \lstinline|nullptr| !}
	\begin{itemize}
		\item C++ 11 : \lstinline|nullptr|
		\begin{itemize}
			\item Unique pointeur du type \lstinline|nullptr_t|
			\item Conversion implicite de \lstinline|nullptr_t| vers tout type de pointeur
		\end{itemize}
	\end{itemize}

	\begin{lstlisting}[language=C++]
void foo(char*) { cout << "chaine\n"; }
void foo(int) { cout << "entier\n"; }

foo(0);        // Version int
foo(nullptr);  // Version pointeur\end{lstlisting}

	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Utilisez \lstinline|nullptr| plutôt que \lstinline|0| ou \lstinline|NULL|
		\end{itemize}
	\end{exampleblock}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:22,positionColumn:1,positionLineNumber:22,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%0Astatic+void+foo(char*)%0A%7B%0A++std::cout+%3C%3C+%22chaine%5Cn%22%3B%0A%7D%0A%0Astatic+void+foo(int)%0A%7B%0A++std::cout+%3C%3C+%22entier%5Cn%22%3B%0A%7D%0A%0Aint+main()%0A%7B%0A++foo(0)%3B%0A%23if+1%0A++foo(NULL)%3B%0A%23else%0A++foo(nullptr)%3B%0A%23endif%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\subsection*{static\_assert}
\begin{frame}[fragile]
	\frametitle{\lstinline|static_assert|}
	\begin{itemize}
		\item Assertion vérifiée à la compilation
	\end{itemize}

	\begin{lstlisting}[language=C++]
static_assert(sizeof(int) == 3, "Taille incorrecte");
// Erreur de compilation indiquant "Taille incorrecte"\end{lstlisting}

	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Utilisez \lstinline|static_assert| pour vérifier à la compilation ce qui peut l'être
		\end{itemize}
	\end{exampleblock}

	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Préférez les vérifications \textit{compile-time} ou \textit{link-time} aux vérifications \textit{run-time}
		\end{itemize}

\note[item]{Typez correctement, définissez \lstinline|const| ce qui l'est par construction, pas de conversion implicite (et donc des constructeurs explicites), garantissez les invariants par construction si possible}
\note[item]{Et plusieurs autres points dans ce qui suit : opérateurs de conversion explicite, \lstinline|enum class|, \lstinline|override|, etc.}
	\end{exampleblock}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:5,positionColumn:1,positionLineNumber:5,selectionStartColumn:1,selectionStartLineNumber:5,startColumn:1,startLineNumber:5),source:'%23include+%3Ciostream%3E%0A%0Aint+main()%0A%7B%0A++static_assert(sizeof(int)+%3D%3D+3,+%22Taille+incorrecte%22)%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\subsection*{constexpr}
\begin{frame}[fragile]
	\frametitle{\lstinline|constexpr|}
	\begin{itemize}
		\item Indique une expression constante
		\item Donc évaluable et utilisable à la compilation
		\item Implicitement \lstinline|const|
		\item Fonctions \lstinline|constexpr| implicitement \lstinline|inline|
		\item Contenu des fonctions \lstinline|constexpr| limité
		\begin{itemize}
			\item \lstinline|static_assert|
			\item \lstinline|typedef|
			\item \lstinline|using|
			\item Exactement une expression \lstinline|return|
		\end{itemize}

\note[item]{Et des \textit{null statements}, mais ça n'a pas d'intérêt}
	\end{itemize}

	\begin{lstlisting}[language=C++]
constexpr int foo() { return 42; }

char bar[foo()];\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{\lstinline|constexpr|}
	\begin{lstlisting}[language=C++]
constexpr int foo() { return 42; }

int a = 42;
switch(a)
{
  case foo():
    break;

  default:
    break;
}\end{lstlisting}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:23,positionColumn:1,positionLineNumber:23,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%0Astatic+constexpr+int+foo()%0A%7B%0A++return+42%3B%0A%7D%0A%0Aint+main()%0A%7B%0A++char+bar%5Bfoo()%5D+%3D+%22azerty%22%3B%0A%0A++int+a+%3D+42%3B%0A++switch(a)%0A++%7B%0A++++case+foo():%0A++++++std::cout+%3C%3C+bar+%3C%3C+!'%5Cn!'%3B%0A++++++break%3B%0A%0A++++default:%0A++++++break%3B%0A++%7D%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{\lstinline|constexpr|}
	\begin{itemize}
		\item Sous certaines conditions restrictives, \lstinline|const| sur une variable est suffisant

\note[item]{type entier ou énumération, initialisé à la déclaration par une expression constante}
	\end{itemize}

	\begin{lstlisting}[language=C++]
const int a = 42;
char bar[a];\end{lstlisting}

	\begin{alertblock}{\textit{Variable-Length Array}}
		\begin{itemize}
			\item Pas de rapport entre VLA et \lstinline|constexpr|
			\item VLA est un mécanisme \textit{run-time}
		\end{itemize}
	\end{alertblock}

\note[item]{VLA est une fonctionnalité C, non reprise en C++, mais proposée sous forme d'extension par certains compilateurs. Elle consiste à accepter les tableaux de taille définie au \textit{run-time}}

	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Déclarez \lstinline|constexpr| les constantes et fonctions évaluables en \textit{compile-time}
		\end{itemize}
	\end{exampleblock}
\end{frame}

\subsection*{Extended sizeof}
\begin{frame}[fragile]
	\frametitle{Extended \lstinline|sizeof|}
	\begin{itemize}
		\item \lstinline|sizeof| sur des membres non statiques
	\end{itemize}

	\begin{lstlisting}[language=C++]
struct Foo { int bar; };

// Valide en C++11, mal-forme en C++98/03
cout << sizeof(Foo::bar); \end{lstlisting}

\note[item]{Mal-formé (\textit{ill-formed}) n'implique pas une erreur de compilation ni même un avertissement. Seulement que ce n'est pas correct vu de la norme}

	\begin{block}{Note}
		\begin{itemize}
			\item En pratique, cet exemple compile en mode C++98 sous GCC
		\end{itemize}

\note[item]{Au moins GCC 5.3 et suivants}
\note[item]{Compile et semble fonctionner, mais ce n'est pas pour autant correct}
	\end{block}
\end{frame}

\subsection*{Sémantique de déplacement}
\begin{frame}
	\frametitle{Sémantique de déplacement}
	\begin{itemize}
		\item Deux constats
		\begin{itemize}
			\item Copie peut être couteuse ou impossible

\note[item]{Copie désactivée : techniquement compliquée ou dangereux (flux, thread), pas de sens (sémantique d'entité)}

			\item Copie inutile lorsque l'objet source est immédiatement détruit
		\end{itemize}
	\end{itemize}

	\begin{block}{Optimisation des copies}
		\begin{itemize}
			\item Partiellement adressé en C++98/03 par l'élision de copie et (N)RVO
		\end{itemize}

\note[item]{Optimisations autorisées même lorsque le comportement observable est modifié}
	\end{block}

	\begin{itemize}
		\item Échange de données légères plutôt que copie profonde
		\item Déplacement seulement si
		\begin{itemize}
			\item Type déplaçable
			\item Instance sur le point d'être détruite ou explicitement déplaçable
		\end{itemize}
	\end{itemize}

	\begin{alertblock}{Attention}
		\begin{itemize}
			\item Les données ne sont plus présentes dans l'objet initial
		\end{itemize}
	\end{alertblock}
\end{frame}

\begin{frame}
	\frametitle{Sémantique de déplacement}
	\begin{itemize}
		\item Copie
	\end{itemize}

	\begin{picture}(0,0)(-50,0)
		% Boites
		\put(20,0){\framebox(30,8)[c]{\tiny Vecteur 1}}
		\put(50,0){\framebox(20,8)[c]{\tiny Cap n}}
		\put(70,0){\framebox(20,8)[c]{\tiny Taille m}}

		\put(110,0){\framebox(30,8)[c]{\tiny Vecteur 2}}
		\put(140,0){\framebox(20,8)[c]{\tiny Cap 0}}
		\put(160,0){\framebox(20,8)[c]{\tiny Taille 0}}

		\put(50,-16){\framebox(14,8)[c]{\tiny Obj\textsubscript{1}}}
		\put(64,-16){\framebox(14,8)[c]{\tiny Obj\textsubscript{2}}}
		\put(78,-16){\framebox(14,8)[c]{\tiny ...}}
		\put(92,-16){\framebox(14,8)[c]{\tiny Obj\textsubscript{m}}}

		\put(140,-16){\framebox(14,8)[c]{\tiny $null$}}

		% Fleches
		\put(35,0){\line(0,-1){12}}
		\put(35,-12){\vector(1,0){15}}

		\put(125,0){\line(0,-1){12}}
		\put(125,-12){\vector(1,0){15}}

		% Texte
		\put(0,-25){\tiny \color{teal}Allocation}

		% Boites
		\put(20,-35){\framebox(30,8)[c]{\tiny Vecteur 1}}
		\put(50,-35){\framebox(20,8)[c]{\tiny Cap n}}
		\put(70,-35){\framebox(20,8)[c]{\tiny Taille m}}

		\put(110,-35){\framebox(30,8)[c]{\tiny Vecteur 2}}
		\put(140,-35){\framebox(20,8)[c]{\tiny Cap n}}
		\put(160,-35){\framebox(20,8)[c]{\tiny Taille 0}}

		\put(50,-51){\framebox(14,8)[c]{\tiny Obj\textsubscript{1}}}
		\put(64,-51){\framebox(14,8)[c]{\tiny Obj\textsubscript{2}}}
		\put(78,-51){\framebox(14,8)[c]{\tiny ...}}
		\put(92,-51){\framebox(14,8)[c]{\tiny Obj\textsubscript{m}}}

		\put(140,-51){\framebox(14,8)[c]{\tiny }}
		\put(154,-51){\framebox(14,8)[c]{\tiny }}
		\put(168,-51){\framebox(14,8)[c]{\tiny }}
		\put(182,-51){\framebox(14,8)[c]{\tiny }}

		% Fleches
		\put(35,-35){\line(0,-1){12}}
		\put(35,-47){\vector(1,0){15}}

		\put(125,-35){\line(0,-1){12}}
		\put(125,-47){\vector(1,0){15}}

		% Texte
		\put(0,-60){\tiny \color{teal}Copie des éléments}

		% Boites
		\put(20,-70){\framebox(30,8)[c]{\tiny Vecteur 1}}
		\put(50,-70){\framebox(20,8)[c]{\tiny Cap n}}
		\put(70,-70){\framebox(20,8)[c]{\tiny Taille m}}

		\put(110,-70){\framebox(30,8)[c]{\tiny Vecteur 2}}
		\put(140,-70){\framebox(20,8)[c]{\tiny Cap n}}
		\put(160,-70){\framebox(20,8)[c]{\tiny Taille 0}}

		\put(50,-86){\framebox(14,8)[c]{\tiny Obj\textsubscript{1}}}
		\put(64,-86){\framebox(14,8)[c]{\tiny Obj\textsubscript{2}}}
		\put(78,-86){\framebox(14,8)[c]{\tiny ...}}
		\put(92,-86){\framebox(14,8)[c]{\tiny Obj\textsubscript{m}}}

		\put(140,-86){\framebox(14,8)[c]{\tiny Obj\textsubscript{1}}}
		\put(154,-86){\framebox(14,8)[c]{\tiny }}
		\put(168,-86){\framebox(14,8)[c]{\tiny }}
		\put(182,-86){\framebox(14,8)[c]{\tiny }}

		% Fleches
		\put(35,-70){\line(0,-1){12}}
		\put(35,-82){\vector(1,0){15}}

		\put(125,-70){\line(0,-1){12}}
		\put(125,-82){\vector(1,0){15}}

		% Texte
		\put(107,-100){...}

		% Boites
		\put(20,-114){\framebox(30,8)[c]{\tiny Vecteur 1}}
		\put(50,-114){\framebox(20,8)[c]{\tiny Cap n}}
		\put(70,-114){\framebox(20,8)[c]{\tiny Taille m}}

		\put(110,-114){\framebox(30,8)[c]{\tiny Vecteur 2}}
		\put(140,-114){\framebox(20,8)[c]{\tiny Cap n}}
		\put(160,-114){\framebox(20,8)[c]{\tiny Taille 0}}

		\put(50,-130){\framebox(14,8)[c]{\tiny Obj\textsubscript{1}}}
		\put(64,-130){\framebox(14,8)[c]{\tiny Obj\textsubscript{2}}}
		\put(78,-130){\framebox(14,8)[c]{\tiny ...}}
		\put(92,-130){\framebox(14,8)[c]{\tiny Obj\textsubscript{m}}}

		\put(140,-130){\framebox(14,8)[c]{\tiny Obj\textsubscript{1}}}
		\put(154,-130){\framebox(14,8)[c]{\tiny Obj\textsubscript{2}}}
		\put(168,-130){\framebox(14,8)[c]{\tiny ...}}
		\put(182,-130){\framebox(14,8)[c]{\tiny Obj\textsubscript{m}}}

		% Fleches
		\put(35,-114){\line(0,-1){12}}
		\put(35,-126){\vector(1,0){15}}

		\put(125,-114){\line(0,-1){12}}
		\put(125,-126){\vector(1,0){15}}
	\end{picture}
\end{frame}

\begin{frame}
	\frametitle{Sémantique de déplacement}
	\begin{itemize}
		\item Déplacement
	\end{itemize}

	\begin{picture}(0,0)(-50,0)
		% Boites
		\put(20,0){\framebox(30,8)[c]{\tiny Vecteur 1}}
		\put(50,0){\framebox(20,8)[c]{\tiny Cap n}}
		\put(70,0){\framebox(20,8)[c]{\tiny Taille m}}

		\put(110,0){\framebox(30,8)[c]{\tiny Vecteur 2}}
		\put(140,0){\framebox(20,8)[c]{\tiny Cap 0}}
		\put(160,0){\framebox(20,8)[c]{\tiny Taille 0}}

		\put(50,-16){\framebox(14,8)[c]{\tiny Obj\textsubscript{1}}}
		\put(64,-16){\framebox(14,8)[c]{\tiny Obj\textsubscript{2}}}
		\put(78,-16){\framebox(14,8)[c]{\tiny ...}}
		\put(92,-16){\framebox(14,8)[c]{\tiny Obj\textsubscript{m}}}

		\put(140,-16){\framebox(14,8)[c]{\tiny $null$}}

		% Fleches
		\put(35,0){\line(0,-1){12}}
		\put(35,-12){\vector(1,0){15}}

		\put(125,0){\line(0,-1){12}}
		\put(125,-12){\vector(1,0){15}}

		% Texte
		\put(0,-25){\tiny \color{teal}Permutation}

		% Boites
		\put(20,-35){\framebox(30,8)[c]{\tiny Vecteur 1}}
		\put(50,-35){\framebox(20,8)[c]{\tiny Cap 0}}
		\put(70,-35){\framebox(20,8)[c]{\tiny Taille 0}}

		\put(110,-35){\framebox(30,8)[c]{\tiny Vecteur 2}}
		\put(140,-35){\framebox(20,8)[c]{\tiny Cap n}}
		\put(160,-35){\framebox(20,8)[c]{\tiny Taille m}}

		\put(50,-51){\framebox(14,8)[c]{\tiny Obj\textsubscript{1}}}
		\put(64,-51){\framebox(14,8)[c]{\tiny Obj\textsubscript{2}}}
		\put(78,-51){\framebox(14,8)[c]{\tiny ...}}
		\put(92,-51){\framebox(14,8)[c]{\tiny Obj\textsubscript{m}}}

		\put(140,-51){\framebox(14,8)[c]{\tiny $null$}}

		% Fleches
		\put(35,-35){\line(0,-1){20}}
		\put(35,-55){\line(1,0){95}}
		\put(130,-55){\line(0,1){8}}
		\put(130,-47){\vector(1,0){10}}

		\put(125,-35){\line(0,-1){4}}
		\put(125,-39){\line(-1,0){85}}
		\put(40,-39){\line(0,-1){8}}
		\put(40,-47){\vector(1,0){10}}
	\end{picture}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Sémantique de déplacement}
	\begin{itemize}
		\item \textit{rvalue reference}
		\begin{itemize}
			\item Référence sur un objet temporaire ou sur le point d'être détruit
			\item Noté par une double esperluette : \lstinline|T&& value|
		\end{itemize}
		\item Deux fonctions \og de conversion\fg{}
		\begin{itemize}
			\item \lstinline|std::move()| convertit le paramètre en \textit{rvalue}

\note[item]{\lstinline|std::move()| force la sémantique de déplacement sur l'objet}

			\item \lstinline|std::forward()| convertit le paramètre en \textit{rvalue} s'il n'est pas une \textit{lvalue reference}
		\end{itemize}

		\begin{block}{\textit{rvalue}, \textit{lvalue}, \ldots ?}
			\begin{itemize}
				\item Voir \href{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf}{N3337} §3.10
			\end{itemize}
		\end{block}

		\begin{block}{\lstinline|std::forward()| ?}
			\begin{itemize}
				\item \textit{perfect forwarding} (Voir \href{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1385.htm}{N1385})
			\end{itemize}
		\end{block}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Sémantique de déplacement}
	\begin{itemize}
		\item Rendre une classe déplaçable
		\begin{itemize}
			\item Constructeur par déplacement \lstinline|T(const T&&)|
			\item Opérateur d'affectation par déplacement \lstinline|T& operator=(const T&&)|
		\end{itemize}
	\end{itemize}

	\begin{block}{Génération implicite}
		\begin{itemize}
			\item Pas de constructeur par copie, d'opérateur d'affectation, de destructeur, ni l'autre déplacement \textit{user-declared}
		\end{itemize}
	\end{block}

	\begin{alertblock}{\textit{user-declared} ? \textit{user-provided} ?}
		\begin{itemize}
			\item \textit{user-declared} : la fonction est déclarée par l'utilisateur, y compris en \lstinline|=default| 
			\item \textit{user-provided} : le corps de la fonction est fourni par l'utilisateur

\note[item]{Pour faire simple un fonction \lstinline|=default| est \textit{user-declared} mais pas \textit{user-provided}. Dans le cas de la génération implicite des opérations de déplacement, c'est bien le \textit{user-declared} qui désactive.}
		\end{itemize}
	\end{alertblock}
\end{frame}

\begin{frame}
	\frametitle{Sémantique de déplacement}
	\begin{block}{\textit{Rule of five}}
		Si une classe déclare destructeur, constructeur par copie ou par déplacement, affectation par copie ou par déplacement, alors elle doit définir les cinq

\note[item]{Contrairement à \textit{Rule of three}, l'absence des constructeur et opérateur d'affectation par déplacement n'est pas une erreur grave, mais une optimisation manquée}
	\end{block}

	\begin{block}{\textit{Rule of zero}}
		Lorsque c'est possible, n'en définissez aucune

\note[item]{\textit{Rule of zero} s'applique typiquement aux classes sans gestion explicite d'\textit{ownership}, c'est à dire sans membres qu'il faut explicitement libérés, fermés, \ldots. Ce qui devrait être le cas par défaut}
	\end{block}

	\begin{block}{Pour aller plus loin}
		\begin{itemize}
			\item Voir \href{https://github.com/cppp-france/CPPP-19/blob/master/elegance_style_epure_et_classe-Loic_Joly/elegance_style_epure_et_classe-Loic_Joly.pdf}{Élégance, style épuré et classe (Loïc Joly)}
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}
	\frametitle{Sémantique de déplacement}
	\begin{block}{Dans la bibliothèque standard}
		\begin{itemize}
			\item Nombreuses classes standard déplaçables (thread, flux, \ldots)

\note[item]{Mutex et lock ne sont pas copiables ni déplaçables}

			\item Évolution de contraintes : déplaçable plutôt que copiable

\note[item]{Évolution des contraintes notamment pour les conteneurs et les algorithmes}

			\item Implémentations utilisant le déplacement si possible
		\end{itemize}
	\end{block}
\end{frame}

\subsection*{Initialisation}
\begin{frame}[fragile]
	\frametitle{Initializer list}
	\begin{itemize}
		\item Initialisation des conteneurs
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo;

foo.push_back(1);
foo.push_back(56);
foo.push_back(18);
foo.push_back(3);

// Devient

vector<int> foo{1, 56, 18, 3};\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Initializer list}
	\begin{itemize}
		\item Classe \lstinline|std::initializer_list| pour accéder aux valeurs de la liste
	\end{itemize}

	\begin{alertblock}{Accéder, pas contenir !}
		\begin{itemize}
			\item \lstinline|std::initializer_list| référence mais ne contient pas les valeurs
			\item Valeurs contenues dans un tableau temporaire de même durée de vie
			\item Copier un \lstinline|std::initializer_list| ne copie pas les données
		\end{itemize}
	\end{alertblock}		

	\begin{itemize}
		\item Fonctions membres \lstinline|size()|, \lstinline|begin()|, \lstinline|end()|
		\item Construction automatique depuis une liste de valeurs entre accolades
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Initializer list}
	\begin{itemize}
		\item Constructeurs peuvent prendre un \lstinline|std::initializer_list| en paramètre
	\end{itemize}

	\begin{lstlisting}[language=C++]
MaClasse(initializer_list<value_type> itemList);\end{lstlisting}

	\begin{itemize}
		\item Ainsi que toute autre fonction
		\item Intégré aux conteneurs de la bibliothèque standard
	\end{itemize}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:39,positionColumn:1,positionLineNumber:39,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%23include+%3Cvector%3E%0A%23include+%3Cinitializer_list%3E%0A%0Astruct+Foo%0A%7B%0A++Foo(std::initializer_list%3Cint%3E+l)+:+m_vec(l)%0A++%7B%0A++++std::cout+%3C%3C+l.size()+%3C%3C+!'%5Cn!'%3B%0A++%7D%0A%0A++void+append(std::initializer_list%3Cint%3E+l)%0A++%7B%0A++++for(std::initializer_list%3Cint%3E::iterator+it+%3D+l.begin()%3B+it+!!%3D+l.end()%3B+%2B%2Bit)%0A++++%7B%0A++++++m_vec.push_back(*it)%3B%0A++++%7D%0A++%7D%0A%0A++std::vector%3Cint%3E+m_vec%3B%0A%7D%3B%0A%0Aint+main()%0A%7B%0A++Foo+foo+%3D+%7B1,+2,+3,+4,+5%7D%3B%0A++for(size_t+i+%3D+0%3B+i+%3C+foo.m_vec.size()%3B+%2B%2Bi)%0A++%7B%0A++++std::cout+%3C%3C+foo.m_vec%5Bi%5D+%3C%3C+!'+!'%3B%0A++%7D%0A++std::cout+%3C%3C+!'%5Cn!'%3B%0A%0A++foo.append(%7B6,+7,+8%7D)%3B%0A++for(size_t+i+%3D+0%3B+i+%3C+foo.m_vec.size()%3B+%2B%2Bi)%0A++%7B%0A++++std::cout+%3C%3C+foo.m_vec%5Bi%5D+%3C%3C+!'+!'%3B%0A++%7D%0A++std::cout+%3C%3C+!'%5Cn!'%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
\frametitle{Initializer list}
	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Préférez \lstinline|std::initializer_list| aux insertions successives
		\end{itemize}
	\end{exampleblock}

	\begin{alertblock}{Don't}
		\begin{itemize}
			\item N'utilisez pas \lstinline|std::initializer_list| pour copier ou transformer
			\item Utilisez les algorithmes et constructeurs idoines
		\end{itemize}

\note[item]{meilleure sémantique, plus évolutif et probablement plus performant}
	\end{alertblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Uniform Initialization}
	\begin{itemize}
		\item Plusieurs types d'initialisation en C++98/03
	\end{itemize}

	\begin{lstlisting}[language=C++]
int a = 2;
int b(2);
int c[] = {1, 2, 3};
int d;\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Uniform Initialization}
	\begin{itemize}
		\item Mais aucune de générique
	\end{itemize}

	\begin{lstlisting}[language=C++]
int a(2);        // Definition de l'entier a
int b();         // Declaration d'une fonction
int c(foo);      // ???
int d[] (1, 2);  // KO\end{lstlisting}

\note[item]{\lstinline|int b();| est un piège classique}
\note[item]{La signification de \lstinline|int c(foo);| va dépendre de ce qu'est \lstinline|foo|}

	\pause

	\begin{lstlisting}[language=C++]
int a[] = {1, 2, 3};        // OK

struct Foo { int a; };
Foo foo = {1};              // OK

vector<int> b = {1, 2, 3};  // KO
int c{8}                    // KO\end{lstlisting}

\note[item]{L'initialisation de \lstinline|Foo| fonctionne car c'est un POD (pas de classe de base, pas de virtuel, etc.)}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Uniform Initialization}
	\begin{itemize}
		\item En C++ 11, l'initialisation via \lstinline|{}| est générique
	\end{itemize}

	\begin{lstlisting}[language=C++]
int a[] = {1, 2, 3};         // OK
Foo b = {5};                 // OK
vector<int> c = {1, 2, 3};   // OK
int d = {8};                 // OK
int e = {};                  // OK\end{lstlisting}

	\begin{itemize}
		\item Avec ou sans \lstinline|=|
	\end{itemize}

	\begin{lstlisting}[language=C++]
int a[]{1, 2, 3};            // OK
Foo b{5};                    // OK
vector<int> c{1, 2, 3};      // OK
int d{8};                    // OK
int e{};                     // OK\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Uniform Initialization}
	\begin{itemize}
		\item Dans différents contextes
	\end{itemize}

	\begin{lstlisting}[language=C++]
int* p = new int{4};
long l = long{2};

void f(int);
f({2});\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Uniform Initialization}
	\begin{alertblock}{Attention}
		\begin{itemize}
			\item Pas de troncature avec \lstinline|{}|
		\end{itemize}

		\begin{lstlisting}[language=C++]
int foo{2.5};  // Erreur\end{lstlisting}
	\end{alertblock}

	\begin{alertblock}{Attention}
		\begin{itemize}
			\item Si le constructeur par \lstinline|std::initializer_list| existe, il est utilisé
		\end{itemize}

		\begin{lstlisting}[language=C++]
vector<int> foo{2};  // 2
vector<int> foo(2);  // 0 0\end{lstlisting}
	\end{alertblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Uniform Initialization}
	\begin{alertblock}{Contraintes sur l'initialisation d'agrégats}
		\begin{itemize}
			\item Pas d'héritage
			\item Pas de constructeur fourni par l'utilisateur
			\item Pas d'initialisation \textit{brace-or-equal-initializers}
			\item Pas de fonction virtuelle ni de membre non statique protégé ou privé
		\end{itemize}
	\end{alertblock}

	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Préférez l'initialisation \lstinline|{}| aux autres formes
		\end{itemize}
	\end{exampleblock}
\end{frame}

\subsection*{Déduction de type}
\begin{frame}[fragile]
	\frametitle{\lstinline|auto|}
	\begin{itemize}
		\item Déduction (ou inférence) de type

\note[item]{Les deux termes se trouvent. Forme simple (par rapport à des langages fonctionnels comme Caml ou Haskell) de l'inférence.}

		\item Type déduit de l'initialisation
	\end{itemize}

	\pause

	\begin{alertblock}{Attention}
		\begin{itemize}
			\item Inférence de type $\neq$ typage dynamique
			\item Inférence de type $\neq$ typage faible
			\item Typage dynamique $\neq$ typage faible
		\end{itemize}
	\end{alertblock}

	\pause

	\begin{block}{Vocabulaire}
		\begin{itemize}
			\item Statique : type porté par la variable et ne varie pas
			\item Dynamique : type porté par la valeur
			\item Absence : variable non typée, type imposé par l'opération
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{\lstinline|auto|}
	\begin{itemize}
		\item \lstinline|auto| définit une variable dont le type est déduit
	\end{itemize}

	\begin{lstlisting}[language=C++]
auto i = 2;  // int\end{lstlisting}

	\begin{itemize}
		\item Règles de déduction proches de celles des templates
		\item Listes entre accolades inférées comme des \lstinline|std::initializer_list|
	\end{itemize}

	\begin{alertblock}{Attention}
		\begin{itemize}
			\item Référence, \lstinline|const| et \lstinline|volatile| perdus durant la déduction
		\end{itemize}

		\begin{lstlisting}[language=C++]
const int i = 2;
auto j = i;  // int \end{lstlisting}
	\end{alertblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{\lstinline|auto|}
	\begin{itemize}
		\item Combinaison possible avec \lstinline|const|, \lstinline|volatile| ou \lstinline|&|
	\end{itemize}

	\begin{lstlisting}[language=C++]
const auto i = 2;

int j = 3;
auto& k = j;\end{lstlisting}

	\begin{itemize}
		\item Typer explicitement l'initialiseur permet de forcer le type déduit
	\end{itemize}

	\begin{lstlisting}[language=C++]
// unsigned long
auto i = static_cast<unsigned long>(2);
auto j = 2UL\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{\lstinline|auto|}
	\begin{itemize}
		\item Tendance forte \textit{Almost Always Auto} (AAA)
	\end{itemize}

	\begin{block}{Pour aller plus loin}
		\begin{itemize}
			\item Voir \href{https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/}{GotW 94 : AAA Style}
		\end{itemize}
	\end{block}

	\begin{itemize}
		\item Plusieurs avantages
		\begin{itemize}
			\item Variables forcément initialisées
			\item Typage correct et précis
			\item Garanties conservées au fil des corrections et refactoring
			\item Généricité et simplification du code
		\end{itemize}
	\end{itemize}

	\pause

	\begin{block}{Quiz}
		\begin{itemize}
			\item Type de retour de \lstinline|std::list<std::string>::size()| ?
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{\lstinline|auto|}
	\begin{itemize}
		\item Limitations - solutions
		\begin{itemize}
			\item Erreur de déduction - typage explicite de l'initialiseur
			\item Initialisation impossible - \lstinline|decltype|
			\item Interfaces, rôles, contexte - concepts ?

\note[item]{Pas utile de connaitre le type exact d'une variables de type \lstinline|std::map<std::string, std::vector<unsigned long long> >::const_iterator| mais il peut être important de savoir que c'est un itérateur. Ce qu'auto n'indique pas}
\note[item]{Mais il faut attendre C++20 pour avoir les concepts}
		\end{itemize}
	\end{itemize}

	\begin{alertblock}{Compatibilité}
		\begin{itemize}
			\item \lstinline|auto| présent en C++98/03 avec un sens radicalement différent
		\end{itemize}

\note[item]{Sens en C++98/03 : variable de type automatique (c'est à dire sur la pile) par opposition à statique (cas par défaut et donc inutilisé en pratique)}
\note[item]{Un cas où la compatibilité ascendante entre C++98/03 et C++11 a été rompue}
	\end{alertblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{\lstinline|decltype|}
	\begin{itemize}
		\item Déduction du type d'une variable ou d'une expression
		\item Permet donc la création d'une variable du même type
	\end{itemize}

	\begin{lstlisting}[language=C++]
int a;
long b;
decltype(a) c;         // int
decltype(a + b) d;     // long\end{lstlisting}

	\begin{itemize}
		\item Généralement, déduction sans aucune modification du type

\note[item]{Donc conservation des références, \lstinline|const|, etc.}

		\item Depuis une \textit{lvalue} de type \lstinline|T| autre qu'un nom de variable : \lstinline|T&|
	\end{itemize}

	\begin{lstlisting}[language=C++]
decltype( (a) ) e;     // int&\end{lstlisting}

\note[item]{Au passage, cette ligne ne compile pas car la référence n'est pas initialisée}
\end{frame}

\begin{frame}[fragile]
	\frametitle{\lstinline|declval|}
	\begin{itemize}
		\item Utilisation de fonctions membres dans \lstinline|decltype| sans instance
		\item Typiquement sur des templates acceptant des types sans constructeur commun mais avec une fonction membre commune
	\end{itemize}

	\begin{lstlisting}[language=C++]
struct foo {
  foo(const foo&) {}
  int bar () const { return 1; } };

decltype(foo().bar()) n2 = 5;               // Erreur
decltype(std::declval<foo>().bar()) n2 = 5; // OK, int\end{lstlisting}

	\begin{alertblock}{Attention}
		\begin{itemize}
			\item Uniquement dans des contextes non évalués
		\end{itemize}
	\end{alertblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Déduction du type retour}
	\begin{itemize}
		\item Combinaison de \lstinline|auto| et \lstinline|decltype|
	\end{itemize}

	\begin{lstlisting}[language=C++]
auto add(int a, int b) -> decltype(a + b) {
  return a + b; }\end{lstlisting}

	\begin{itemize}
		\item Particulièrement utiles pour des fonctions templates
	\end{itemize}

	\begin{block}{Quiz : T, U ou autre ?}
		\begin{lstlisting}[language=C++]
template<typename T, typename U> ??? add(T a, U b) {
  return a + b; }\end{lstlisting}

\note[item]{Vrai problème sur les templates avant C++11}
\note[item]{Une solution historique : un seul type template et on compte sur les conversions implicites voire on demande des conversions explicites}
	\end{block}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1DIApACYAQuYukl9ZATwDKjdAGFUtAK4sGe1wAyeAyYAHI%2BAEaYxCBm0gAOqAqETgwe3r56icmOAkEh4SxRMXG2mPa5DEIETMQE6T5%2BXGUVqdW1BPlhkdGx0go1dQ2ZzQMdXYXFfQCUtqhexMjsHOYAzMHI3lgA1Carbk4DxJise9gmGgCCaxtbmLv7AG6YDiRnF9dXTF5E20zo6AgwQIf1I22B2wi022AFoztssJsCABPeKYCBMXaWSHQj4mADsViu222xwICwYfyxFkheyJ13xABE8VcISwmMEINM8YSPiSCfSSSTvr88A9GdszHS%2BUKBugQCh5iC9m4VeCHqr9lizNqNWqUWi8IC8NMAHTMNhcvVa8w623WtzbA2YI1AwRmi3o3H7NW2kwAVjcDD9q0FuyZLMu/N5xKFItQ6r2ErGjmQAH1RAMVV4GMlgCF0NtaAJgGcIGZuaGZSS5Qq0D8HYmfTazHbW43na6TebWF7G/aB83HZ3ATm8wWiyWPb2rSrfa2A0GQ2GCcyrjKBdW/j8E2Kk38ARBmttVpWwzWCPLFQ251q90PdYPNcPUS7jdPLd7n4/27eX4bjXdHtP37BdA2DBcq1jVceTXS4OFmWhOH9Xg/A4LRSFQThVUsaxtgUeZFnuNYeFIAhNAQ2YAGsQH9DR9E4SRUIozDOF4BQQHo8j0IQ0g4FgJBMFUF4dzICgMWIYAFGUQxyiEBBUAAdzQ0i0BYeI6CYSoZJCWh5KUtCMLUjT6BiYAuFbUhjLoaJQl7NirNQdSbOIAB5H59OUlihJeS5JI4jheB85BqnwNDeH4QQRDEdgpBkQRFBUdQeNIXRmgMIwUGsax9DwCIONgT0QAiVAkgIUhnhibh8RQ6ZZlQeJKgCmE5STUxcMsLguFhAB1MRaF6oSCGIJh2MIpY9DlYIdLkhSvO4XhhswZZSMUkb4goxDkOYlKsI4bBhOQUTtlUAAOAA2GFzskbZgGQZBtgs00dQgHCrEsMFcEIEgsVWLhpkWzbZgQE4sBiLlSBouiGI4JjSEM3g9vYziyKBmGzB2jCkdRni6oq6JkmcSQgA%3D}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Déduction du type retour}
	\begin{block}{Solution}
		\begin{itemize}
			\item Pas de bonne réponse en typage explicite
			\item Mais l'inférence de type vient à notre secours
		\end{itemize}
	\end{block}

	\begin{lstlisting}[language=C++]
template<typename T, typename U>
auto add(T a, U b) -> decltype(a + b) {
  return a + b; }\end{lstlisting}

	\begin{exampleblock}{do}
		\begin{itemize}
			\item Utilisez la déduction du type retour dans vos fonctions templates
		\end{itemize}
	\end{exampleblock}
\end{frame}

\subsection*{Conteneurs}
\begin{frame}[fragile]
	\frametitle{\lstinline|std::array|}
	\begin{itemize}
		\item \lstinline|std::array|
		\begin{itemize}
			\item Tableau de taille fixe connue à la compilation
			\item Éléments contigus
			\item Accès indexé
		\end{itemize}
	\end{itemize}

	\begin{lstlisting}[language=C++]
array<int, 8> foo{2, 5, 9, 8, 2, 6, 8, 9};
accumulate(foo.begin(), foo.end(), 0); // 49\end{lstlisting}

	\begin{lstlisting}[language=C++]
array<int, 8> foo{2, 5, 9, 8, 2, 6, 8, 9, 17};
// Erreur de compilation\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{\lstinline|std::array|}
	\begin{itemize}
		\item[]\begin{itemize}
			\item Vérification des index à la compilation
		\end{itemize}
	\end{itemize}

	\begin{lstlisting}[language=C++]
array<int, 8> foo{2, 5, 9, 8, 2, 6, 8, 9};
get<2>(foo) << '\n';  // 9
get<8>(foo) << '\n';  // Erreur de compilation\end{lstlisting}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:18,positionColumn:1,positionLineNumber:18,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%23include+%3Carray%3E%0A%23include+%3Cnumeric%3E%0A%0Aint+main()%0A%7B%0A++%7B%0A++++std::array%3Cint,+8%3E+foo%7B2,+5,+9,+8,+2,+6,+8,+9%7D%3B%0A++++std::cout+%3C%3C+std::accumulate(foo.begin(),+foo.end(),+0)+%3C%3C+!'%5Cn!'%3B%0A++%7D%0A%0A%23if+0%0A++%7B%0A++++std::array%3Cint,+8%3E+foo%7B2,+5,+9,+8,+2,+6,+8,+9,+17%7D%3B%0A++%7D%0A%23endif%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
\frametitle{\lstinline|std::forward_list|}
	\begin{itemize}
		\item Liste simplement chaînée \lstinline|std::forward_list|
	\end{itemize}

	\begin{lstlisting}[language=C++]
forward_list<int> foo{2, 5, 9, 8, 2, 6, 8, 9, 12};
accumulate(foo.begin(), foo.end(), 0); // 61\end{lstlisting}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:12,positionColumn:1,positionLineNumber:12,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%23include+%3Cforward_list%3E%0A%23include+%3Cnumeric%3E%0A%0Aint+main()%0A%7B%0A++%7B%0A++++std::forward_list%3Cint%3E+foo%7B2,+5,+9,+8,+2,+6,+8,+9,+12%7D%3B%0A++++std::cout+%3C%3C+std::accumulate(foo.begin(),+foo.end(),+0)+%3C%3C+!'%5Cn!'%3B%0A++%7D%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Conteneurs associatifs}
	\begin{itemize}
		\item Conteneurs associatifs sous forme de tables de hachage
		\begin{itemize}
			\item \lstinline|std::unordered_map|
			\item \lstinline|std::unordered_multimap|
			\item \lstinline|std::unordered_set|
			\item \lstinline|std::unordered_multiset|
		\end{itemize}
		\item Versions non ordonnées de \lstinline|std::map|, \lstinline|std::multimap|, \lstinline|std::set| et \lstinline|std::multiset|

		\begin{block}{\textit{Unordered} ?}
			\begin{itemize}
				\item Nombreuses implémentations \lstinline|hash_XXX| existantes
				\item Structures fondamentalement non ordonnées
			\end{itemize}
		\end{block}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{\lstinline|shrink_to_fit()|}
	\begin{itemize}
		\item \lstinline|shrink_to_fit()| réduit la capacité des \lstinline|std::vector|, \lstinline|std::deque| et \lstinline|std::string| à leur taille
	\end{itemize}

\note[item]{Pour être précis, ce n'est pas nécessairement exactement à la taille ça peut être plus grand - à la discrétion de l'implémentation (performances, cohérence, \ldots) -, mais l'idée est là}

	\begin{lstlisting}[language=C++]
vector<int> foo{12, 25};
foo.reserve(15);
// Taille : 2, capacite : 15

foo.shrink_to_fit();
// Taille : 2, capacite : 2\end{lstlisting}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:13,positionColumn:1,positionLineNumber:13,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%23include+%3Cvector%3E%0A%0Aint+main()%0A%7B%0A++std::vector%3Cint%3E+foo%7B12,+25%7D%3B%0A++foo.reserve(15)%3B%0A++std::cout+%3C%3C+foo.size()+%3C%3C+%22+/+%22+%3C%3C+foo.capacity()+%3C%3C+!'%5Cn!'%3B%0A%0A++foo.shrink_to_fit()%3B%0A++std::cout+%3C%3C+foo.size()+%3C%3C+%22+/+%22+%3C%3C+foo.capacity()+%3C%3C+!'%5Cn!'%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{\lstinline|data()|}
	\begin{itemize}
		\item \lstinline|data()| récupère le \og tableau C\fg{} d'un \lstinline|std::vector|
	\end{itemize}

	\begin{block}{\lstinline|foo.data()| ? \lstinline|&foo[0]| ?}
		\begin{itemize}
			\item Comportement identique
			\item Préférez \lstinline|foo.data()| sémantiquement plus clair
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{\lstinline|emplace()|}
	\begin{itemize}
		\item \lstinline|emplace()|, \lstinline|emplace_back()| et \lstinline|emplace_front()| construisent dans le conteneur depuis les paramètres d'un des constructeurs de l'élément
	\end{itemize}

	\begin{lstlisting}[language=C++]
class Point {
public:
  Point(int a, int b); };

vector<Point> foo;
foo.emplace_back(2, 5);\end{lstlisting}

	\begin{block}{Objectif}
		\begin{itemize}
			\item Éliminer les copies inutiles restantes et gagner en performance
		\end{itemize}

\note[item]{Copies présentes malgré l'élision de copie, (N)RVO et la sémantique de déplacement}
\note[item]{On gagne aussi en lisibilité (moins de ligne, pas de construction juste pour pousser, pas d'introduction d'un nom sans utilité)}
	\end{block}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:22,positionColumn:1,positionLineNumber:22,selectionStartColumn:1,selectionStartLineNumber:22,startColumn:1,startLineNumber:22),source:'%23include+%3Ciostream%3E%0A%23include+%3Cvector%3E%0A%0Aclass+Point+%0A%7B%0Apublic:%0A++Point(int+a,+int+b)%0A++++:+m_a(a)%0A++++,+m_b(b)%0A++%7B%0A++%7D%0A%0A++int+m_a%3B%0A++int+m_b%3B%0A%7D%3B%0A%0Aint+main()%0A%7B%0A++std::vector%3CPoint%3E+foo%3B%0A++foo.emplace_back(2,+5)%3B%0A%0A++std::cout+%3C%3C+foo%5B0%5D.m_a+%3C%3C+%22+%22+%3C%3C+foo%5B0%5D.m_b+%3C%3C+%22%5Cn%22%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{\lstinline|std::string|}
	\begin{itemize}
		\item Évolutions de \lstinline|std::string|
		\begin{itemize}
			\item Éléments obligatoirement contigus
			\item \lstinline|data()| retourne une chaîne C valide (synonyme à \lstinline|c_str()|)

\note[item]{En C++98, \lstinline|data()| renvoyait les caractères de la chaîne mais pas nécessairement sous forme d'une chaîne C valide (pas obligatoirement de 0 terminal)}

			\item \lstinline|front()| retourne le premier caractère d'une chaîne
			\item \lstinline|back()| retourne le dernier caractère d'une chaîne
			\item \lstinline|pop_back()| supprime le dernier caractère d'une chaîne
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{\lstinline|std::bitset|}
	\begin{itemize}
		\item Évolutions de \lstinline|std::bitset|
		\begin{itemize}
			\item \lstinline|all()| teste si tous les bits sont levés
			\item \lstinline|to_ullong()| convertit en \lstinline|unsigned long long|
		\end{itemize}
	\end{itemize}

	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Préférez \lstinline|std::array| lorsque la taille est fixe et connue
			\item Sinon préférez \lstinline|std::vector| 
		\end{itemize}
	\end{exampleblock}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:17,positionColumn:1,positionLineNumber:17,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%23include+%3Cbitset%3E%0A%0Aint+main()%0A%7B%0A++std::bitset%3C5%3E+foo%3B%0A++std::cout+%3C%3C+std::boolalpha+%3C%3C+foo.all()+%3C%3C+!'%5Cn!'%3B%0A%0A++foo.set(2)%3B%0A++std::cout+%3C%3C+std::boolalpha+%3C%3C+foo.all()+%3C%3C+!'%5Cn!'%3B%0A++std::cout+%3C%3C+foo.to_ullong()+%3C%3C+!'%5Cn!'%3B%0A%0A++foo.set()%3B%0A++std::cout+%3C%3C+std::boolalpha+%3C%3C+foo.all()+%3C%3C+!'%5Cn!'%3B%0A++std::cout+%3C%3C+foo.to_ullong()+%3C%3C+!'%5Cn!'%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\subsection*{Itérateurs}
\begin{frame}[fragile]
	\frametitle{Itérateurs}
	\begin{itemize}
		\item Fonctions membres \lstinline|cbegin()|, \lstinline|cend()|, \lstinline|crbegin()| et \lstinline|rcend()| retournant des \lstinline|const_iterator|

\note[item]{Les fonctions \lstinline|begin()|, \lstinline|end()|, etc. retournent des \lstinline|const_iterator| si le conteneur est \lstinline|const|, des \lstinline|iterator| dans le cas contraire}

		\item Fonctions libres \lstinline|std::begin()| et \lstinline|std::end()|
		\begin{itemize}
			\item Conteneur : appel des fonctions membres
			\item Tableau C : adresse du premier élément et suivant le dernier élément
		\end{itemize}
	\end{itemize}

	\begin{lstlisting}[language=C++]
int foo[] = {1, 2, 3, 4};
vector<int> bar{2, 3, 4, 5};

accumulate(begin(foo), end(foo), 0);  // 10
accumulate(begin(bar), end(bar), 0);  // 14\end{lstlisting}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:11,positionColumn:1,positionLineNumber:11,selectionStartColumn:1,selectionStartLineNumber:11,startColumn:1,startLineNumber:11),source:'%23include+%3Ciostream%3E%0A%23include+%3Cvector%3E%0A%23include+%3Cnumeric%3E%0A%0Aint+main()%0A%7B%0A++int+foo%5B%5D+%3D+%7B1,+2,+3,+4%7D%3B%0A++std::vector%3Cint%3E+bar%7B2,+3,+4,+5%7D%3B%0A%0A++std::cout+%3C%3C+std::accumulate(std::begin(foo),+std::end(foo),+0)+%3C%3C+%22%5Cn%22%3B%0A++std::cout+%3C%3C+std::accumulate(std::begin(bar),+std::end(bar),+0)+%3C%3C+%22%5Cn%22%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Itérateurs}
	\begin{itemize}
		\item [] \begin{itemize}
			\item Compatibles avec les conteneurs non-STL proposant \lstinline|begin()| et \lstinline|end()|
			\item Surchargeable sans modification du conteneur pour les autres
		\end{itemize}
	\end{itemize}

	\begin{lstlisting}[language=C++]
class Foo {
public:
  char* first();
  const char* first() const; };

char* begin(Foo& foo) {
  return foo.first(); }

const char* begin(const Foo& foo) {
  return foo.first(); }\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Itérateurs}
	\begin{block}{Conseils}
		\begin{itemize}
			\item \lstinline|using std::begin| et \lstinline|using std::end| permet l'ADL malgré la surcharge
		\end{itemize}
	\end{block}

	\begin{alertblock}{Don't}
		\begin{itemize}
			\item N'ouvrez pas le namespace \lstinline|std| pour spécialiser
		\end{itemize}
	\end{alertblock}

	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Préférez \lstinline|std::begin()| et \lstinline|std::end()| aux fonctions membres
		\end{itemize}

\note[item]{Plus générique (à commencer par tableau C), coût à priori nul}
	\end{exampleblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Itérateurs}
	\begin{itemize}
		\item Fonctions libres \lstinline|std::prev()| et \lstinline|std::next()| pour retrouver l'itérateur suivant ou précédent
		\item \lstinline|move_iterator| : adaptateur d'itérateur retournant des \textit{rvalue reference} lors du déréférencement
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<string> foo(3), bar{"one","two","three"};

typedef vector<string>::iterator Iter;

copy(move_iterator<Iter>(bar.begin()),
     move_iterator<Iter>(bar.end()),
     foo.begin());
// foo : "one" "two" "three"
// bar : "" "" ""\end{lstlisting}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1DIApACYAQuYukl9ZATwDKjdAGFUtAK4sGe1wAyeAyYAHI%2BAEaYxCAAzGakAA6oCoRODB7evnrJqY4CQSHhLFEx8baY9vkMQgRMxASZPn5cFVXptfUEhWGR0XEJCnUNTdmtQ109xaUDAJS2qF7EyOwc5rHByN5YANQmsW5OQ8SYrPvYJhoAguub25h7BwBumA4k55c3ZhsMW167%2Bzcx2CwA%2B11uv3ujzcYmAJEICBYYJu1wIAE9EpgsFQdkN0CAQC83sRAXiCcCjOcCYRokwiMQdgBJAjRfZWcHXYIEHYsJjBCCzT4mADs7KuOz2os%2BEolZMJr3pgK55x2/FQIosAFZSDtYjqABw6rhmEUAETZQuuMp2TC8RB2hEeptxBHxICiwH5asFsTF1rlaDt0MBOwAVI7ASHzGY9mYY5GDmGQqoCBBCLNg4noyZNW4GNnfdLJeaOeLJX6ZXKiYqDnKKaDYthVahUBBYj6K7LXQTq%2B9a92QPWVRF6hrowJMNHSNGCAB3dVx6dxggIE6TuNmi1WysDtCJNEQOUsVAvAD6NOIdL7bmZrMbEBHxAAdB7%2BbN5i63cezxerySDre/7YA%2B9RPq4AofmqL6YJ6DAQVuKJlhK/DEIeeAAF6YKe3J4E6OwaGyDrQs2qBPqkmECoR1jWHggrbhKY70TubqBtyCZuLGZhgGscaZhxao5hYeA5s67GcdxnEIdam5MQGixsQcIbcTmebKYWTEoWhmHYUR%2BzOgRvq6Ymj5kRhmCUYZ1GWLRRYMVKTFdix8l8eJPHxopxmjpqQkiS50YSQWnbFrZn4EqxLnKbmDBqRWMk3MKJZXBw8y0Jwmq8H4HBaKQqCcG4VkWLiizLA86w8KQBCaMl8wANYgJqmpPlIsQAGwaLEXCxB1moAJxmMK%2BicJIGVVTlnC8AoIAaBVVXzHAsBIJgqivHaJDkJQ9TAAoyiGJUQgIKgs6ZeVaAsIkdB0ukO0hLQ%2B2HZl2Wned9AxMAxoJE9dDRKErCrLwn0vQA8nad1HaNS2vFcxBbeNpAQ8gtT4JlvD8IIIhiOwUgyIIigqOoWU6HoBhGCgBX6HgESTbAzBsO6LZDKQLwxNwwrpe%2BOWJNUk0cAAtHiemmJY1hcFwOw8wA6mItBi%2BLS0EJeE3FSseh4sE117QdYPcLw8uYKs5WzpeiSzYNHDpaQD28LlHDYMtyCrQyqj6i1PMtZIOzAMgyA7MaT4xhA%2BVC5YOq4IQJCxh1sw67N8wIKcWAxAKpB1ZIkhPvqmotbEPUtc7ueSBowp6qlHDDRbo3WxNU0zQT7Ml2YI0E2NHDR7X8xM6kziSEAA}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\subsection*{Algorithmes}
\begin{frame}[fragile]
	\frametitle{Foncteurs prédéfinis}
	\begin{itemize}
		\item \lstinline|std::bit_and()| : et bit à bit
		\item \lstinline|std::bit_or()| : ou inclusif bit à bit
		\item \lstinline|std::bit_xor()| : ou exclusif bit à bit
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<unsigned char> foo{0x10, 0x20, 0x30};
vector<unsigned char> bar{0xFF, 0x25, 0x00};
vector<unsigned char> baz;

transform(begin(foo), end(foo), begin(bar), 
          back_inserter(baz), 
          bit_and<unsigned char>());
// baz : 0x10 0x20, 0x00\end{lstlisting}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1DIApACYAQuYukl9ZATwDKjdAGFUtAK4sGIM6SuADJ4DJgAcj4ARpjEIJIAzKQADqgKhE4MHt6%2B/ilpGQIhYZEsMXGJtpj2jgJCBEzEBNk%2BfgF2mA6Z9Y0ExRHRsfFJCg1NLbntY32hA2VDiQCUtqhexMjsHOYJocjeWADUJgluTqPEmKzH2CYaAILbu/uYRydOLIZ4yde3D2Y7DD2XkOxzcADdOkRiD97o9Ac9Xm5zqFgDC/gCgSCTmJgCRCAgWGjfqECAcPqEIItfiYAOxWe4HA6jdAgEAQhwkUFeBjpYBhdAHZAIRrXA78VC0iwaVRcDSkA7SsxyhWqBIaWkAEWO9LujOZrPZUK5PLwfMwAqFIoS2AOURFdOlADFHfLFQBWV2qDTqmlahI636MyWBxlMggstmQzknbm8/mC4XQ622pgAL21Ib14dZBGIhgU/GILAg%2BpAMWAFPFyzDEdc1FQqGrpfLFLtxCb2bLTGQAGsAPqhJRNWIQO2pjsRqKEPuGdDGuPmhNW7CUqn%2B6kM0OFkt4VOYPukvCvDUK7UHI%2BglOpgB06T3lLP1mseCpm6DdMzodLaC8pNBl9LBBMFUREAM7JQCBoWhaAgMAOA0ODFlAk4a1ZCCAHcIDMJD/xQ0YmEcZA%2B1EUZ51NeMSWuUc0xMN0LDwWiNRwk5L3MMwjjMMwMzfI5fU/b9Vj/FiULg2i3AYUT103TUN11XidVDVDIw5JM3FjcjF0tJMbTHbi5KzCNc3zQti2bTAKwYetG3lUs6yrGzOxbSy2wnVk7V7AceViAgRzHVyy2naM1JNM0LUTKjFjXAMeO3O990PY9T39c9ESvW9d0wB9kqfSwX0/YMeIM1kfyEtwwIjICQNwtwlIgqCYLghCOGYsq8PAzACEw7DkJq/DCOIphSJjEKKMEKjdLohi3SYnqOPYti9MUmSeIE39ZtEt1xMkhTeK1WFpI/FbO0NIL1NCpdtKvRav07IyeRMktHPMysG38uzXocydnucxp/Pc/tB283y0z%2B6dVFOkbNPC61Vz0z9Yoyg8UuOE91WSi8ULHdL7yijirFy199Pkz8ipQQTZsA4CKfayC6Aa%2BDEOpiMMKwlqwIIvAiJIggyPOyiYYm%2BjGLZlC2Lm673z2onVtKy8Nq2rYpLk5aHj4%2B5mv0Tg3V4Px4N4VBODKyxrCZVZ1hebYeFIAhNGa5YexAN03WvKQEgANg0BIuASL23QATjMGlNY4SQddt0gDY4XgFBAOUbb15Y4FgJBgM6X8SHIShGmABRlEMaohAQVB0N1q20BYZI6A5gQ87CWhC%2BL3WtFIcvK/oOJgC4TiW9QCu6FicJWE2XhW/74gAHlfwbkvw9T5A7mIHPOF4Of6nwXXeH4QQRDEdgpBkQRFBUdQ9dIXQuH0QxjBymxaDwKIY9gZg2DLBtRlICE4m4GltciiPklqDyTgABaZkKNTDG0sFwLgBxgEAHUxC0FgXA4CRlo5mw2HoZkoRa4FyLjPbgvBcyYE2FbdCeZki22WLQLWYdT6R2wKoNOUIDiqAABxu2AW7SQBxgDIGQAcLu152IQCNvjGwBxcCEBIBxL2iwiFUOWEBJgWA4iUlIA7SQkhrxsLdG7BIfs3YcKMZIDQNIkg0JDnQ5ukdo6x2too4OZhrH62Xg4hOyxP7pGcJIIAA}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Algorithmes - Recherche linéaire}
	\begin{itemize}
		\item \lstinline|std::find_if_not()| recherche le premier élément ne vérifiant pas le prédicat
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{1, 4, 5, 9, 12};

find_if_not(begin(foo), end(foo), is_odd); // 4\end{lstlisting}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:15,positionColumn:1,positionLineNumber:15,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%23include+%3Cvector%3E%0A%23include+%3Calgorithm%3E%0A%0Astatic+bool+is_odd(int+i)%0A%7B%0A++return+(i%252)%3D%3D1%3B%0A%7D%0A%0Aint+main()%0A%7B%0A++std::vector%3Cint%3E+foo%7B1,+4,+5,+9,+12%7D%3B%0A++std::cout+%3C%3C+*std::find_if_not(std::begin(foo),+std::end(foo),+is_odd)+%3C%3C+%22%5Cn%22%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:55.14360313315927,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:44.85639686684073,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Algorithmes - Comparaison}
	\begin{itemize}
		\item \lstinline|std::all_of()| teste si tous les éléments de l'ensemble vérifient un prédicat
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{1, 4, 5, 9, 12};
vector<int> bar{1, 5, 9};
vector<int> baz{4, 12};

all_of(begin(foo), end(foo), is_odd); // False
all_of(begin(bar), end(bar), is_odd); // True
all_of(begin(baz), end(baz), is_odd); // False\end{lstlisting}

	\begin{itemize}
		\item Retourne vrai si l'ensemble est vide
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Algorithmes - Comparaison}
	\begin{itemize}
		\item \lstinline|std::any_of()| teste si au moins un élément vérifie un prédicat
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{1, 4, 5, 9, 12};
vector<int> bar{1, 5, 9};
vector<int> baz{4, 12};

any_of(begin(foo), end(foo), is_odd); // True
any_of(begin(bar), end(bar), is_odd); // True
any_of(begin(baz), end(baz), is_odd); // False\end{lstlisting}

	\begin{itemize}
		\item Retourne faux si l'ensemble est vide
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Algorithmes - Comparaison}
	\begin{itemize}
		\item \lstinline|std::none_of()| teste si aucun élément ne vérifie le prédicat
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{1, 4, 5, 9, 12};
vector<int> bar{1, 5, 9};
vector<int> baz{4, 12};

none_of(begin(foo), end(foo), is_odd); // False
none_of(begin(bar), end(bar), is_odd); // False
none_of(begin(baz), end(baz), is_odd); // True\end{lstlisting}

	\begin{itemize}
		\item Retourne vrai si l'ensemble est vide
	\end{itemize}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1DIApACYAQuYukl9ZATwDKjdAGFUtAK4sGe1wAyeAyYAHI%2BAEaYxCAAbBqkAA6oCoRODB7evnrJqY4CQSHhLFEx8baY9vkMQgRMxASZPn5cFVXptfUEhWGR0XoKdQ1N2a2DXT3FpRIAlLaoXsTI7BzmAMzByN5YANQma25Og8SYrPvYJhoAguub25h7BwBumA4k55c3ZhsMW167%2BzcYmAJEICBYH2uny8qSMO0G6BAICiwGC%2Bys1xhwWA8IIiJArnRn0%2B40cyB2EVQnh2eAUAH0MOgIMECDSZsSAOwYq47HYnAiLBg7ZnmACsZnZawAIvspVwiVCOTKodcWTsWExghB2YrubyTFzPrzeQikS83sRASzzjt%2BKgDRZWjtpDtRaQdgBOd1cMwGmVrPXG00oBaswGA3H4ymeMSJBBMR5uCPBsS0BlUCAorV2uY7VzUKm52kM9DoGaJiNgVaitwMKsKnl7JXE676w2toN4s2vIiWg7WtbYW1Uh1Ot2ev0N42RpFoLxhg7JrvIqkGWhxhPhg4zkCp9OZzCohgF1C5/M593FxnlrduHb1mt11YBo1N5U3DsO18m5fm3tWwQbTtB0XR9ScXw7H98TnBck23YNozXDcK3g5c91QDMs2PC88wYJkcKvUsb0XbcH1resIMbScVSo9tGyg7sLQAgggJHLknRdccvR2MDm0o6dgxglC7wQ1dY3jYSd0MABPfcsJPM88IUy96WvSSyKfKc3xbWjAwYkA/3eftAMHYd7XY90uPAvSdyE28d0Q8TNxIkS0IYWSMIPI9lNw/DCxUksy3U6tyOfQNqI/XTvx3Qy%2B0OEyh2ArlQN9PibME0NJNEmN1wk%2ByU3cuTD2zfzfJ8wigvsjSKPC5saLbdLfx7Iz4pY0yksdd1OPdbjeP9RroMy/Ll0c3LnLg1z8QYARMCK7ycPPUqKuIib7xCzT%2BO0%2BqmwGxj/2MtrErYzrXR66zooy%2BcspGsSxuuqaZrmkrT3dRaXppVSiOCkxHxq18Iv%2BuiBKapiDtY8yLBS87INsoaXIc27kOGh6Qie7DSreotPsq%2BHqrCwH3wijg5loThRV4PwOC0UhUE4JNLGseEFiWB51h4UgCE0Ym5gAaxAUUElJjhJAprmac4XgFBABJOap4nSDgWAkEwVRXnnEhyEoepgAUZRDEqIQEFQAB3Sn2bQFhEjoJhqj1kJaENk3Kepi2rfoGJgB9MxSFduholCVgVl4X33YAeXnR3TbFlXXiuYgdYl0gY%2BQWp8Ep3h%2BEEEQxHYKQZEERQVHUOXSF0VoDCMFBrGsfQ8AiKXYGYNgVxSAhSBeGJuA5cmZjmVBEmqKWOAAWgRWVTAZywuC4HZh4AdVTWe55VghiCYSXmeWAY8WCO2DaNqPuF4VfMBWdnjbXxIuZJsnRZL2mOGwVXkHV4gdlUAAOWJh9iSQdmAZA5IfQADozDCnplYSw7pcCEBIHsb4XAZjH2vnMBApwsAxG1KQPmAt9CcBFqQZ2vAH6S2lhzFBeCOBmDvtTEh5C5a93btEVIzhJBAA%3D%3D}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Algorithmes - Comparaison}
	\begin{itemize}
		\item \lstinline|std::is_permutation()| teste si un ensemble est la permutation d'un autre
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{1, 4, 5, 9, 12};
vector<int> bar{1, 5, 4, 9, 12};
vector<int> baz{5, 4, 3, 9, 1};

is_permutation(begin(foo), end(foo), begin(bar)); // true
is_permutation(begin(foo), end(foo), begin(baz)); // false\end{lstlisting}

	\begin{itemize}
		\item Égalité des éléments mais pas de leur ordre
	\end{itemize}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:24,positionColumn:1,positionLineNumber:24,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%23include+%3Cvector%3E%0A%23include+%3Calgorithm%3E%0A%0Ausing+std::begin%3B%0Ausing+std::end%3B%0A%0Aint+main()%0A%7B%0A++%7B%0A++++std::vector%3Cint%3E+foo%7B1,+4,+5,+9,+12%7D%3B%0A++++std::vector%3Cint%3E+bar%7B5,+4,+12,+9,+1%7D%3B%0A%0A++++std::cout+%3C%3C+std::boolalpha+%3C%3C+std::is_permutation(begin(foo),+end(foo),+begin(bar))+%3C%3C+!'%5Cn!'%3B%0A++%7D%0A%0A++%7B%0A++++std::vector%3Cint%3E+foo%7B1,+4,+5,+9,+12%7D%3B%0A++++std::vector%3Cint%3E+bar%7B5,+4,+12,+7,+1%7D%3B%0A%0A++++std::cout+%3C%3C+std::boolalpha+%3C%3C+std::is_permutation(begin(foo),+end(foo),+begin(bar))+%3C%3C+!'%5Cn!'%3B%0A++%7D%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Algorithmes - Copie}
	\begin{itemize}
		\item \lstinline|std::copy_n()| copie les n premiers éléments d'un ensemble
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{1, 4, 5, 9, 12}, bar;

copy_n(begin(foo), 3, back_inserter(bar)); // 1 4 5\end{lstlisting}

	\begin{itemize}
		\item \lstinline|std::copy_if()| copie les éléments vérifiant un prédicat
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{1, 4, 5, 9, 12}, bar;

copy_if(begin(foo), end(foo), back_inserter(bar), is_odd);
// 1 5 9\end{lstlisting}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:39,positionColumn:1,positionLineNumber:39,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%23include+%3Cvector%3E%0A%23include+%3Calgorithm%3E%0A%0Ausing+std::begin%3B%0Ausing+std::end%3B%0A%0Astatic+bool+is_odd(int+i)%0A%7B%0A++return+(i%252)%3D%3D1%3B%0A%7D%0A%0Aint+main()%0A%7B%0A++std::vector%3Cint%3E+foo%7B1,+4,+5,+9,+12%7D%3B%0A%0A++%7B%0A++++std::vector%3Cint%3E+bar%3B%0A++++std::copy_n(begin(foo),+4,+std::back_inserter(bar))%3B%0A%0A++++for(size_t+i+%3D+0%3B+i+%3C+bar.size()%3B+%2B%2Bi)%0A++++%7B%0A++++++std::cout+%3C%3C+bar%5Bi%5D+%3C%3C+!'+!'%3B%0A++++%7D%0A++++std::cout+%3C%3C+!'%5Cn!'%3B%0A++%7D%0A%0A++%7B%0A++++std::vector%3Cint%3E+bar%3B%0A++++std::copy_if(begin(foo),+end(foo),+std::back_inserter(bar),+is_odd)%3B%0A%0A++++for(size_t+i+%3D+0%3B+i+%3C+bar.size()%3B+%2B%2Bi)%0A++++%7B%0A++++++std::cout+%3C%3C+bar%5Bi%5D+%3C%3C+!'+!'%3B%0A++++%7D%0A++++std::cout+%3C%3C+!'%5Cn!'%3B%0A++%7D%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Algorithmes - Déplacement}
	\begin{itemize}
		\item \lstinline|std::move()| déplace les éléments d'un ensemble du début vers la fin
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{4, 5, 9, 12};
vector<int> bar;

move(begin(foo), end(foo), back_inserter(bar));\end{lstlisting}

	\begin{itemize}
		\item \lstinline|std::move_backward()| déplace les éléments de la fin vers le début
		\item Versions \og déplacement\fg{} de \lstinline|std::copy()| et \lstinline|std::copy_backward()|
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Algorithmes - Partitionnement}
	\begin{itemize}
		\item \lstinline|std::is_partitioned()| indique si un ensemble est partitionné, c'est à dire si les éléments vérifiant un prédicat sont avant ceux ne le vérifiant pas
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{4, 5, 9, 12};
vector<int> bar{9, 5, 4, 12};

is_partitioned(begin(foo), end(foo), is_odd); // false
is_partitioned(begin(bar), end(bar), is_odd); // true\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Algorithmes - Partitionnement}
	\begin{itemize}
		\item \lstinline|std::partition_copy()| copie l'ensemble en le partitionnant
		\item \lstinline|std::partition_point()| retourne le point de partition d'un ensemble partitionné, c'est à dire le premier élément ne vérifiant pas le prédicat
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{9, 5, 4, 12};

partition_point(begin(foo), end(foo), is_odd); // 4\end{lstlisting}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:33,positionColumn:1,positionLineNumber:33,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%23include+%3Cvector%3E%0A%23include+%3Calgorithm%3E%0A%0Ausing+std::begin%3B%0Ausing+std::end%3B%0A%0Astatic+bool+is_odd(int+i)%0A%7B%0A++return+(i%252)%3D%3D1%3B%0A%7D%0A%0Aint+main()%0A%7B%0A++%7B%0A++++std::vector%3Cint%3E+foo%7B4,+5,+9,+12%7D%3B%0A%0A++++std::cout+%3C%3C+std::boolalpha+%3C%3C+std::is_partitioned(begin(foo),+end(foo),+is_odd)+%3C%3C+!'%5Cn!'%3B%0A++%7D%0A%0A++%7B%0A++++std::vector%3Cint%3E+foo%7B9,+5,+4,+12%7D%3B%0A%0A++++std::cout+%3C%3C+std::boolalpha+%3C%3C+std::is_partitioned(begin(foo),+end(foo),+is_odd)+%3C%3C+!'%5Cn!'%3B%0A++%7D%0A%0A++%7B%0A++++std::vector%3Cint%3E+foo%7B9,+5,+4,+12%7D%3B%0A%0A++++std::cout+%3C%3C+*std::partition_point(begin(foo),+end(foo),+is_odd)+%3C%3C+!'%5Cn!'%3B%0A++%7D%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Algorithmes - Tri}
	\begin{itemize}
		\item \lstinline|std::is_sorted()| indique si l'ensemble est ordonnée (ascendant)
	\end{itemize}

\note[item]{Possibilité de fournir un foncteur de comparaison (\lstinline|<| par défaut)}

	\begin{lstlisting}[language=C++]
vector<int> foo{4, 5, 9, 12};
vector<int> bar{9, 5, 4, 12};

is_sorted(begin(foo), end(foo)); // true
is_sorted(begin(bar), end(bar)); // false\end{lstlisting}

	\begin{itemize}
		\item \lstinline|std::is_sorted_until()| détermine le premier élément mal placé
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{4, 5, 9, 3, 12};

is_sorted_until(begin(foo), end(foo)); // 3\end{lstlisting}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:28,positionColumn:1,positionLineNumber:28,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%23include+%3Cvector%3E%0A%23include+%3Calgorithm%3E%0A%0Ausing+std::begin%3B%0Ausing+std::end%3B%0A%0Aint+main()%0A%7B%0A++%7B%0A++++std::vector%3Cint%3E+foo%7B4,+5,+9,+12%7D%3B%0A%0A++++std::cout+%3C%3C+std::boolalpha+%3C%3C+std::is_sorted(begin(foo),+end(foo))+%3C%3C+!'%5Cn!'%3B%0A++%7D%0A%0A++%7B%0A++++std::vector%3Cint%3E+foo%7B9,+5,+4,+12%7D%3B%0A%0A++++std::cout+%3C%3C+std::boolalpha+%3C%3C+std::is_sorted(begin(foo),+end(foo))+%3C%3C+!'%5Cn!'%3B%0A++%7D%0A%0A++%7B%0A++++std::vector%3Cint%3E+foo%7B4,+5,+2,+12%7D%3B%0A%0A++++std::cout+%3C%3C+*std::is_sorted_until(begin(foo),+end(foo))+%3C%3C+!'%5Cn!'%3B%0A++%7D%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Algorithmes - Mélange}
	\begin{itemize}
		\item \lstinline|std::shuffle()| mélange l'ensemble grâce à un générateur de nombre aléatoire uniforme
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{4, 5, 9, 12};
unsigned seed = now().time_since_epoch().count();

shuffle(begin(foo), end(foo), default_random_engine(seed));\end{lstlisting}

\note[item]{Générateurs de nombre aléatoire correspondant vus plus tard}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:22,positionColumn:1,positionLineNumber:22,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%23include+%3Cvector%3E%0A%23include+%3Calgorithm%3E%0A%23include+%3Cchrono%3E%0A%23include+%3Crandom%3E%0A%0Ausing+std::begin%3B%0Ausing+std::end%3B%0A%0Aint+main()%0A%7B%0A++std::vector%3Cint%3E+foo%7B4,+5,+9,+12%7D%3B%0A++unsigned+seed+%3D+std::chrono::system_clock::now().time_since_epoch().count()%3B%0A%0A++std::shuffle(begin(foo),+end(foo),+std::default_random_engine(seed))%3B%0A++for(size_t+i+%3D+0%3B+i+%3C+foo.size()%3B+%2B%2Bi)%0A++%7B%0A++++std::cout+%3C%3C+foo%5Bi%5D+%3C%3C+!'+!'%3B%0A++%7D%0A++std::cout+%3C%3C+!'%5Cn!'%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Algorithmes - Gestion de tas}
	\begin{itemize}
		\item \lstinline|std::is_heap()| indique si l'ensemble forme un tas
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{4, 5, 9, 3, 12};

is_heap(begin(foo), end(foo));  // false
make_heap(begin(foo), end(foo));
is_heap(begin(foo), end(foo));  // true\end{lstlisting}

	\begin{itemize}
		\item \lstinline|std::is_heap_until()| indique le premier élément qui n'est pas dans la position correspondant à un tas 
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Algorithmes - Min-max}
	\begin{itemize}
		\item \lstinline|std::minmax()| retourne la paire constituée du plus petit et du plus grand de deux éléments
	\end{itemize}

	\begin{lstlisting}[language=C++]
minmax(5, 2); // 2 - 5\end{lstlisting}

	\begin{itemize}
		\item \lstinline|std::minmax_element()| retourne la paire constituée des itérateurs sur le plus petit et le plus grand élément d'un ensemble
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo{18, 5, 6, 8};

minmax_element(foo.begin(), foo.end()); // 5 - 18\end{lstlisting}

\note[item]{La fonction de comparaison est configurable (< par défaut)}
\note[item]{Combinaison des fonctions min et max en un seul parcours}
\note[item]{Optimisation classique de recherche de min et max en un seul parcours}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:16,positionColumn:1,positionLineNumber:16,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%23include+%3Cvector%3E%0A%23include+%3Calgorithm%3E%0A%23include+%3Cutility%3E%0A%0Ausing+std::begin%3B%0Ausing+std::end%3B%0A%0Aint+main()%0A%7B%0A++std::vector%3Cint%3E+foo%7B18,+5,+6,+8%7D%3B%0A++auto+p+%3D+std::minmax_element(begin(foo),+end(foo))%3B%0A%0A++std::cout+%3C%3C+*(p.first)+%3C%3C+%22+%22+%3C%3C+*(p.second)+%3C%3C+%22%5Cn%22%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Algorithmes - Numérique}
	\begin{itemize}
		\item \lstinline|std::iota()| affecte des valeurs successives aux éléments d'un ensemble
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<int> foo(5);

iota(begin(foo), end(foo), 50); // 50 51 52 53 54\end{lstlisting}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:19,positionColumn:1,positionLineNumber:19,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%23include+%3Cvector%3E%0A%23include+%3Cnumeric%3E%0A%0Ausing+std::begin%3B%0Ausing+std::end%3B%0A%0Aint+main()%0A%7B%0A++std::vector%3Cint%3E+foo(5)%3B%0A++%0A++std::iota(begin(foo),+end(foo),+50)%3B%0A++for(size_t+i+%3D+0%3B+i+%3C+foo.size()%3B+%2B%2Bi)%0A++%7B%0A++++std::cout+%3C%3C+foo%5Bi%5D+%3C%3C+!'+!'%3B%0A++%7D%0A++std::cout+%3C%3C+!'%5Cn!'%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Algorithmes - Conclusion}
	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Continuez à suivre les règles C++98/03 à propos des algorithmes
		\end{itemize}
	\end{exampleblock}

	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Privilégiez la sémantique lorsque plusieurs algorithmes sont utilisables
		\end{itemize}
	\end{exampleblock}
\end{frame}

\subsection*{Range-based for loop}
\begin{frame}[fragile]
	\frametitle{Range-based for loop}
	\begin{itemize}
		\item Itération sur un \og conteneur\fg{} complet

	\begin{lstlisting}
vector<int> foo{4, 8, 12, 37};
for(int var : foo)
  cout << var << " ";    // Affiche 4 8 12 37\end{lstlisting}

		\item Compatible avec \lstinline|auto|

	\begin{lstlisting}
vector<int> foo{4, 8, 12, 37};
for(auto var : foo)
  cout << var << " ";    // Idem\end{lstlisting}

		\item Utilisable sur tout conteneur
		\begin{itemize}
			\item Exposant \lstinline|begin()| et \lstinline|end()|
			\item Utilisable avec \lstinline|std::begin()| et \lstinline|std::end()|
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Range-based for loop}
	\begin{alertblock}{Modification des éléments}
		\begin{itemize}
			\item La variable d'itération doit être une référence
		\end{itemize}
	\end{alertblock}

	\begin{lstlisting}
vector<int> foo(4);

for(auto& var : foo)
  var = 5;    // foo : 5 5 5 5\end{lstlisting}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1DIApACYAQuYukl9ZATwDKjdAGFUtAK4sGe1wAyeAyYAHI%2BAEaYxCAAzADspAAOqAqETgwe3r56KWmOAkEh4SxRMQm2mPYFDEIETMQEWT5%2BXJXVGXUNBEVhkdF6CvWNzTltQ929JWUSAJS2qF7EyOwc5rHByN5YANQmsW5OQ8SYrPvYJhoAguub25h7BwBumA4k55c318EEOyxMwQgs0%2BJniVmuOz2YM%2BkMhQ3QIBALzexH2h0E5x2/FQoIs0h2AA5SDsuGZiQlQQARfbgq6wrEkCA/HZPBo7EAM1DAiGw3Ew%2Bk7eGItBeX5otEstnig47MAcWVrWK0%2BlU/lwggIlCLMUHCVykwAVjcDH1Sv5quu5uhPPVmuRRFRBx%2BmOxuPxRJJZJ2FPi1LNNoZxAgTFFqElxHZnO5dN51pj9KFWtFjzcEtZEelbgVCppaqh1IDiZFOtTMv1RpNiuV%2BZBPL5hY1iPt7ydGNi2E5EEkwP98cDwdD5gAbOHI9joyq4wLR/tKTsDbmAxa%2B/wgyGiKOOeO8/W%2B7bhdqU2mpbqy/LTdXIcuE42kyW9WsKxerQWbr7Phx5rROAbeH4OFopCoJwqaWNYgqLMsDzrDwpAEJon7zAA1iABoaPonCSH%2BCFAZwvAKCA6HwQBn6kHAsBIJgqivKGZAUMGxDAAoyiGFUQgIKgADu/6wWgLBJHQTA1CxIS0OxXH/oBfECfQMTAKSZLSXQ0ShKwqy8EpskAPKiuJ3E4VRrxXIxBEcLwhnIHU%2BD/rw/CCCIYjsFIMiCIoKjqCRpC6G0BhGCg1jWPoeARARsDMGwIARKgqQEKQLwxNw8S/rM8yoEkNSmQAtPCs6mGBlhcFwOyZQA6mItDFSVVEEMQTD4ZBKyDBqwQiWxHH6dwvA1ZgqywZxtVJAhX4/thnnARw2DUcgtE7KoBJDplQ6SDswDIMgnoAHRmDsECgVYljErghAkHsZixFwsxdUN8wIKcWAxECpAoWhGEcFhpCSbw434YRcHXa9ZijYB31/SRKVxdEaTOJIQA%3D%3D%3D}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}
	\frametitle{Range-based for loop}
	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Préférez \textit{range-based for loop} aux boucles classiques et à \lstinline|std::for_each()|
		\end{itemize}
	\end{exampleblock}

\note[item]{\lstinline|std::for_each()| n'a plus d'intérêt en C++11 mais redevient utile en C++17 avec les politiques d'exécution parallélisées}

	\begin{block}{Conseils}
		\begin{itemize}
			\item Contrairement à \lstinline|for|, l'indice de l'itération n'est pas disponible
			\item Malgré tout, préférez la \textit{range-based for loop} avec un indice externe à \lstinline|for|
		\end{itemize}
	\end{block}

	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Utilisez l'inférence de type sur la variable d'itération
		\end{itemize}
	\end{exampleblock}
\end{frame}

\subsection*{string et conversions}
\begin{frame}[fragile]
	\frametitle{\lstinline|std::string| \& conversions}
	\begin{itemize}
		\item Fonctions de conversion d'une chaîne de caractères en un nombre
		\begin{itemize}
			\item \lstinline|std::stoi()| vers \lstinline|int|
			\item \lstinline|std::stol()| vers \lstinline|long|
			\item \lstinline|std::stoul()| vers \lstinline|unsigned long|
			\item \lstinline|std::stoll()| vers \lstinline|long long|
			\item \lstinline|std::stoull()| vers \lstinline|unsigned long long|
			\item \lstinline|std::stof()| vers \lstinline|float|
			\item \lstinline|std::stod()| vers \lstinline|double|
			\item \lstinline|std::stold()| vers \lstinline|long double|
		\end{itemize}
	\end{itemize}

	\begin{lstlisting}
stoi("56"); // 56\end{lstlisting}

	\begin{itemize}
		\item S'arrêtent sur le premier caractère non convertible
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{\lstinline|std::string| \& conversions}
	\begin{itemize}
		\item \lstinline|std::to_string()| convertit d'un nombre en une chaîne de caractères
	\end{itemize}

	\begin{lstlisting}
to_string(56); // "56"\end{lstlisting}

	\begin{itemize}
		\item \lstinline|std::to_wstring()| convertit vers une chaîne de caractères larges
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{\lstinline|std::string| \& conversions}
	\begin{alertblock}{Attention}
		\begin{itemize}
			\item Pas de fonction \lstinline|std::stoui()| de conversion vers un \lstinline|unsigned int|
		\end{itemize}
	\end{alertblock}

	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Préférez \lstinline|std::sto...()| à \lstinline|sscanf()|, \lstinline|atoi()| ou \lstinline|strto...()|
		\end{itemize}
	\end{exampleblock}

	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Préférez \lstinline|std::to_string()| à \lstinline|snprintf()| ou \lstinline|itoa()|
		\end{itemize}
	\end{exampleblock}

	\begin{block}{Alternative et complément}
		\begin{itemize}
			\item Boost.Lexical\_cast permet de telles conversions et quelques autres
		\end{itemize}
	\end{block}
\end{frame}

\subsection*{string UTF}
\begin{frame}[fragile]
	\frametitle{Chaînes de caractères UTF}
	\begin{itemize}
		\item \lstinline|char| doit pouvoir contenir un encodage 8 bits UTF-8

\note[item]{Pas de garantie en C++98/03, implémentation-defined}

		\item \lstinline|char16_t| représente un code point 16 bits
		\item \lstinline|char32_t| représente un code point 32 bits
		\item \lstinline|std::u16string| spécialisation de \lstinline|basic_string| pour caractères 16 bits
		\item \lstinline|std::u32string| spécialisation de \lstinline|basic_string| pour caractères 32 bits
		\item Même interface que \lstinline|std::string|
	\end{itemize}
\end{frame}

\subsection*{string literals}
\begin{frame}[fragile]
	\frametitle{Nouvelles chaînes littérales}
	\begin{itemize}
		\item Chaînes littérales UTF-8, UTF-16 et UTF32
	\end{itemize}

	\begin{lstlisting}[language=C++]
string u8str     = u8"UTF-8 string.";
u16string u16str = u"UTF-16 string.";
u32string u32str = U"UTF-32 string.";\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Nouvelles chaînes littérales}
	\begin{itemize}
		\item Chaînes littérales brutes (sans interprétation des échappements)

\note[item]{Utilité pour écrire des expressions rationnelles, des commandes shell ou autres qui ont aussi leurs échappements}

		\begin{itemize}
			\item Préfixées par \lstinline|R|
			\item Encadrées par une paire de parenthèses
			\item Éventuellement complétées d'un délimiteur
		\end{itemize}
	\end{itemize}

	\begin{lstlisting}[language=C++]
// Affiche Message\n en une seule \n ligne
cout << R"(Message\n en une seule \n ligne)";
cout << R"--(Message\n en une seule \n ligne)--";\end{lstlisting}

	\begin{itemize}
		\item Composition possible des deux type de chaînes littérales
	\end{itemize}

	\begin{lstlisting}[language=C++]
u8R"(Message\n en une seule \n ligne)";\end{lstlisting}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:9,positionColumn:1,positionLineNumber:9,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%0Aint+main()%0A%7B%0A++std::cout+%3C%3C+R%22(Message%5Cn+en+une+seule+%5Cn+ligne)%22+%3C%3C+!'%5Cn!'%3B%0A++std::cout+%3C%3C+R%22--(Message%5Cn+en+une+seule+%5Cn+ligne)--%22+%3C%3C+!'%5Cn!'%3B%0A++std::cout+%3C%3C+u8R%22(Message%5Cn+en+une+seule+%5Cn+ligne)%22+%3C%3C+!'%5Cn!'%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\subsection*{User-defined literals}
\begin{frame}[fragile]
	\frametitle{User-defined literals}
	\begin{itemize}
		\item Possibilité de définir des littéraux \og utilisateur\fg{}
		\item Nombre (entier ou réel), caractère ou chaîne suffixé par un identifiant
		\item Identifiants non standards préfixés par \lstinline|_|

\note[item]{Les identifiants non préfixés sont réservé pour le standard}

		\item Définit via \lstinline|operator""suffixe|
	\end{itemize}

	\begin{lstlisting}[language=C++]
class Foo {
public: explicit Foo(int a) : m_a{a} {}
private : int m_a; };

Foo operator""_f(unsigned long long int a) {
  return Foo(a); }

Foo foo = 12;   // Erreur compilation
Foo bar = 12_f; // OK\end{lstlisting}

\note[item]{L'erreur de compilation peut ici tout simplement être corrigée en utilisant l'initialisation via \{\}, mais c'est pour l'exemple}
\end{frame}

\begin{frame}[fragile]
	\frametitle{User-defined literals}
	\begin{itemize}
		\item Littéraux brutes : chaîne C entièrement analysée par l'opérateur
	\end{itemize}
	
\begin{lstlisting}[language=C++]
Foo operator""_b(const char* str) {
  unsigned long long a = 0;
  for(size_t i = 0; str[i]; ++i)
    a = (a * 2) + (str[i] - '0');
  return Foo(a); }

Foo foo = 0110_b;  // 6\end{lstlisting}

	\begin{alertblock}{Restrictions}
		\begin{itemize}
			\item Uniquement pour les littéraux numériques
		\end{itemize}
	\end{alertblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{User-defined literals}
	\begin{itemize}
		\item Littéraux \og préparés\fg{} par le compilateur
		\begin{itemize}
			\item Littéraux entiers : \lstinline|unsigned long long int|
			\item Littéraux réels : \lstinline|long double|
			\item Littéraux caractères : \lstinline|char|, \lstinline|wchar_t|, \lstinline|char16_t| ou \lstinline|char32_t|
			\item Chaînes littérales : couple pointeur sur caractères et \lstinline|size_t|
		\end{itemize}
	\end{itemize}

	\begin{block}{Motivations}
		\begin{itemize}
			\item Pas de conversion implicite
			\item Expressivité

\note[item]{Exemple d'expressivité : des classes de \og quantité\fg{} avec des \textit{user-defined literals} pour les unités}
		\end{itemize}
	\end{block}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:63,positionColumn:1,positionLineNumber:63,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%23include+%3Cstring%3E%0A%0Aclass+Foo%0A%7B%0Apublic:%0A++explicit+Foo(int+a)%0A++++:+m_a%7Ba%7D%0A++%7B%7D%0A%0A++void+print()%0A++%7B%0A++++std::cout+%3C%3C+m_a+%3C%3C+!'%5Cn!'%3B%0A++%7D%0A%0Aprivate+:%0A++int+m_a%3B%0A%7D%3B%0A%0Astatic+Foo+operator+%22%22+_f(unsigned+long+long+int+a)%0A%7B%0A++return+Foo(a)%3B%0A%7D%0A%0Astatic+Foo+operator%22%22_f(const+char*+str,+size_t+/*+length+*/)%0A%7B%0A++return+Foo(std::stoull(str))%3B%0A%7D%0A%0Astatic+Foo+operator%22%22_b(const+char*+str)%0A%7B%0A++unsigned+long+long+a+%3D+0%3B%0A++for(size_t+i+%3D+0%3B+str%5Bi%5D%3B+%2B%2Bi)%0A++%7B%0A++++a+%3D+(a+*+2)+%2B+(str%5Bi%5D+-+!'0!')%3B%0A++%7D%0A++return+Foo(a)%3B%0A%7D%0A%0Aint+main()%0A%7B%0A++%7B%0A%23if+0%0A++++Foo+foo1+%3D+12%3B%0A%23endif%0A++%7D%0A%0A++%7B%0A++++Foo+foo+%3D+42_f%3B%0A++++foo.print()%3B%0A++%7D%0A%0A++%7B%0A++++Foo+foo+%3D+%2212%22_f%3B%0A++++foo.print()%3B%0A++%7D%0A%0A++%7B%0A++++Foo+foo+%3D+0110_b%3B%0A++++foo.print()%3B%0A++%7D%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\subsection*{tuple}
\begin{frame}[fragile]
	\frametitle{\lstinline|std::tuple|}
	\begin{itemize}
		\item Collection d'objets de type divers
		\item Généralisation de \lstinline|std::pair|
	\end{itemize}

	\begin{lstlisting}[language=C++]
tuple<int, char, long> foo;\end{lstlisting}

	\begin{itemize}
		\item \lstinline|std::make_tuple()| construit un \lstinline|std::tuple|
	\end{itemize}

	\begin{lstlisting}[language=C++]
tuple<int, char, long> foo = make_tuple(5, 'e', 98L);\end{lstlisting}

	\begin{block}{\lstinline|std::make_tuple| ou constructeur ?}
		\lstinline|std::make_tuple()| permet la déduction de types, pas le constructeur

		\begin{lstlisting}[language=C++]
auto foo{5, 'e', 98L};              // KO
auto bar = make_tuple(5, 'e', 98L); // OK\end{lstlisting}
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{\lstinline|std::tuple|}
	\begin{itemize}
		\item Fonction de déstructuration : \lstinline|std::tie()|
		\item Et une constante pour ignorer des éléments : \lstinline|std::ignore|
	\end{itemize}

	\begin{lstlisting}[language=C++]
int a; long b;
tie(a, ignore, b) = foo;\end{lstlisting}

\note[item]{C++17 introduit les \textit{structured binding} qui améliore grandement la déstructuration en proposant une syntaxe plus simple et claire}

	\begin{itemize}
		\item \lstinline|std::get<>()| accède aux éléments du \lstinline|std::tuple| par l'indice
	\end{itemize}

	\begin{lstlisting}[language=C++]
char c = get<1>(foo);\end{lstlisting}

	\begin{alertblock}{Attention}
		\begin{itemize}
			\item Les indices commencent à 0
		\end{itemize}
	\end{alertblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{\lstinline|std::tuple|}
	\begin{itemize}
		\item \lstinline|std::tuple_cat()| concatène deux \lstinline|std::tuple|
	\end{itemize}

	\begin{lstlisting}[language=C++]
auto foo = make_tuple(5, 'e');
auto bar = make_tuple(98L, 'r');
auto baz = tuple_cat(foo, bar); // 5 'e' 98L 'r'\end{lstlisting}

	\begin{itemize}
		\item Classe représentant la taille : \lstinline|std::tuple_size|
	\end{itemize}

	\begin{lstlisting}[language=C++]
tuple_size<decltype(baz)>::value;  // 4\end{lstlisting}

	\begin{itemize}
		\item Classe représentant le type des éléments : \lstinline|std::tuple_element|
	\end{itemize}

	\begin{lstlisting}[language=C++]
tuple_element<0, decltype(baz)>::type first;  // int\end{lstlisting}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:23,positionColumn:1,positionLineNumber:23,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%23include+%3Cstring%3E%0A%23include+%3Ctuple%3E%0A%0Aint+main()%0A%7B%0A++std::tuple%3Cint,+std::string,+double%3E+foo+%3D+std::make_tuple(42,+%22FOO%22,+25.2)%3B%0A%0A++int+a%3B%0A++double+b%3B%0A%0A++std::tie(a,+std::ignore,+b)+%3D+foo%3B%0A++std::cout+%3C%3C+a+%3C%3C+!'+!'+%3C%3C+b+%3C%3C+!'%5Cn!'%3B%0A%0A++std::string+c+%3D+std::get%3C1%3E(foo)%3B%0A++std::cout+%3C%3C+c+%3C%3C+!'%5Cn!'%3B%0A%0A++auto+bar+%3D+std::make_tuple(12,+5UL)%3B%0A++auto+baz+%3D+std::tuple_cat(foo,+bar)%3B%0A%0A++std::cout+%3C%3C+std::tuple_size%3Cdecltype(baz)%3E::value+%3C%3C+!'%5Cn!'%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{\lstinline|std::tuple|}
	\begin{alertblock}{Don't}
		\begin{itemize}
			\item N'utilisez pas \lstinline|std::tuple| pour remplacer une structure
			\item \lstinline|std::tuple| regroupe localement des éléments sans lien sémantique
		\end{itemize}
	\end{alertblock}

	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Préférez un \lstinline|std::tuple| de retour aux paramètres OUT
		\end{itemize}
	\end{exampleblock}
\end{frame}

\subsection*{fstream}
\begin{frame}[fragile]
	\frametitle{Constructeurs de \lstinline|fstream|}
	\begin{itemize}
		\item Construction depuis des \lstinline|std::string|
	\end{itemize}

	\begin{lstlisting}[language=C++]
string filename{"foo.txt"};

// C++ 98
ofstream file(filename.c_str());

// C++ 11
ofstream file{filename};\end{lstlisting}
\end{frame}

\subsection*{Classes}
\begin{frame}[fragile]
	\frametitle{\lstinline|=default| \& \lstinline|=delete|}
	\begin{itemize}
		\item Applicables aux fonctions générées implicitement le compilateur
		\begin{itemize}
			\item Constructeur par défaut, par copie et par déplacement
			\item Destructeur
			\item Opérateur d'affectation
			\item Opérateur d'affectation par déplacement
		\end{itemize}
		\item \lstinline|=default| force le compilateur à générer l'implémentation triviale
		\item \lstinline|=delete| désactive la génération implicite de la fonction
		\item \lstinline|=delete| peut aussi s'appliquer aux fonctions héritées pour les supprimer
	\end{itemize}

	\begin{lstlisting}[language=C++]
class Foo {
  public: Foo(int) {}
  public: Foo() = default;

  private: Foo(const Foo&) = delete;
  private: Foo& operator=(const Foo&) = delete; };\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{\lstinline|=default| \& \lstinline|=delete|}
	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Préférez \lstinline|=default| à une implémentation manuelle avec le même effet
		\end{itemize}
	\end{exampleblock}

	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Préférez \lstinline|=delete| à une déclaration privée sans définition
		\end{itemize}
	\end{exampleblock}

	\begin{block}{\lstinline|=default| ou non définition ?}
		\begin{itemize}
			\item Consensus plutôt du côté de la non-définition
			\item Intérêt documentaire réel à \lstinline|=default|
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Initialisation par défaut des membres}
	\begin{itemize}
		\item Initialisation des membres lors de la déclaration
	\end{itemize}

	\begin{lstlisting}[language=C++]
struct Foo {
  Foo() {}
  int m_a{2}; };\end{lstlisting}

	\begin{alertblock}{Restriction}
		\begin{itemize}
			\item Pas d'initialisation avec \lstinline|()|
			\item Initialisation avec \lstinline|=| uniquement sur des types copiables
		\end{itemize}
	\end{alertblock}

	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Préférez l'initialisation des membres à l'initialisation par constructeurs pour les initialisations avec une valeur connue à la compilation
		\end{itemize}

\note[item]{Y compris pour les valeurs \og par défaut\fg{} modifiées dans seulement une petite partie des constructeurs}
	\end{exampleblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Délégation de constructeur}
	\begin{itemize}
		\item Utilisation d'un constructeur dans l'implémentation d'un second
		\item \ldots{} en \og l'initialisant\fg{} dans la liste d'initialisation
	\end{itemize}

	\begin{lstlisting}[language=C++]
struct Foo {
  Foo(int a) : m_a(a) {}
  Foo() : Foo(2) {}
  int m_a; };\end{lstlisting}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:33,positionColumn:1,positionLineNumber:33,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%0Aclass+Foo%0A%7B%0Apublic:%0A++Foo(int+a)%0A++++:+m_a(a)%0A++%7B%0A++%7D%0A%0A++Foo()%0A++++:+Foo(2)%0A++%7B%0A++%7D%0A%0A++void+print()%0A++%7B%0A++++std::cout+%3C%3C+m_a+%3C%3C+!'%5Cn!'%3B%0A++%7D%0A%0Aprivate:%0A++int+m_a%3B%0A%7D%3B%0A%0Aint+main()%0A%7B%0A++Foo+foo(4)%3B%0A++Foo+bar%3B%0A%0A++foo.print()%3B%0A++bar.print()%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Délégation de constructeur}
	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Utilisez la délégation de constructeur pour mutualiser le code commun
		\end{itemize}
	\end{exampleblock}

	\begin{alertblock}{Don't}
		\begin{itemize}
			\item Évitez la délégation pour l'initialisation constante de membres
			\item Préférez l'initialisation par défaut des membres
		\end{itemize}
	\end{alertblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Héritage de constructeur}
	\begin{itemize}
		\item Indique que la classe hérite des constructeurs de la classe mère
		\item Génération du constructeur correspondant par le compilateur
		\begin{itemize}
			\item Paramètres du constructeur de base
			\item Appelle le constructeur de base correspondant
			\item Initialise les membres sans fournir de paramètres

\note[item]{Donc initialisation d'attribut si présente, sinon constructeur par défaut (ou non initialisation pour \lstinline|int|, pointeur, \ldots) et erreur si un membre ne peut pas être construit}
		\end{itemize}
	\end{itemize}

	\begin{lstlisting}[language=C++]
struct Foo {
  Foo() {}
  Foo(int a) : m_a(a) {}
  int m_a{2}; };

struct Bar : Foo {
  using Foo::Foo; };\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Héritage de constructeur}
	\begin{itemize}
		\item Redéfinition possible dans la classe dérivée
	\end{itemize}

	\begin{lstlisting}[language=C++]
struct Bar : Foo {
  using Foo::Foo;
  Bar() : Foo(5) {}};\end{lstlisting}

	\begin{alertblock}{Valeurs par défaut}
		\begin{itemize}
			\item Génération de toutes les combinaisons de constructeurs sans valeur par défaut correspondantes au constructeur de base avec des valeurs par défaut
		\end{itemize}

\note[item]{Ainsi \lstinline|Foo(int, int = 2)| va injecter \lstinline|Bar(int)| et \lstinline|Bar(int, int)|}
	\end{alertblock}

	\begin{alertblock}{Héritage multiple}
		\begin{itemize}
			\item Héritage impossible de deux constructeurs avec la même signature
		\end{itemize}
	\end{alertblock}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1DIApACYAQuYukl9ZATwDKjdAGFUtAK4sGe1wAyeAyYAHI%2BAEaYxCAAbGakAA6oCoRODB7evnrJqY4CQSHhLFEx8baY9vkMQgRMxASZPn5cFVXptfUEhWGR0XoKdQ1N2a2DXT3FpRIAlLaoXsTI7BzmAMzByN5YANQma25Og8SYrPvYJhoAguub25h7B8fBwOeXN9fHXg47AGKoqHeJgA7FZrjs/gCIMECDsmDN3hCISAdiwAPpMCDwxF7UE4kEAESB4MhqAgaAYgx2g3QIBAzyM5li1IIxARJORqIxEBpdMGqDwPNZM3ZVwhILBYtxROuOJhXKY%2B0lhKVxKuXx%2BFnqOxR/0BsrxJK8qSMpLpetVsoNRLWys%2BrO%2BsK1AC8daSgYapcaXmaQBbbWqIS7yQIqbz6ayXkyWWycZy9RANKKkTtSFzjkLYySJfjgTKPgWIeGGcB06zLTc8xX3vKWExghBRTns56U3qdvwyZIEQGOaSdhF6hBzGZJGYRz27VKiwRaSgFrD9m4lx2AQA6dFMR7Lg47MAcPcHpcrwfEDcY7cr/cmACsbgY197UpVVufraRWuIq67k7jO0/A5DiOY4TtWfbhmgXiLgcK6dueW7Hru%2B6Hpeu6nvBqFuIet73o%2BkrilWr4EfhH5MK6nYQN2FYpi6gHEMOZijuOjG/kRSIQQumHfhhiFYchyG8XRPEwUhB6PjuWHoeixyYded4PqsT4EfmL5XBwcy0JwN68H4HBaKQqCcMuljWNSCxLA86w8KQBCaOpcwANYgDeGj6Jwkg6XZBmcLwCggK5tl6eppBwLASCYKomDIFBJDkJQ9TAAoyiGJUQgIKgADuunWWgLCJHQTDVMlIS0GlmW6fpuX5fQMTAFwjGkFVdDRKErArLwTU1QA8lBZVZV5EVRVcxCJT5pCDcgtT4LpvD8IIIhiOwUgyIIigqOoQWkLorQGEYKDWNY%2Bh4BEfmwMwbAgBEAKDKQABu/TcMC2kigZiTVH5HAALQ0vsBKmCZlhcFwOyfQA6mItAg6DEWskwvnmcsAyzsExWpel/XcLwrKYCs1kZcQTCJHZGlaZ5m2GRw2CRdFRBfqoAAcsSfbEkg7MAyDIDs9VrmYOwQMZViWGmuCECQexmGsXAzFjxNzAgpxYDEjakE5LluRwHmkBVvAU75/k2bL6tmGT%2Bm6wbQUvfdxCpM4khAA}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{\lstinline|override|}
	\begin{itemize}
		\item Indique la redéfinition d'une fonction d'une classe de base
	\end{itemize}

	\begin{lstlisting}[language=C++]
struct Foo {
  Foo() {}
  virtual void f(int); };

struct Bar : Foo {
  Bar() {}
  virtual void f(int) override; };\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{\lstinline|override|}
	\begin{itemize}
		\item Provoque une erreur de compilation si la fonction n'existe pas dans la classe de base ou n'est pas virtuelle
	\end{itemize}

	\begin{lstlisting}[language=C++]
struct Foo {
  Foo() {}
  virtual void f(int); 
  virtual void g(int) const;
  void h(int); };

struct Bar : Foo {
  Bar() {}
  void f(float) override;   // Erreur 
  void g(int) override;     // Erreur
  void h(int) override; };  // Erreur\end{lstlisting}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:49,positionColumn:1,positionLineNumber:49,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%23include+%3Cstring%3E%0A%0Astruct+Foo%0A%7B%0A++Foo()%0A++%7B%0A++%7D%0A%0A++virtual+void+f(int)%0A++%7B%0A++%7D%0A%0A++virtual+void+g(int)+const%0A++%7B%0A++%7D%0A%0A++void+h(int)%0A++%7B%0A++%7D%0A%7D%3B%0A%0Astruct+Bar+:+Foo%0A%7B%0A++Bar()%0A++%7B%0A++%7D%0A%0A++void+f(float)+override%0A++%7B%0A++%7D%0A%0A++void+g(int)+override%0A++%7B%0A++%7D%0A%0A++void+h(int)+override%0A++%7B%0A++%7D%0A%0A++void+i(int)+override%0A++%7B%0A++%7D%0A%7D%3B%0A%0Aint+main()%0A%7B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{\lstinline|override|}
	\begin{block}{Objectifs}
		\begin{itemize}
			\item Documentaire
			\item Détection des non-reports de modifications lors d'un refactoring
			\item Détection des redéfinitions involontaires
		\end{itemize}
	\end{block}

	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Marquez \lstinline|override| les fonctions que vous redéfinissez
		\end{itemize}
	\end{exampleblock}

	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Utilisez \lstinline|virtual| à la base de l'arbre d'héritage
			\item Utilisez \lstinline|override| sur les redéfinitions
		\end{itemize}

\note[item]{Si une fonction est virtuelle, toutes ces redéfinitions le sont qu'elles soient ou non marquées comme tel}
	\end{exampleblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{\lstinline|final|}
	\begin{itemize}
		\item Indique qu'une classe ne peut pas être dérivée
	\end{itemize}

	\begin{lstlisting}[language=C++]
struct Foo final {
  virtual void f(int); };

struct Bar : Foo {   // Erreur
  void f(int); };
\end{lstlisting}

	\begin{itemize}
		\item Aussi bien via l'héritage public que privé
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{\lstinline|final|}
	\begin{itemize}
		\item Ou qu'une fonction ne peut plus être redéfinie
	\end{itemize}

	\begin{lstlisting}[language=C++]
struct Foo {
  virtual void f(int); };

struct Bar : Foo {
  void f(int) final; };

struct Baz : Bar {
  void f(int); };    // Erreur\end{lstlisting}

	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Utilisez \lstinline|final| avec parcimonie
		\end{itemize}
	\end{exampleblock}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:21,positionColumn:1,positionLineNumber:21,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%23include+%3Cstring%3E%0A%0Astruct+Foo+final%0A%7B%0A++Foo()%0A++%7B%0A++%7D%0A%7D%3B%0A%0Astruct+Bar+:+Foo%0A%7B%0A++Bar()%0A++%7B%0A++%7D%0A%7D%3B%0A%0Aint+main()%0A%7B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:40,positionColumn:1,positionLineNumber:40,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%23include+%3Cstring%3E%0A%0Astruct+Foo%0A%7B%0A++Foo()%0A++%7B%0A++%7D%0A%0A++virtual+void+f(int)%0A++%7B%0A++%7D%0A%7D%3B%0A%0Astruct+Bar+:+Foo%0A%7B%0A++Bar()%0A++%7B%0A++%7D%0A%0A++virtual+void+f(int)+final%0A++%7B%0A++%7D%0A%7D%3B%0A%0Astruct+Baz+:+Bar%0A%7B%0A++Baz()%0A++%7B%0A++%7D%0A%0A++virtual+void+f(int)%0A++%7B%0A++%7D%0A%7D%3B%0A%0Aint+main()%0A%7B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Opérateurs de conversion explicite}
	\begin{itemize}
		\item Extension de \lstinline|explicit| aux opérateurs de conversion
		\item Qui ne définissent alors plus de conversion implicite
	\end{itemize}

	\begin{lstlisting}[language=C++]
struct Foo { operator int() { return 5; } };

Foo f;
int a = f;	                  // OK
int b = static_cast<int>(f);  // OK\end{lstlisting}

	\begin{lstlisting}[language=C++]
struct Foo { explicit operator int() { return 5; } };

Foo f;
int a = f;	                  // Erreur
int b = static_cast<int>(f);  // OK\end{lstlisting}

	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:39,positionColumn:1,positionLineNumber:39,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%23include+%3Cstring%3E%0A%0Astruct+Foo%0A%7B%0A++operator+int()%0A++%7B%0A++++return+5%3B%0A++%7D%0A%7D%3B%0A%0A%0Astruct+Bar%0A%7B%0A++explicit+operator+int()%0A++%7B%0A++++return+5%3B%0A++%7D%0A%7D%3B%0A%0Aint+main()%0A%7B%0A++%7B%0A++++Foo+f%3B%0A++++int+a+%3D+f%3B%0A++++int+b+%3D+static_cast%3Cint%3E(f)%3B%0A++++std::cout+%3C%3C+a+%3C%3C+!'+!'+%3C%3C+b+%3C%3C+!'%5Cn!'%3B%0A++%7D%0A%0A++%7B%0A++++Bar+f%3B%0A%23if+1%0A++++int+a+%3D+f%3B%0A%23endif%0A++++int+b+%3D+static_cast%3Cint%3E(f)%3B%0A++++std::cout+%3C%3C+b+%3C%3C+!'%5Cn!'%3B%0A++%7D%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\subsection*{Exceptions}
\begin{frame}[fragile]
	\frametitle{\lstinline|noexcept|}
	\begin{itemize}
		\item Indique qu'une fonction ne jette pas d'exception

\note[item]{Rôle documentaire et permet au compilateur d'effectuer certaines optimisations (par exemple sur le choix entre déplacement et copie)}
\note[item]{Appelle \lstinline|std::terminate()| lorsque la fonction ne respecte pas son contrat et lance une exception}
\note[item]{\lstinline|std::terminate()| appelle le \textit{handler} correspondant qui par défaut est \lstinline|std::abort()| qui arrête violemment le programme}
	\end{itemize}

	\begin{lstlisting}[language=C++]
void foo() noexcept {}\end{lstlisting}

	\begin{itemize}
		\item Pilotable par une expression booléenne
	\end{itemize}

	\begin{lstlisting}[language=C++]
void foo() noexcept(true) {}\end{lstlisting}

	\begin{block}{Dépréciation}
		\begin{itemize}
			\item Les spécifications d'exception sont dépréciées
			\item Voir \href{http://www.gotw.ca/publications/mill22.htm}{A Pragmatic Look at Exception Specifications} (Herb Sutter)
		\end{itemize}

\note[item]{En pratique, seule \lstinline|throw()| était utilisée et utilisable et a été remplacée par \lstinline|noexcept|}
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{\lstinline|noexcept|}
	\begin{itemize}
		\item Opérateur \lstinline|noexcept()| teste, au \textit{compile-time}, si une expression peut ou non lever une exception
		\item Pour l'appel de fonction, teste si la fonction est \lstinline|noexcept|

\note[item]{Combinable avec le spécificateur}
	\end{itemize}

	\begin{lstlisting}[language=C++]
noexcept(foo()); // true\end{lstlisting}

	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Marquez \lstinline|noexcept| les fonctions qui sémantiquement ne jette pas d'exception
		\end{itemize}
	\end{exampleblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Conversion exception - pointeur}
	\begin{itemize}
		\item \lstinline|std::exception_ptr| quasi-pointeur à responsabilité partagée sur une exception
		\item \lstinline|std::current_exception()| récupère un pointeur sur l'exception courante
		\item \lstinline|std::rethrow_exception()| relance l'exception contenue dans \lstinline|std::exception_ptr| 
		\item \lstinline|std::make_exception_ptr()| construit \lstinline|std::exception_ptr| depuis une exception
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Conversion exception - pointeur}
	\begin{lstlisting}[language=C++]
void foo() { throw 42; }

try {
  foo(); }
catch(...) {
  exception_ptr bar= current_exception();
  rethrow_exception(bar); } \end{lstlisting}

	\begin{block}{Motivation}
		\begin{itemize}
			\item Faire passer la barrière des threads aux exceptions
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Nested exception}
	\begin{itemize}
		\item \lstinline|std::nested_exception| contient une exception imbriquée
		\item \lstinline|nested_ptr()| récupère un pointeur sur l'exception imbriquée
		\item \lstinline|rethrow_nested()| relance l'exception imbriquée
		\item \lstinline|std::rethrow_if_nested()| relance l'exception imbriquée si elle existe
		\item \lstinline|std::throw_with_nested()| lance une exception embarquant l'exception courante
	\end{itemize}

	\begin{lstlisting}[language=C++]
void foo() {
  try { throw 42; }
  catch(...) { 
    throw_with_nested(logic_error("bar")); } }

try { foo(); }
catch(logic_error &e) { std::rethrow_if_nested(e); }\end{lstlisting}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:28,positionColumn:1,positionLineNumber:28,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%23include+%3Cexception%3E%0A%23include+%3Cstring%3E%0A%0Avoid+foo()+%0A%7B%0A++try+%0A++%7B+%0A++++throw+42%3B%0A++%7D%0A++catch(...)%0A++%7B+%0A++++std::throw_with_nested(std::logic_error(%22bar%22))%3B%0A++%7D%0A%7D%0A%0Aint+main()%0A%7B%0A++try%0A++%7B%0A++++foo()%3B%0A++%7D%0A++catch(std::logic_error+%26e)%0A++%7B%0A++++std::rethrow_if_nested(e)%3B%0A++%7D%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\subsection*{Énumérations fortement typées}
\begin{frame}[fragile]
	\frametitle{Énumérations fortement typées \lstinline|enum class|}
	\begin{itemize}
		\item Énumérations mieux typées
		\item Sans conversions implicites

\note[item]{Pas de conversion avec des entiers ou d'autres énumérations}

		\item Énumérés locaux à l'énumération
	\end{itemize}

	\begin{lstlisting}[language=C++]
enum class Foo { BAR1, BAR2 };

Foo foo = Foo::BAR1;\end{lstlisting}

	\begin{itemize}
		\item Possibilité de fournir le type sous-jacent

\note[item]{Sur les énumérations classiques aussi}
	\end{itemize}

	\begin{lstlisting}[language=C++]
enum class Foo : unsigned char { BAR1, BAR2 };\end{lstlisting}

	\begin{itemize}
		\item \lstinline|std::underlying_type| permet de récupérer ce type sous-jacent
	\end{itemize}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:24,positionColumn:1,positionLineNumber:24,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%23include+%3Ctype_traits%3E%0A%0Aenum+class+Foo+:+unsigned+int%0A%7B+%0A++BAR1,%0A++BAR2,%0A%7D%3B%0A%0Aint+main()%0A%7B%0A%23if+0%0A++Foo+foo+%3D+BAR2%3B%0A%23else%0A++Foo+foo+%3D+Foo::BAR2%3B%0A%23endif%0A%0A%23if+0%0A++std::cout+%3C%3C+foo+%3C%3C+%22%5Cn%22%3B%0A%23else%0A++std::cout+%3C%3C+static_cast%3Cstd::underlying_type%3CFoo%3E::type%3E(foo)+%3C%3C+%22%5Cn%22%3B%0A%23endif%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Énumérations fortement typées \lstinline|enum class|}
	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Préférez les énumérations fortement typées
		\end{itemize}
	\end{exampleblock}

	\begin{block}{Bémol}
		\begin{itemize}
			\item Pas de méthode simple et robuste pour récupérer la valeur ou l'intitulé de l'énuméré
		\end{itemize}
	\end{block}
\end{frame}

\subsection*{Programmation fonctionnelle}
\begin{frame}[fragile]
	\frametitle{\lstinline|std::function|}
\note[item]{Fonction de première classe (\og first-class citizens\fg{}) : utilisables comme paramètre ou retour de fonction}
\note[item]{Fonction d'ordre supérieur : prend en paramètre ou retourne une autre fonction}
\note[item]{Les fonctions d'ordre supérieur apparaissaient également dans le design de la STL}

	\begin{itemize}
		\item Encapsule un appelable de n'importe quel type
	\end{itemize}

	\begin{lstlisting}[language=C++]
int foo(int, int);

function<int(int, int)> bar = foo;\end{lstlisting}

	\begin{itemize}
		\item Copiable
		\item Peut être passer en paramètre ou retourner par une fonction
	\end{itemize}

	\begin{block}{Note}
		\begin{itemize}
			\item Les foncteurs ne sont pas transmis aux algorithmes par ce mécanisme mais par des paramètres templates identifiés aux types internes du compilateur
		\end{itemize}

\note[item]{Types internes moins génériques et non accessibles mais plus efficaces}
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{\lstinline|std::mem_fn|}
	\begin{itemize}
		\item Convertit une fonction membre en \textit{function object} prenant une instance en paramètre
	\end{itemize}

	\begin{lstlisting}[language=C++]
struct Foo { int f(int a) { return 2 * a; } };

Foo foo;
function<int(Foo, int)> bar = mem_fn(&Foo::f);
bar(foo, 5);   // 10\end{lstlisting}

	\begin{block}{Note}
		\begin{itemize}
			\item Type de retour non spécifié mais stockable dans \lstinline|std::function|
		\end{itemize}
	\end{block}

	\begin{block}{Dépréciation}
		\begin{itemize}
			\item Dépréciation de \lstinline|std::mem_fun|, \lstinline|std::ptr_fun| et consorts
		\end{itemize}

\note[item]{Série de fonctions templates convertissant des fonctions membres, des pointeurs de fonction, etc. en foncteur utilisable dans les algorithmes. Leur grosse limitation venait du nombre de paramètres limités (0 ou 1)}
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{\lstinline|std::bind|}
	\begin{itemize}
		\item Construction de \textit{function object} en liant des paramètres à un appelable
		\item \textit{Placeholders} \lstinline|std::placholders::_1|, \lstinline|std::placholders::_2|, \ldots{} pour lier les paramètres du \textit{function object} à l'appelable
	\end{itemize}

	\begin{lstlisting}[language=C++]
int foo(int a, int b) { return (a - 1) * b; }

function<int(int)> bar = bind(&foo, _1, 2);
bar(3);               // 4

auto baz = bind(&foo, _2, _1);
baz(3, 2, 1, 2, 3);   // 3\end{lstlisting}	

\note[item]{Avec auto, il est possible de passer autant de paramètres surnuméraires que souhaiter}

	\begin{block}{Dépréciation}
		\begin{itemize}
			\item Dépréciation de \lstinline|std::bind1st| et \lstinline|std::bind2nd|
		\end{itemize}

\note[item]{Version C++98 mais limités car ne pouvait que convertir une fonction binaire en fonction unaire en liant le premier ou le second paramètre}
	\end{block}

	\vskip 5mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:17,positionColumn:1,positionLineNumber:17,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%23include+%3Cfunctional%3E%0A%0Astatic+int+foo(int+a,+int+b)%0A%7B%0A++return+(a+-+1)+*+b%3B%0A%7D%0A%0Aint+main()%0A%7B%0A++std::function%3Cint(int)%3E+bar+%3D+std::bind(%26foo,+std::placeholders::_1,+2)%3B%0A++std::cout+%3C%3C+bar(3)+%3C%3C+!'%5Cn!'%3B%0A%0A++auto+baz+%3D+std::bind(%26foo,+std::placeholders::_2,+std::placeholders::_1)%3B%0A++std::cout+%3C%3C+baz(3,+2,+1,+2,+3)+%3C%3C+!'%5Cn!'%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{lambda et fermeture}
	\begin{block}{Vocabulaire}
		\begin{itemize}
			\item Lambda : fonction anonyme
			\item Fermeture : capture des variables libres de l'environnement lexical
		\end{itemize}
	\end{block}

	\pause

	\begin{itemize}
		\item \lstinline|[capture](parametres) specificateurs -> type_retour {instructions}|
	\end{itemize}

	\begin{lstlisting}[language=C++]
int bar = 4;
auto foo = [&bar] (int a) -> int { bar *= a; return a; };

int baz = foo(5);
// bar : 20, baz : 5\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{lambda et fermeture}
	\begin{itemize}
		\item Capture
		\begin{itemize}
			\item{} \lstinline|[]| : pas de capture
			\item{} \lstinline|[x]| : capture x par valeur
			\item{} \lstinline|[&y]| : capture y par référence
			\item{} \lstinline|[&]| : capture tout par référence
			\item{} \lstinline|[=]|  : capture tout par valeur
			\item{} \lstinline|[x, &y]| : capture x par valeur et y par référence
			\item{} \lstinline|[=, &z]| : capture z par référence et le reste par copie
			\item{} \lstinline|[&, z]| : capture z par valeur et le reste par référence
		\end{itemize}
		\item La capture de variables membres se fait par la capture de  \lstinline|this|
		\begin{itemize}
			\item Soit explicitement via \lstinline|[this]|
		\end{itemize}
	\end{itemize}

	\begin{alertblock}{Capture de \lstinline|this|}
		\begin{itemize}
			\item Capture du pointeur, non de l'objet
		\end{itemize}

\note[item]{C++14 permet la capture d'une copie de l'objet}
	\end{alertblock}

	\begin{itemize}
		\item [] \begin{itemize}
			\item Soit via \lstinline|[=]| ou \lstinline|[&]|

\note[item]{Plusieurs changements autour de la capture explicite ou implicite de \lstinline|this| dans les versions suivantes}
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{lambda et fermeture}
	\begin{itemize}
		\item Préservation de la constante des variables capturées

\note[item]{Même avec \lstinline|mutable|}

		\item Pas de capture des variables globales et statiques

\note[item]{Dans l'exemple ci-dessus, \lstinline|bar| ne peut donc pas être une variable globale}
	\end{itemize}

	\begin{alertblock}{Attention}
		\begin{itemize}
			\item Par défaut, les variables capturées par copie ne sont pas modifiables
		\end{itemize}

		\begin{lstlisting}[language=C++]
int i = 5;
	
auto foo = [=] () { cout << ++i << "\n"; };      // Erreur
auto bar = [=] () mutable { cout << ++i << "\n"; };  // OK\end{lstlisting}

\note[item]{Bien entendu dans le cas de mutable, ce qui est modifié est bien la copie, pas la variable originale}
	\end{alertblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{lambda et fermeture}
	\begin{itemize}
		\item Spécificateurs
		\begin{itemize}
			\item \lstinline|mutable| : modification possible des variables capturées par copie
			\item \lstinline|noexcept| : ne lève pas d'exception
		\end{itemize}

		\item Omission possible du type de retour si
		\begin{itemize}
			\item Unique instruction
			\item Un \lstinline|return|
		\end{itemize}

\note[item]{Restrictions levées dans les versions récentes}

		\item Omission possible d'une liste de paramètres vide

\begin{lstlisting}[language=C++]
auto foo = [] { return 5; };\end{lstlisting}
	\end{itemize}

	\begin{alertblock}{\lstinline|mutable|}
		\begin{itemize}
			\item Sauf avec le mot clé \lstinline|mutable|
		\end{itemize}
	\end{alertblock}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:29,positionColumn:1,positionLineNumber:29,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%23include+%3Cvector%3E%0A%23include+%3Calgorithm%3E%0A%0Ausing+std::begin%3B%0Ausing+std::end%3B%0A%0Aint+main()%0A%7B%0A++%7B%0A++++int+bar+%3D+4%3B%0A++++auto+foo+%3D+%5B%26bar%5D+(int+a)+-%3E+int+%7B+bar+*%3D+a%3B+return+3+*+a%3B%7D%3B%0A%0A++++std::cout+%3C%3C+foo(5)+%3C%3C+!'+!'+%3C%3C+bar+%3C%3C+!'%5Cn!'%3B%0A++%7D%0A%0A++%7B%0A++++std::vector%3Cint%3E+foo%7B1,+8,+5,+6,+3,+7%7D%3B%0A++++std::vector%3Cint%3E+bar%3B%0A%0A++++std::copy_if(begin(foo),+end(foo),+std::back_inserter(bar),+%5B%5D+(int+i)+%7Breturn+(i%252)+%3D%3D+1%3B%7D)%3B%0A++++for(auto+i+:+bar)%0A++++%7B%0A++++++std::cout+%3C%3C+i+%3C%3C+!'+!'%3B%0A++++%7D%0A++++std::cout+%3C%3C+!'%5Cn!'%3B%0A++%7D%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{lambda, \lstinline|std::function|, \ldots{} - Conclusion}
	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Préférez les lambdas aux \lstinline|std::function|
			\item Préférez les lambdas à \lstinline|std::bind()|
		\end{itemize}
	\end{exampleblock}

\note[item]{Les lambdas sont généralement plus efficaces}

	\begin{block}{Motivations}
		\begin{itemize}
			\item Lisibilité, expressivité et performances
			\item Voir \href{https://github.com/boostcon/cppnow_presentations_2016/blob/master/00_tuesday/practical_performance_practices.pdf}{practical\_performance\_practices.pdf}
		\end{itemize}

\note[item]{Entre autres, il y a aussi des remarques intéressantes sur le choix des conteneurs, des pointeurs intelligents, sur \lstinline|std::endl|, etc.}
	\end{block}

	\begin{alertblock}{Attention}
		\begin{itemize}
			\item Prenez garde à la durée de vie des variables capturées par référence
		\end{itemize}
	\end{alertblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{\lstinline|std::reference_wrapper|}
	\begin{itemize}
		\item Encapsule un objet en émulant un référence
		\item Construction par \lstinline|std::ref()| et \lstinline|std::cref()|
		\item Copiable
	\end{itemize}

	\begin{lstlisting}[language=C++]
int a{10};
reference_wrapper<int> aref = ref(a);

aref++;   // a : 11\end{lstlisting}
\end{frame}

\subsection*{Template}
\begin{frame}[fragile]
	\frametitle{Double chevron}
	\begin{itemize}
		\item C++98/03 : \lstinline|>>| est toujours l'opérateur de décalage
		\item C++11 : peut être une double fermeture de template
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<vector<int>> foo;
// Invalide en C++98/03
// Valide en C++11\end{lstlisting}

\note[item]{En C++98/03, il fallait un espace entre les deux >}

	\begin{itemize}
		\item Utilisation de parenthèses pour forcer l'interprétation en tant qu'opérateur
	\end{itemize}

	\begin{lstlisting}[language=C++]
vector<array<int, (0x10 >> 3) >> foo;\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Alias de template}
	\begin{itemize}
		\item En C++98/03, \lstinline|typedef| définit des alias sur des templates
		\item \ldots{} seulement si tous les paramètres templates sont explicites
	\end{itemize}

	\begin{lstlisting}[language=C++]
template <typename T, typename U, int V>
class Foo;

typedef Foo<int, int, 5> Baz;  // OK

template <typename U>
typedef Foo<int, U, 5> Bar;    // Incorrect\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Alias de template}
	\begin{itemize}
		\item \lstinline|using| permet la création d'alias ne définissant que certains paramètres
	\end{itemize}

	\begin{lstlisting}[language=C++]
template <typename U>
using Bar = Foo<int, U, 5>;\end{lstlisting}

	\pause

	\begin{itemize}
		\item \lstinline|using| n'est pas réservé aux templates
	\end{itemize}

\note[item]{Ainsi \lstinline|using| devient le mot clé générique pour injecter des symboles : tout ou partie d'un namespace dans un autre, membres d'une classe de base dans une classe dérivée, alias sur un type, fut-il template partiellement paramétré}

	\begin{lstlisting}[language=C++]
using Error = int;\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Extern template}
	\begin{itemize}
		\item Indique que le template est instancié dans une autre unité de compilation
		\item Inutile de l'instancier ici
	\end{itemize}

	\begin{lstlisting}[language=C++]
extern template class std::vector<int>;\end{lstlisting}

	\begin{block}{Objectif}
		\begin{itemize}
			\item Réduction du temps de compilation
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Variadic template}
	\begin{itemize}
		\item Template à nombre de paramètres variable
		\item Définition avec \lstinline|typename...|
	\end{itemize}

	\begin{lstlisting}[language=C++]
template<typename... Args>
class Foo;\end{lstlisting}

	\begin{itemize}
		\item Récupération de la liste avec \lstinline|...|
	\end{itemize}

	\begin{lstlisting}[language=C++]
template<typename... Args>
void bar(Args... parameters);\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Variadic template}
	\begin{itemize}
		\item Récupération de la taille avec \lstinline|sizeof...|
	\end{itemize}

	\begin{lstlisting}[language=C++]
template<typename... Args>
class Foo() {
private :
  static const unsigned int size = sizeof...(Args); };\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Variadic template}
	\begin{itemize}
		\item Utilisation récursive par spécialisation
	\end{itemize}

	\begin{lstlisting}[language=C++]
// Condition d'arret
template<typename T>
T sum(T val) {
  return val; }

template<typename T, typename... Args>
T sum(T val, Args... values) {
  return val + sum(values...); }

sum(1, 5, 56, 9);                   // 71
sum(string("Un"), string("Deux"));  // "UnDeux"\end{lstlisting}

\note[item]{Très proche de la façon de parcourir des listes (ou d'autres structures de données) dans les langages fonctionnels (p.ex. Lisp) où une liste est décomposée entre un élément de tête et le reste de la liste}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:22,positionColumn:1,positionLineNumber:22,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%23include+%3Cstring%3E%0A%0A//+Condition+d!'arret%0Atemplate%3Ctypename+T%3E%0AT+sum(T+val)%0A%7B%0A++return+val%3B%0A%7D%0A%0Atemplate%3Ctypename+T,+typename...+Args%3E%0AT+sum(T+val,+Args...+values)%0A%7B%0A++return+val+%2B+sum(values...)%3B%0A%7D%0A%0Aint+main()%0A%7B%0A++std::cout+%3C%3C+sum(1,+5,+56,+9)+%3C%3C+!'%5Cn!'%3B%0A++std::cout+%3C%3C+sum(std::string(%22Un%22),+std::string(%22Deux%22))+%3C%3C+!'%5Cn!'%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Variadic template}
	\begin{itemize}
		\item Ou expansion sur une expression et une fonction d'expansion
	\end{itemize}

	\begin{lstlisting}[language=C++]
template<typename... T> void pass(T&&...) {}

int total = 0;
foo(int i) {
  total += i; 
  return i; }

template<typename... T>
auto sum(T... t) {
  pass((foo(t))...); return total; }

sum(1,2,3,5);  // 11\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Variadic template}
	\begin{alertblock}{Contraintes de l'expansion}
		\begin{itemize}
			\item Paramètre unique
			\item Ne retournant pas \lstinline|void|
			\item Pas d'ordre garanti
		\end{itemize}
	\end{alertblock}

	\begin{itemize}
		\item Candidat naturel : \lstinline|std::initializer_list|
		\item \ldots{} constructible depuis un \textit{variadic template}
	\end{itemize}

	\begin{lstlisting}[language=C++]
template<typename... T>
auto foo(T... t) {
  initializer_list<int>{ t... }; }

foo(1,2,3,5);\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Variadic template}
	\begin{itemize}
		\item \ldots{} qui règle le problème de l'ordre
	\end{itemize}

	\begin{lstlisting}[language=C++]
int total = 0;
foo(int i) {
  total += i; return i; }

template<typename... T>
auto sum(T... t) {
  initializer_list<int>{ (foo(t), 0)... };
  return total; }

sum(1,2,3,5);  // 11\end{lstlisting}

\note[item]{,0 permet de régler le souci du retour void}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Variadic template}
	\begin{itemize}
		\item \ldots{} sur n'importe quelle expression prenant un paramètre

\note[item]{Donc appelle de fonction ou lambda mais aussi simple expression}
	\end{itemize}

	\begin{lstlisting}[language=C++]
template<typename... T>
auto sum(T... t) {
  typename common_type<T...>::type result{};
  initializer_list<int>{ (result += t, 0)... };
  return result; }

sum(1, 2, 3, 5);  // 11\end{lstlisting}

	\begin{lstlisting}[language=C++]
template<typename... T>
void print(T... t) {
  initializer_list<int>{ (cout << t << " ", 0)... }; }

print(1, 2, 3, 5);\end{lstlisting}

	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:25,positionColumn:1,positionLineNumber:25,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%23include+%3Cstring%3E%0A%0Atemplate%3Ctypename+...+T%3E%0Atypename+std::common_type%3CT...%3E::type+sum(T+...+t)%0A%7B%0A++typename+std::common_type%3CT...%3E::type+result%7B%7D%3B%0A++std::initializer_list%3Cint%3E%7B+(result+%2B%3D+t,+0)...+%7D%3B%0A++return+result%3B%0A%7D%0A%0Atemplate%3Ctypename+...+T%3E%0Avoid+print(T+...+t)%0A%7B%0A++std::initializer_list%3Cint%3E%7B+(std::cout+%3C%3C+t+%3C%3C+%22+%22,+0)...+%7D%3B%0A%7D%0A%0Aint+main()%0A%7B%0A++std::cout+%3C%3C+sum(1,+5,+42,+9)+%3C%3C+!'%5Cn!'%3B%0A++std::cout+%3C%3C+sum(std::string(%22Un%22),+std::string(%22Deux%22))+%3C%3C+!'%5Cn!'%3B%0A%0A++print(1,+2,+3,+5)%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g112,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+11.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{\lstinline|std::enable_if|}
	\begin{itemize}
		\item Classe template sur une expression booléenne et un type
		\item Définition du type seulement si l'expression booléenne est vraie
		\item Templates disponibles uniquement pour certains types
	\end{itemize}

	\begin{lstlisting}[language=C++]
template<class T, 
typename enable_if<is_integral<T>::value, T>::type* = nullptr>
void foo(T data) { }

foo(42);
foo("azert");    // Erreur\end{lstlisting}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:32,positionColumn:1,positionLineNumber:32,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%23include+%3Ctype_traits%3E%0A%0Atemplate%3Cclass+T,+typename+std::enable_if%3Cstd::is_integral%3CT%3E::value,+T%3E::type*+%3D+nullptr%3E%0Avoid+foo(T+data)%0A%7B%0A++std::cout+%3C%3C+data+%3C%3C+%22%5Cn%22%3B%0A%7D%0A%0Atemplate%3Cclass+T,+typename+std::enable_if%3C!!std::is_integral%3CT%3E::value,+T%3E::type*+%3D+nullptr%3E%0Avoid+bar(T)%0A%7B%0A++std::cout+%3C%3C+%22Generique%5Cn%22%3B%0A%7D%0A%0Atemplate%3Cclass+T,typename+std::enable_if%3Cstd::is_integral%3CT%3E::value,+T%3E::type*+%3D+nullptr%3E%0Avoid+bar(T)%0A%7B%0A++std::cout+%3C%3C+%22Entier%5Cn%22%3B%0A%7D%0A%0Aint+main()%0A%7B%0A++foo(42)%3B%0A%23if+0%0A++foo(%22azert%22)%3B%0A%23endif%0A%0A++bar(42)%3B%0A++bar(%22azert%22)%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Types locaux en arguments templates}
	\begin{itemize}
		\item Utilisation des types locaux non-nommés comme arguments templates
	\end{itemize}

	\begin{lstlisting}[language=C++]
void bar(vector<int>& foo) {
struct Less {
  bool operator()(int a, int b) { return a < b; } };

sort(foo.begin(), foo.end(), Less()); }\end{lstlisting}

	\begin{itemize}
		\item Y compris des lambdas
	\end{itemize}

	\begin{lstlisting}[language=C++]
sort(foo.begin(), foo.end(),
     [] (int a, int b) { return a < b; }); }\end{lstlisting}
\end{frame}

\subsection*{Type traits}
\begin{frame}[fragile]
	\frametitle{Type traits - Helper}
	\begin{itemize}
		\item \lstinline|std::integral_constant| : constante \textit{compile-time}
		\item \lstinline|true_type| : \lstinline|std::integral_constant| booléen vrai
		\item \lstinline|false_type| : \lstinline|std::integral_constant| booléen faux
	\end{itemize}

	\begin{lstlisting}[language=C++]
template <unsigned n>
struct factorial 
  : integral_constant<int,n*factorial<n-1>::value> {};

template <>
struct factorial<0> 
  : integral_constant<int,1> {};

factorial<5>::value;  // 120 en compile-time\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Type traits - Trait}
	\begin{itemize}
		\item Détermine, à la compilation, les caractéristiques des types
		\item \lstinline|std::is_array| : tableau C
	\end{itemize}

	\begin{lstlisting}[language=C++]
is_array<int>::value;     // false
is_array<int[3]>::value;  // true\end{lstlisting}

	\begin{itemize}
		\item \lstinline|std::is_integral| : type entier
	\end{itemize}

	\begin{lstlisting}[language=C++]
is_integral<short>::value;   // true
is_integral<string>::value;  // false\end{lstlisting}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:19,positionColumn:1,positionLineNumber:19,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%23include+%3Ctype_traits%3E%0A%0Atemplate+%3Cunsigned+n%3E%0Astruct+factorial+:+std::integral_constant%3Cint,+n+*+factorial%3Cn-1%3E::value%3E%0A%7B%7D%3B%0A%0Atemplate+%3C%3E%0Astruct+factorial%3C0%3E+:+std::integral_constant%3Cint,+1%3E%0A%7B%7D%3B%0A%0Aint+main()%0A%7B%0A++std::cout+%3C%3C+factorial%3C5%3E::value+%3C%3C+!'%5Cn!'%3B%0A%0A++std::cout+%3C%3C+std::boolalpha+%3C%3C+std::is_array%3Cint%3E::value+%3C%3C+!'%5Cn!'%3B%0A++std::cout+%3C%3C+std::boolalpha+%3C%3C+std::is_array%3Cint%5B3%5D%3E::value+%3C%3C+!'%5Cn!'%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Type traits - Trait}
	\begin{itemize}
		\item \lstinline|std::is_fundamental| : type fondamental (entier, réel, \lstinline|void| ou \lstinline|nullptr_t|)
	\end{itemize}

	\begin{lstlisting}[language=C++]
is_fundamental<short>::value;   // true
is_fundamental<string>::value;  // false
is_fundamental<void*>::value;   // false\end{lstlisting}

	\begin{itemize}
		\item \lstinline|std::is_const| : type constant
	\end{itemize}

	\begin{lstlisting}[language=C++]
is_const<const short>::value;  // true
is_const<string>::value;       // false\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Type traits - Trait}
	\begin{itemize}
		\item \lstinline|std::is_base_of| : base d'un autre type
	\end{itemize}

	\begin{lstlisting}[language=C++]
struct Foo {};
struct Bar : Foo {};

is_base_of<int, int>::value;        // false
is_base_of<string, string>::value;  // true
is_base_of<Foo, Bar>::value;        // true
is_base_of<Bar, Foo>::value;        // false\end{lstlisting}

	\begin{itemize}
		\item Et bien d'autres \ldots
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Type traits - Transformations}
	\begin{itemize}
		\item Construction d'un type par transformation d'un type existant
		\item \lstinline|std::add_const| : type \lstinline|const|
	\end{itemize}

	\begin{lstlisting}[language=C++]
// const int
typedef add_const<int>::type A;
// const int
typedef add_const<const int>::type B;
// const int* const
typedef add_const<const int*>::type C;\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Type traits - Transformations}
	\begin{itemize}
		\item \lstinline|std::make_unsigned| : type non signé correspondant
	\end{itemize}

	\begin{lstlisting}[language=C++]
enum Foo {bar};

// unsigned int
typedef make_unsigned<int>::type A;
// unsigned int
typedef make_unsigned<unsigned>::type B;
// const unsigned int
typedef make_unsigned<const unsigned>::type C;
// unsigned int
typedef make_unsigned<Foo>::type D;\end{lstlisting}

	\begin{itemize}
		\item Et bien d'autres \ldots
	\end{itemize}
\end{frame}

\subsection*{Pointeurs intelligents}
\begin{frame}[fragile]
	\frametitle{Pointeurs intelligents}
	\begin{itemize}
		\item RAII appliqué aux pointeurs et aux ressources allouées
		\item Objets à sémantique de pointeur gérant la durée de vie des objets
		\item Garantie de libération
		\item Garantie de cohérence
		\item Historiquement
		\begin{itemize}
			\item \lstinline|std::auto_ptr|
			\item \lstinline|boost::scoped_ptr| et \lstinline|boost::scoped_array|
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Pointeurs intelligents - \lstinline|std::unique_ptr|}
	\begin{itemize}
		\item Responsabilité exclusive
		\item Non copiable mais déplaçable
		\item Testable
	\end{itemize}

	\begin{lstlisting}[language=C++]
unique_ptr<int> p(new int);
*p = 42;\end{lstlisting}

	\begin{itemize}
		\item \lstinline|release()| relâche la responsabilité de la ressource

\note[item]{La ressource n'est pas libérée, mais le pointeur n'en a plus la responsabilité (pointeur brut retourné)}

		\item \lstinline|reset()| change la ressource possédée

\note[item]{L'objet précédemment pointé est libéré}
\note[item]{Possible de fournir un pointeur \lstinline|nullptr| à \lstinline|reset()| (valeur par défaut) pour simplement libérer l'objet contenu}

		\item \lstinline|get()| récupère un pointeur brut sur la ressource

\note[item]{P.ex. pour appeler une API C}
	\end{itemize}

	\begin{alertblock}{Attention}
		\begin{itemize}
			\item Ne pas utilisez le pointeur retourné par \lstinline|get()| pour libérer la ressource
		\end{itemize}
	\end{alertblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Pointeurs intelligents - \lstinline|std::unique_ptr|}
	\begin{itemize}
		\item Fourniture possible de la fonction de libération
	\end{itemize}

	\begin{lstlisting}[language=C++]
FILE *fp = fopen("foo.txt", "w");
unique_ptr<FILE, int(*)(FILE*)> p(fp, &fclose);\end{lstlisting}

	\begin{itemize}
		\item Spécialisation pour les tableaux C
		\begin{itemize}
			\item Sans \lstinline|*| et \lstinline|->|
			\item Mais avec \lstinline|[]|
		\end{itemize}
	\end{itemize}

	\begin{lstlisting}[language=C++]
std::unique_ptr<int[]> foo (new int[5]);
for(int i=0; i<5; ++i) foo[i] = i;\end{lstlisting}

	\begin{block}{Dépréciation}
		\begin{itemize}
			\item Dépréciation de \lstinline|std::auto_ptr|
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Pointeurs intelligents - \lstinline|std::shared_ptr|}
	\begin{itemize}
		\item Responsabilité partagée de la ressource
		\item Comptage de références
		\item Copiable (incrémentation du compteur de références)
		\item Testable
	\end{itemize}

	\begin{lstlisting}[language=C++]
shared_ptr<int> p(new int());
*p = 42;\end{lstlisting}

	\begin{itemize}
		\item \lstinline|reset()| change la ressource possédée

\note[item]{Avec ajustement des compteurs de références et libération si nécessaire}

		\item \lstinline|use_count()| retourne le nombre de possesseurs de la ressource
		\item \lstinline|unique()| indique si la possession est unique
		\item Fourniture possible de la fonction de libération
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Pointeurs intelligents - \lstinline|std::make_shared()|}
	\begin{itemize}
		\item Allocation et construction de l'objet dans le \lstinline|std::shared_ptr|
	\end{itemize}

	\begin{lstlisting}[language=C++]
shared_ptr<int> p = make_shared<int>(42);\end{lstlisting}

	\begin{block}{Objectifs}
		\begin{itemize}
			\item Pas de \lstinline|new| explicite, plus robuste

			\begin{lstlisting}[language=C++]
// Fuite possible en cas d'exception depuis bar()
foo(shared_ptr<int>(new int(42)), bar());\end{lstlisting}

			\item Allocation unique pour la ressource et le compteur de référence
		\end{itemize}
	\end{block}

	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Utilisez \lstinline|std::make_shared()| pour construire vos \lstinline|std::shared_ptr|
		\end{itemize}
	\end{exampleblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Pointeurs intelligents - \lstinline|std::weak_ptr|}
	\begin{itemize}
		\item Aucune responsabilité sur la ressource
		\item Collabore avec \lstinline|std::shared_ptr| sans impact sur le comptage de références
		\item Pas de création depuis un pointeur nu
	\end{itemize}

	\begin{block}{Objectif}
		\begin{itemize}
			\item Rompre les cycles 
		\end{itemize}
	\end{block}

	\begin{lstlisting}[language=C++]
shared_ptr<int> sp(new int(20));
weak_ptr<int> wp(sp);\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Pointeurs intelligents - \lstinline|std::weak_ptr|}
	\begin{itemize}
		\item Pas d'accès à la ressource
		\item Convertible en \lstinline|std::shared_ptr| via \lstinline|lock()|

\note[item]{Pourquoi ? Pour verrouiller la ressource le temps de son utilisation}
\note[item]{Retourne un \lstinline|std::shared_ptr| vide si la ressource n'existe plus}
	\end{itemize}

	\begin{lstlisting}[language=C++]
shared_ptr<int> sp = wp.lock();\end{lstlisting}

	\begin{itemize}
		\item \lstinline|reset()| vide le pointeur
		\item \lstinline|use_count()| retourne le nombre de possesseurs de la ressource

\note[item]{Possesseurs aux nombres desquels notre \lstinline|std::weak_ptr| n'appartient pas}

		\item \lstinline|expired()| indique si le \lstinline|std::weak_ptr| ne référence plus une ressource valide

\note[item]{Soit il pointe sur rien, soit la ressource a été libérée car n'avait plus de \lstinline|std::shared_ptr| sur elle}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Pointeurs intelligents - Conclusion}
	\begin{alertblock}{Don't}
		\begin{itemize}
			\item N'utilisez pas de pointeurs bruts possédants
		\end{itemize}
	\end{alertblock}

	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Réfléchissez à la responsabilité de vos ressources
		\end{itemize}
	\end{exampleblock}

	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Préférez \lstinline|std::unique_ptr| à \lstinline|std::shared_ptr|
			\item Préférez une responsabilité unique à une responsabilité partagée

\note[item]{Code globalement plus simple (parfois au prix d'une petite complexité locale) et souvent plus performant (le comptage de référence à un coup, particulièrement en environnement multithreadé)}
		\end{itemize}
	\end{exampleblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Pointeurs intelligents - Conclusion}
	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Brisez les cycles à l'aide de \lstinline|std::weak_ptr|
		\end{itemize}
	\end{exampleblock}

	\begin{alertblock}{Attention}
		\begin{itemize}
			\item Passez par un \lstinline|std::unique_ptr| temporaire intermédiaire pour insérer des éléments dans un conteneur de \lstinline|std::unique_ptr|
			\item Voir \href{https://accu.org/index.php/journals/2271}{Overload 134 - C++ Antipatterns}
		\end{itemize}

\note[item]{\lstinline|push_back| d'un pointeur brute n'est pas possible et \lstinline|emplace_back| peut échouer en laissant fuir le pointeur}
	\end{alertblock}

	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Transférez au plus tôt la responsabilité à un pointeur intelligent
		\end{itemize}
	\end{exampleblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Pointeurs intelligents - Conclusion}
	\begin{block}{Pour aller plus loin}
		\begin{itemize}
			\item Voir \href{http://loic-joly.developpez.com/tutoriels/cpp/smart-pointers/}{Pointeurs intelligents (Loïc Joly)}
		\end{itemize}
	\end{block}

	\begin{block}{Sous silence}
		\begin{itemize}
			\item Allocateurs, mémoire non-initialisée, alignement, \ldots
		\end{itemize} 
	\end{block}

	\begin{block}{Mais aussi}
		\begin{itemize}
			\item Support minimal des \textit{Garbage Collector}

\note[item]{Support enlevé en C++23 : trop restrictif, inutilisé, conceptions très différentes et variés dans les langages à GC}

			\item Mais pas de GC standard
		\end{itemize}
	\end{block}
\end{frame}

\subsection*{Attributs}
\begin{frame}[fragile]
	\frametitle{Attributs}
	\begin{itemize}
		\item Syntaxe standard pour les directives de compilation \textit{inlines}
		\item \ldots y compris celles spécifiques à un compilateur
		\item Remplace la directive \lstinline|#pragma|
		\item Et les mots-clé propriétaires (\lstinline|__attribute__|, \lstinline|__declspec|)
	\end{itemize}

	\begin{lstlisting}[language=C++]
[[ attribut ]]\end{lstlisting}

	\begin{itemize}
		\item Peut être multiple
	\end{itemize}

	\begin{lstlisting}[language=C++]
[[ attribut1, attribut2 ]]\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Attributs}
	\begin{itemize}
		\item Peut prendre des arguments
	\end{itemize}

	\begin{lstlisting}[language=C++]
[[ attribut(arg1, arg2) ]]\end{lstlisting}

	\begin{itemize}
		\item Peut être dans un namespace et spécifique à une implémentation
	\end{itemize}

	\begin{lstlisting}[language=C++]
[[ vendor::attribut ]]\end{lstlisting}

	\begin{block}{Par exemple}
		les attributs \lstinline|gsl| des \og C++ Core Guidelines Checker\fg{} de Microsoft
		
	\begin{lstlisting}[language=C++]
[[ gsl::suppress(26400) ]]\end{lstlisting}
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Attributs}
	\begin{itemize}
		\item Placé après le nom pour les entités nommées
	\end{itemize}

	\begin{lstlisting}[language=C++]
int [[ attribut1 ]] i [[ attribut2 ]];
// Attribut1 s'applique au type
// Attribut2 s'applique a i\end{lstlisting}

	\begin{itemize}
		\item Placé avant l'entité sinon
	\end{itemize}

	\begin{lstlisting}[language=C++]
[[ attribut ]] return i;
// Attribut s'applique au return\end{lstlisting}

	\begin{exampleblock}{Bonus}
		\begin{itemize}
			\item Aussi une information à destination des développeurs
		\end{itemize}
	\end{exampleblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Attribut \lstinline|[[ noreturn ]]|}
	\begin{itemize}
		\item Indique qu'une fonction ne retourne pas
	\end{itemize}

	\begin{lstlisting}[language=C++]
[[ noreturn ]] void f() { throw "error"; }\end{lstlisting}

	\begin{alertblock}{Attention}
		\begin{itemize}
			\item Qui ne retourne pas
			\item Et non qui ne retourne rien
		\end{itemize}
	\end{alertblock}

	\begin{block}{Usage}
		\begin{itemize}
			\item Boucle infinie, sortie de l'application, exception systématique
		\end{itemize}
	\end{block}

	\begin{block}{Sous silence}
		\begin{itemize}
			\item \lstinline|[[ carries_dependency ]]|
		\end{itemize}
	\end{block}
\end{frame}

\subsection*{Rapport}
\begin{frame}[fragile]
	\frametitle{Rapport}

\note[item]{La rapport est dans le type, pas dans les valeurs ou les instances}

	\begin{itemize}
		\item \lstinline|std::ratio| représente un rapport entre deux nombres
		\item Numérateur et dénominateurs sont des paramètres templates
		\item \lstinline|num| accède au numérateur
		\item \lstinline|den| accède au dénominateur
	\end{itemize}

	\begin{lstlisting}[language=C++]
ratio<6, 2> r;
cout << r.num << "/" << r.den;   // 3/1\end{lstlisting}

	\begin{itemize}
		\item Instanciations standard des préfixes du système international d'unités
		\begin{itemize}
			\item yocto, zepto, atto, femto, pico, nano, micro, milli, centi, déci
			\item déca, hecto, kilo, méga, giga, téra, péta, exa, zetta, yotta
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Rapport}
	\begin{itemize}
		\item Méta-fonctions arithmétiques : \lstinline|std::ratio_add()|, \lstinline|std::ratio_substract()|, \lstinline|std::ratio_multiply()| et \lstinline|std::ratio_divide()|

\note[item]{Méta car elles agissent sur les types et non sur les valeurs}
	\end{itemize}

	\begin{lstlisting}[language=C++]
ratio_add<ratio<5, 1>, ratio<3, 2>> r;
cout << r.num << "/" << r.den;   // 13/2\end{lstlisting}

	\begin{itemize}
		\item Méta-fonctions de comparaison : \lstinline|std::ratio_equal()|, \lstinline|std::ratio_not_equal()|, \lstinline|std::ratio_less()|, \lstinline|std::ratio_less_equal()|, \lstinline|std::ratio_greater()| et \lstinline|std::ratio_greater_equal()|
	\end{itemize}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:20,positionColumn:1,positionLineNumber:20,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%23include+%3Cratio%3E%0A%0Aint+main()%0A%7B%0A++%7B%0A++++std::ratio%3C6,+2%3E+r%3B%0A++++std::cout+%3C%3C+r.num+%3C%3C+!'/!'+%3C%3C+r.den+%3C%3C+!'%5Cn!'%3B%0A++%7D%0A%0A++%7B%0A++++std::ratio_add%3Cstd::ratio%3C6,+2%3E,+std::ratio%3C2,+3%3E%3E+r%3B%0A++++std::cout+%3C%3C+r.num+%3C%3C+!'/!'+%3C%3C+r.den+%3C%3C+!'%5Cn!'%3B%0A++%7D%0A%0A++%7B%0A++++std::cout+%3C%3C+std::boolalpha+%3C%3C+std::ratio_less_equal%3Cstd::ratio%3C6,+2%3E,+std::ratio%3C2,+3%3E%3E::value+%3C%3C+!'%5Cn!'%3B%0A++%7D%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\subsection*{Durées et temps}
\begin{frame}[fragile]
	\frametitle{Durées}
	\begin{itemize}
		\item Classe template \lstinline|std::chrono::duration|
		\item Unité dépendante d'un ratio avec la seconde
		\item Instanciations standard : \textit{hours}, \textit{minutes}, \textit{seconds}, \textit{milliseconds}, \textit{microseconds} et \textit{nanosecond}
	\end{itemize}

	\begin{lstlisting}[language=C++]
milliseconds foo(500);  // 500 ms
foo.count();    // 500\end{lstlisting}

	\begin{itemize}
		\item \lstinline|count()| retourne la valeur
		\item \lstinline|period| est le type représentant le ratio
	\end{itemize}

	\begin{lstlisting}[language=C++]
milliseconds foo(10000);
cout << foo.count() * milliseconds::period::num / 
        milliseconds::period::den;  // Affiche 10\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Durées}
	\begin{itemize}
		\item Opérateurs de manipulation des durées (ajout, suppression, \ldots{})
	\end{itemize}

	\begin{lstlisting}[language=C++]
milliseconds foo(500);
milliseconds bar(10);
foo += bar;   // 510
foo /= 2;     // 255\end{lstlisting}

	\begin{itemize}
		\item Opérateurs de comparaison entre durées
		\item \lstinline|zero()| crée une durée nulle
		\item \lstinline|min()| crée la plus petite valeur possible
		\item \lstinline|max()| crée la plus grande valeur possible
	\end{itemize}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:28,positionColumn:1,positionLineNumber:28,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%23include+%3Cchrono%3E%0A%0Aint+main()%0A%7B%0A++%7B%0A++++std::chrono::milliseconds+foo(12000)%3B%0A++++std::cout+%3C%3C+foo.count()+%3C%3C+!'%5Cn!'%3B%0A++++std::cout+%3C%3C+foo.count()+*+std::chrono::milliseconds::period::num+/+std::chrono::milliseconds::period::den+%3C%3C+!'%5Cn!'%3B%0A++%7D%0A%0A++%7B%0A++++std::chrono::milliseconds+foo(500)%3B%0A++++std::chrono::milliseconds+bar(10)%3B%0A%0A++++foo+%2B%3D+bar%3B%0A++++std::cout+%3C%3C+foo.count()+%3C%3C+!'%5Cn!'%3B%0A%0A++++foo+/%3D+2%3B%0A++++std::cout+%3C%3C+foo.count()+%3C%3C+!'%5Cn!'%3B%0A++%7D%0A%0A++%7B%0A++++std::chrono::system_clock::time_point+t+%3D+std::chrono::system_clock::now()%3B%0A++++std::cout+%3C%3C+t.time_since_epoch().count()+%3C%3C+!'%5Cn!'%3B%0A++%7D%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Temps relatif}
	\begin{itemize}
		\item \lstinline|std::chrono::time_point| temps relatif depuis l'epoch
	\end{itemize}

	\begin{block}{Epoch}
		\begin{itemize}
			\item Origine des temps de l'OS (1 janvier 1970 00h00 sur Unix)
		\end{itemize}
	\end{block}

	\begin{itemize}
		\item \lstinline|time_since_epoch()| retourne la durée depuis l'epoch
		\item Opérateurs d'ajout et de suppression d'une durée
		\item Opérateurs de comparaison entre \lstinline|time_point|
		\item \lstinline|min()| retourne le plus petit temps relatif
		\item \lstinline|max()| retourne le plus grand temps relatif
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Horloges}
	\begin{itemize}
		\item \lstinline|std::chrono::system_clock| : horloge temps-réel du système
		\item \lstinline|now()| récupère temps courant
	\end{itemize}

	\begin{lstlisting}[language=C++]
system_clock::time_point today = system_clock::now();
today.time_since_epoch().count();\end{lstlisting}

	\begin{itemize}
		\item \lstinline|to_time_t()| converti en \lstinline|time_t|
		\item \lstinline|fromtime_t()| construit depuis \lstinline|time_t|
	\end{itemize}

	\begin{lstlisting}[language=C++]
system_clock::time_point today = system_clock::now();
time_t tt = system_clock::to_time_t(today);
ctime(&tt);\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Horloges}
	\begin{itemize}
		\item \lstinline|std::chrono::steady_clock| : horloge monotone de mesure des intervalles

\note[item]{Monotone, c'est à dire que cette horloge n'est jamais réglée, en particulier une mise à l'heure durant la mesure n'a pas d'impact sur la mesure}
\note[item]{Pas le cas de \lstinline|std::chrono::system_clock| qui mesure le temps par rapport à epoch et dont la valeur est impactée par la mise à l'heure}
\note[item]{A priori, sous Linux, pas d'appel système pour récupérer la valeur}

		\item \lstinline|now()| récupère temps courant
	\end{itemize}

	\begin{lstlisting}[language=C++]
steady_clock::time_point t1 = steady_clock::now();

...

steady_clock::time_point t2 = steady_clock::now();
duration<double> time_span = 
duration_cast<duration<double>>(t2 - t1);\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Horloges}
	\begin{itemize}
		\item \lstinline|std::chrono::high_resolution_clock| : horloge avec le plus petit intervalle entre deux \textit{ticks}
		\item Possible synonyme de \lstinline|std::chrono::system_clock| ou \lstinline|std::chrono::steady_clock|
	\end{itemize}

	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Préférez \lstinline|std::clock::duration| aux entiers pour manipuler les durées
		\end{itemize}

\note[item]{Meilleur sémantique et meilleur typage}
	\end{exampleblock}

	\begin{alertblock}{Attention}
		\begin{itemize}
			\item N'espérez pas une précision arbitrairement grande des horloges
		\end{itemize}

\note[item]{En particulier ne soyez pas certains de récupérer des durées précis à la nanoseconde sous prétexte qu'il y a une instanciation en nanosecondes}
	\end{alertblock}
\end{frame}

\subsection*{Multi-threading}
\begin{frame}[fragile]
	\frametitle{Thread Local Storage}
	\begin{itemize}
		\item Spécifieur de classe de stockage : \lstinline|thread_local|
		\item Influant sur la durée de stockage
		\item Compatible avec \lstinline|static| et \lstinline|extern|
		\item Rend propres au thread des objets normalement partagés

\note[item]{Typiquement des variables globales ou statiques}
\note[item]{c'est à dire qu'il y a une instance de la variable par thread}

		\item Instance propre au thread créée à la création du thread
		\item Valeur initiale héritée du thread créateur
	\end{itemize}

	\begin{lstlisting}[language=C++]
thread_local int foo = 0;\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Variables atomiques - \lstinline|std::atomic|}
	\begin{itemize}
		\item Encapsulation de types de base fournissant des opérations atomiques
		\item Atomicité de l'affectation, de l'incrémentation et de la décrémentation
	\end{itemize}

	\begin{lstlisting}[language=C++]
atomic<int> foo{5};
++foo; \end{lstlisting}

	\begin{itemize}
		\item \lstinline|store()| stocke une nouvelle valeur
		\item \lstinline|load()| lit la valeur
		\item \lstinline|exchange()| met à jour et retourne la valeur avant modification
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Variables atomiques - \lstinline|std::atomic|}
	\begin{itemize}
		\item \lstinline|compare_exchange_weak| et \lstinline|compare_exchange_strong| 

\note[item]{Différence \textit{weak} / \textit{strong} : \textit{weak} peu échouer dans certains cas. Lorsque cela se produit, aucune valeur n'est modifiée}

		\begin{itemize}
			\item Si \lstinline|std::atomic| est égal à la valeur attendue, il est mis à jour avec une valeur fournie
			\item Sinon, il n'est pas modifié et la valeur attendue prends la valeur de \lstinline|std::atomic|
		\end{itemize}
	\end{itemize}

	\begin{lstlisting}[language=C++]
atomic<int> foo{5};
int bar{5};

foo.compare_exchange_strong(bar, 10);
// foo : 10, bar : 5

foo.compare_exchange_strong(bar, 8);
// foo : 10, bar : 10\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Variables atomiques - \lstinline|std::atomic|}
	\begin{itemize}
		\item \lstinline|fetch_add()| addition et retour de la valeur avant modification
	\end{itemize}

	\begin{lstlisting}[language=C++]
atomic<int> foo{5};

cout << foo.fetch_add(10) << " ";
cout << foo;        // Affiche 5 15\end{lstlisting}

	\begin{itemize}
		\item \lstinline|fetch_sub()| soustraction et retour de la valeur avant modification
		\item \lstinline|fetch_and()| \og et\fg{} binaire et retour de la valeur avant modification
		\item \lstinline|fetch_or()| \og ou\fg{} binaire et retour de la valeur avant modification
		\item \lstinline|fetch_xor()| \og ou exclusif\fg{} et retour de la valeur avant modification
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Variables atomiques - \lstinline|std::atomic|}
	\begin{itemize}
		\item Plusieurs instanciations standards (\lstinline|std::atomic_bool|, \lstinline|std::atomic_int|, \ldots)
	\end{itemize}

	\begin{block}{Mais aussi}
		\begin{itemize}
			\item Plusieurs fonctions \og C-style\fg{}, similaires aux fonctions membres de \lstinline|std::atomic|, manipulant atomiquement des données
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Variables atomiques - \lstinline|std::atomic_flag|}
	\begin{itemize}
		\item Gestion atomique de \textit{flags}
		\item Non copiable, non déplaçable, \textit{lock free}
		\item \lstinline|clear()| remet à 0 le \textit{flag}
		\item \lstinline|test_and_set()| lève le \textit{flag} et retourne sa valeur avant modification
	\end{itemize}

	\begin{lstlisting}[language=C++]
atomic_flag foo = ATOMIC_FLAG_INIT;

foo.test_and_set();  // 0
foo.test_and_set();  // 1
foo.clear();
foo.test_and_set();  // 0\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Threads - \lstinline|std::thread|}
	\begin{itemize}
		\item Représente un fil d'exécution
		\item Déplaçable mais non copiable
		\item Constructible depuis une fonction et sa liste de paramètre
	\end{itemize}

	\begin{lstlisting}[language=C++]
void foo(int);

thread t(foo, 10);\end{lstlisting}

	\begin{itemize}
		\item Thread initialisé démarre immédiatement
		\item \lstinline|joignable()| indique si le thread est joignable
		\begin{itemize}
			\item Pas construit par défaut
			\item Pas été déplacé
			\item Ni joint ni détaché
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Threads - \lstinline|std::thread|}
	\begin{itemize}
		\item \lstinline|join()| attend la fin d'exécution du thread
		\item \lstinline|detach()| détache le thread
	\end{itemize}

	\begin{lstlisting}[language=C++]
void foo(int imax) {
  for(int i = 0; i < imax; ++i)
    cout << "thread " << i << '\n'; }

int imax = 40;
thread t(foo, imax);

for(int i = 0; i < imax; ++i)
  cout << "main " << i << '\n';
t.join();\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Threads - \lstinline|std::this_thread|}
	\begin{itemize}
		\item Représente le thread courant
		\item \lstinline|yield()| permet de \og passer son tour\fg{}

\note[item]{C'est à dire d'indiquer à l'ordonnanceur qu'il peut replanifier}

		\item \lstinline|sleep_for()| suspend l'exécution sur la durée spécifiée
	\end{itemize}

	\begin{lstlisting}[language=C++]
this_thread::sleep_for(chrono::seconds(5));\end{lstlisting}

	\begin{itemize}
		\item \lstinline|sleep_until()| suspend le thread jusqu'au temps demandé
	\end{itemize}

	\begin{alertblock}{Attention}
		\begin{itemize}
			\item Ne vous attendez pas à des attentes arbitrairement précises
		\end{itemize}

\note[item]{À l'échéance, le thread n'interrompt pas les autres pour reprendre la main}
	\end{alertblock}

	\begin{block}{Attentes passives}
		\begin{itemize}
			\item Les autres threads continuent de s'exécuter
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Mutex - \lstinline|std::mutex|}
	\begin{itemize}
		\item Verrou pour l'accès exclusif à une section de code
		\item \lstinline|lock()| verrouille le mutex (en attendant sa libération s'il est déjà verrouillé)
		\item \lstinline|try_lock()| verrouille le mutex s'il est libre, retourne \lstinline|false| sinon
		\item \lstinline|unlock()| relâche le mutex
	\end{itemize}

	\begin{alertblock}{Attention}
		\begin{itemize}
			\item \lstinline|lock()| sur un mutex verrouillé par le même thread provoque un \textit{deadlock}
		\end{itemize}
	\end{alertblock}

	\begin{itemize}
		\item \lstinline|std::recursive_mutex| variante verrouillable plusieurs fois par un même thread

\note[item]{Il faut le relâcher autant de fois pour qu'il soit effectivement non verrouillé}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Mutex - \lstinline|std::timed_mutex|}
	\begin{itemize}
		\item Similaire à \lstinline|std::mutex|
		\item \ldots{} proposant en complément des \textit{try lock} temporisés
		\item \lstinline|try_lock_for()| attend, si le mutex est verrouillé, la libération de celui-ci ou l'expiration d'une durée
		\item \lstinline|try_lock_until()| attend, si le mutex est verrouillé, la libération de celui-ci ou l'atteinte d'un temps
		\item \lstinline|std::recursive_timed_mutex| est une variante de \lstinline|std::timed_mutex| verrouillable plusieurs fois par un même thread
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Mutex - \lstinline|std::lock_guard|}
	\begin{itemize}
		\item Capsule RAII sur les mutex
		\item Constructible uniquement depuis un mutex
		\item Verrouille le mutex à la création et le relâche à la destruction
	\end{itemize}

	\begin{lstlisting}[language=C++]
mutex foo;
{
  lock_guard<mutex> bar(foo);  // Prise du mutex
  ...
}  // Liberation du mutex\end{lstlisting}

	\begin{block}{Note}
		\begin{itemize}
			\item Gestion du mutex entièrement confiée au \textit{lock}
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Mutex - \lstinline|std::unique_lock|}
	\begin{itemize}
		\item Capsule RAII des mutex
		\item Supporte les mutex verrouillés ou non
		\item Relâche le mutex à la destruction
		\item Expose les méthodes de verrouillage et libération des mutex
	\end{itemize}

	\begin{lstlisting}[language=C++]
mutex foo;
{
  unique_lock<mutex> bar(foo, defer_lock);
  ...
  bar.lock();  // Prise du mutex
  ...
}  // Liberation du mutex\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Mutex - \lstinline|std::unique_lock|}
	\begin{itemize}
		\item Comportements multiples à de la création
		\begin{itemize}
			\item Verrouillage immédiat
			\item Tentative de verrouillage
			\item Acquisition sans verrouillage
			\item Acquisition d'un mutex déjà verrouillé)
		\end{itemize}
		\item \lstinline|mutex()| retourne le mutex associé
		\item \lstinline|owns_lock()| teste si le \textit{lock} a un mutex associé et l'a verrouillé
		\item \lstinline|operator bool()| encapsule \lstinline|owns_lock()|
	\end{itemize}

	\begin{block}{Note}
		\begin{itemize}
			\item Gestion du mutex conservée, garantie de libération
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Mutex - Gestion multiple}
	\begin{itemize}
		\item \lstinline|std::lock()| verrouille tous les mutex passés en paramètre
		\item \ldots{} sans produire de \textit{deadlock}
	\end{itemize}

	\begin{lstlisting}[language=C++]
mutex foo, bar, baz;
lock(foo, bar, baz);\end{lstlisting}

	\begin{itemize}
		\item \lstinline|std::try_lock| tente de verrouiller dans l'ordre tous les mutex passés en paramètre
		\item \ldots{} et relâche les mutex déjà pris en cas d'échec sur l'un d'eux
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Mutex - \lstinline|std::call_once()|}
	\begin{itemize}
		\item Garantit l'appel unique (pour un \textit{flag} donnée) de la fonction en paramètre
		\item Si la fonction a déjà été exécutée, \lstinline|std::call_once()| retourne sans exécuter la fonction
		\item Si la fonction est en cours d'exécution, \lstinline|std::call_once()| attend la fin de cette exécution avant de retourner
	\end{itemize}

	\begin{lstlisting}[language=C++]
void foo(int, char);

once_flag flag;
call_once(flag, foo, 42, 'r');\end{lstlisting}

	\begin{block}{Cas d'utilisation}
		\begin{itemize}
			\item Appelle par un unique thread d'une fonction d'initialisation
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Variables conditionnelles - Principe}
	\begin{itemize}
		\item Mise en attente du thread sur la variable conditionnelle
		\item Réveil du thread lors de la notification de la variable
		\item Protection par verrou
		\begin{itemize}
			\item Prise du verrou avant l'appel à la fonction d'attente
			\item Relâchement du verrou par la fonction
			\item Reprise du verrou lors de la notification avant le déblocage du thread
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Variables conditionnelles - \lstinline|std::condition_variable|}
	\begin{itemize}
		\item Uniquement avec \lstinline|std::unique_lock|
		\item \lstinline|wait()| met en attente le thread
	\end{itemize}

	\begin{lstlisting}[language=C++]
mutex mtx;
condition_variable cv;

unique_lock<std::mutex> lck(mtx);
cv.wait(lck);\end{lstlisting}

	\begin{block}{Note}
		\begin{itemize}
			\item Possibilité de fournir un prédicat
			\begin{itemize}
				\item Blocage seulement s'il retourne \lstinline|false|
				\item Déblocage seulement s'il retourne \lstinline|true|
			\end{itemize}
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Variables conditionnelles - \lstinline|std::condition_variable|}
	\begin{itemize}
		\item \lstinline|wait_for()| met en attente le thread, au maximum la durée donnée
		\item \lstinline|wait_until()| met en attente le thread, au maximum jusqu'au temps donné
	\end{itemize}

	\begin{block}{Note}
		\begin{itemize}
			\item \lstinline|wait_for()| et \lstinline|wait_until()| indique si l'exécution a repris suite à un timeout
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Variables conditionnelles - \lstinline|std::condition_variable|}
	\begin{itemize}
		\item \lstinline|notify_one()| notifie un des threads en attente sur la variable conditionnelle
		\item \lstinline|notify_all()| notifie tous les threads en attente
	\end{itemize}

	\begin{alertblock}{Attention}
		\begin{itemize}
			\item Impossible de choisir quel thread notifié avec \lstinline|notify_one()|
		\end{itemize}
	\end{alertblock}

	\begin{itemize}
		\item \lstinline|std::condition_variable_any| similaire à \lstinline|std::condition_variable|
		\item \ldots{} sans être limité à \lstinline|std::unique_lock|
		\item \lstinline|std::notify_all_at_thread_exit()| 
		\begin{itemize}
			\item Indique de notifier tous les threads à la fin du thread courant
			\item Prend un verrou qui sera libéré à la fin du thread
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Variables conditionnelles - \lstinline|std::condition_variable|}
	\begin{lstlisting}[language=C++]
mutex mtx;
condition_variable cv;

void print_id(int id) {
  unique_lock<std::mutex> lck(mtx);
  cv.wait(lck);
  cout << "thread " << id << '\n'; }

thread threads[10];
for(int i = 0; i<10; ++i)
  threads[i] = thread(print_id, i);
this_thread::sleep_for(chrono::seconds(5));
cv.notify_all();
for(auto& th : threads) th.join();\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Futures \& promise - Principe}
	\begin{itemize}
		\item \lstinline|std::promise| contient une valeur
		\begin{itemize}
			\item Disponible ultérieurement
			\item Récupérable, éventuellement dans un autre thread, via \lstinline|std::future|
		\end{itemize}
		\item \lstinline|std::future| permet la récupération d'une valeur disponible ultérieurement
		\begin{itemize}
			\item Depuis un \lstinline|std::promise|
			\item Depuis un appel asynchrone ou différé de fonction
		\end{itemize}
		\item Mécanismes asynchrones
		\item \lstinline|std::future| définissent des points de synchronisation
	\end{itemize}

	\begin{block}{Note}
		\begin{itemize}
			\item \lstinline|std::promise| et \lstinline|std::future| peuvent également manipuler des exceptions
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Futures \& promise - \lstinline|std::future|}
	\begin{itemize}
		\item Utilisable uniquement s'il est valide (associé à un état partagé)
		\item Construit valide que par certaines fonctions fournisseuses
		\item Déplaçable mais non copiable
		\item Prêt lorsque la valeur, ou une exception, est disponible
		\item \lstinline|valid()| teste s'il est valide
		\item \lstinline|wait()| attend qu'il soit prêt
		\item \lstinline|wait_for()| attend qu'il soit prêt, au plus la durée donnée
		\item \lstinline|wait_until()| attend qu'il soit prêt, au plus jusqu'au temps donné
		\item \lstinline|get()| attend qu'il soit prêt, retourne la valeur (ou lève l'exception) et libère l'état partagé
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Futures \& promise - \lstinline|std::future|}
	\begin{itemize}
		\item \lstinline|share()| construit un \lstinline|std::shared_future| depuis le \lstinline|std::future|
	\end{itemize}

	\begin{alertblock}{Attention}
		\begin{itemize}
			\item Après un appel à \lstinline|share()|, le \lstinline|std:future| n'est plus valide
		\end{itemize}
	\end{alertblock}

	\begin{itemize}
		\item \lstinline|std::shared_future| similaires à \lstinline|std::future|
		\begin{itemize}
			\item Mais copiables
			\item Responsabilité partagée sur l'état partagé
			\item Valeur lisible à plusieurs reprises
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Futures \& promise - \lstinline|std::async()|}
	\begin{itemize}
		\item Appelle la fonction fournie
		\item Et retourne, sans attendre la fin de l'exécution, un \lstinline|std::future|
		\item \lstinline|std::future| permet de récupérer la valeur de retour de la fonction
	\end{itemize}

	\begin{block}{Note}
		\begin{itemize}
			\item Deux politiques d'exécution de la fonction appelée
			\begin{itemize}
				\item Exécution asynchrone
				\item Exécution différée à l'appel de \lstinline|wait()| ou \lstinline|get()|
			\end{itemize}
			\item Par défaut le choix est laissé à l'implémentation
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Futures \& promise - \lstinline|std::async()|}
	\begin{lstlisting}[language=C++]
int foo() {
  this_thread::sleep_for(chrono::seconds(5));
  return 10; }

future<int> bar = async(launch::async, foo);
...
cout << bar.get() << "\n";\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Futures \& promise - \lstinline|std::promise|}
	\begin{itemize}
		\item Objet que l'on promet de valoriser ultérieurement
		\item Déplaçable mais non copiable
		\item Partage un état avec le \lstinline|std::future| associé
		\item \lstinline|get_future()| retourne le \lstinline|std::future| associé
	\end{itemize}

	\begin{alertblock}{Attention}
		\begin{itemize}
			\item Un seul \lstinline|std::future| par \lstinline|std::promise| peut être récupéré
		\end{itemize}
	\end{alertblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Futures \& promise - \lstinline|std::promise|}
	\begin{itemize}
		\item \lstinline|set_value()| affecte une valeur et passe l'état partagé à prêt
		\item \lstinline|set_exception()| affecte une exception et passe l'état partagé à prêt
		\item \lstinline|set_value_at_thread_exit()| affecte une valeur, l'état partagé passera à prêt à la fin du thread
		\item \lstinline|set_exception_at_thread_exit()| affecte une exception, l'état partagé passera à prêt à la fin du thread
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Futures \& promise - \lstinline|std::promise|}
	\begin{lstlisting}[language=C++]
void foo(future<int>& fut) {
  int x = fut.get();
  cout << x << '\n'; }

promise<int> prom;
future<int> fut = prom.get_future();
thread th1(foo, ref(fut));
...
prom.set_value(10);
th1.join();\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Futures \& promise - \lstinline|std::packaged_task|}
	\begin{itemize}
		\item Encapsulation d'un appelable similaire à \lstinline|std::function|
		\item \ldots{} dont la valeur de retour est récupérable par un \lstinline|std::future|
		\item Partage un état avec le \lstinline|std::future| associé
		\item \lstinline|valid()| teste s'il est associé à un état partagé (contient un appelable)
		\item \lstinline|get_future()| retourne le \lstinline|std::future| associé
	\end{itemize}

	\begin{alertblock}{Attention}
		\begin{itemize}
			\item Un seul \lstinline|std::future| par \lstinline|std::packaged_task| peut être récupéré
		\end{itemize}
	\end{alertblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Futures \& promise - \lstinline|std::packaged_task|}
	\begin{itemize}
		\item \lstinline|operator()| appelle l'appelable, affecte sa valeur de retour (ou l'exception levée) au \lstinline|std::future| et passe l'état partagé à prêt
		\item \lstinline|reset()| réinitialise l'état partagé en conservant l'appelable
	\end{itemize}

	\begin{block}{note}
		\begin{itemize}
			\item \lstinline|reset()| permet d'appeler une nouvelle fois l'appelable
		\end{itemize}
	\end{block}

	\begin{itemize}
		\item \lstinline|make_ready_at_thread_exit()| appelle l'appelable et affecte sa valeur de retour (ou l'exception levée), l'état partagé passera à prêt à la fin
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Futures \& promise - \lstinline|std::packaged_task|}
	\begin{lstlisting}[language=C++]
void foo(future<int>& fut) {
  int x = fut.get();
  cout << x << '\n'; }

int bar() { return 10; }

packaged_task<int()> tsk(bar);
future<int> fut = tsk.get_future();
thread th1(foo, std::ref(fut));
...
tsk();
th1.join();\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Conclusion}
	\begin{exampleblock}{Do (dans cet ordre)}
		\begin{itemize}
			\item Évitez de partager variables et ressources
			\item Préférez les partages en lecture seule
			\item Préférez les structures de données gérant les accès concurrents

\note[item]{\lstinline|std::atomic|, conteneur \textit{lock-free}, conteneur \textit{thread-safe}, etc.}

			\item Protégez l'accès par mutex ou autres barrières
		\end{itemize}
	\end{exampleblock}

	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Encapsulez les mutex dans des \lstinline|std::lock_guard| ou \lstinline|std::unique_lock|
		\end{itemize}
	\end{exampleblock}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Conclusion}
	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Analysez vos cas d'utilisation pour choisir le bon outil
		\end{itemize}
	\end{exampleblock}

	\begin{alertblock}{Attention}
		\begin{itemize}
			\item Très faibles garanties de \textit{thread-safety} de la part des conteneurs standards
		\end{itemize}

\note[item]{En gros plusieurs threads peuvent lire un même conteneur et plusieurs threads peuvent lire ou écrire simultanément des conteneurs différents sans problème et c'est à peu prés tout}
\note[item]{Mais telle ou telle implémentation peuvent proposer mieux}
	\end{alertblock}

	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Boost.Lockfree pour des structures de données \textit{thread-safe} et \textit{lock-free}
		\end{itemize}
	\end{exampleblock}

	\begin{block}{Pour aller plus loin}
		\begin{itemize}
			\item \cite{ConcInAction} d'Anthony Williams
		\end{itemize}

\note[item]{Anthony Williams est coauteur des propositions de \textit{multi-threading} dans C++11 et co-auteur de Boost.Thread}
	\end{block}
\end{frame}

\subsection*{Expressions rationnelles}
\begin{frame}[fragile]
	\frametitle{Expressions rationnelles (regex)}
	\begin{itemize}
		\item \lstinline|std::basic_regex| représente une expression rationnelle
		\item Instanciations standards \lstinline|std::regex| et \lstinline|std::wregex|
		\item Construite depuis une chaîne représentant l'expression
		\item \ldots{} et des drapeaux de configuration
		\begin{itemize}
			\item Grammaire : \underline{ECMAScript}, basic POSIX, extended POSIX, awk, grep, egrep
			\item Case sensitive ou non
			\item Prise en compte de la locale
			\item \ldots
		\end{itemize}
	\end{itemize}

	\begin{lstlisting}[language=C++]
regex foo("[0-9A-Z]+", icase);\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Expressions rationnelles (regex)}
	\begin{itemize}
		\item\lstinline|std::regex_search()| : recherche
	\end{itemize}

	\begin{lstlisting}[language=C++]
regex r("[0-9]+");
regex_search(string("123"), r);         // true
regex_search(string("abcd123efg"), r);  // true
regex_search(string("abcdefg"), r);     // false\end{lstlisting}

	\begin{itemize}
		\item \lstinline|std::regex_match()| : vérification de correspondance
	\end{itemize}

	\begin{lstlisting}[language=C++]
regex r("[0-9]+");
regex_match(string("123"), r);          // true
regex_match(string("abcd123efg"), r);   // false
regex_match(string("abcdefg"), r);      // false\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Expressions rationnelles (regex)}
	\begin{itemize}
		\item Capture de sous-expressions dans \lstinline|std::match_results|
		\item Instanciations standards \lstinline|std::cmatch|, \lstinline|std::wcmatch|, \lstinline|std::smatch| et \lstinline|std::wsmatch|
		\item \lstinline|empty()| teste la vacuité de la capture
		\item \lstinline|size()| retourne le nombre de captures
		\item Itérateurs sur les captures
		\item Sur chaque élément capturé
		\begin{itemize}
			\item \lstinline|str()| : la chaîne capturée
			\item \lstinline|length()| : sa longueur
			\item \lstinline|position()| : sa position dans la chaîne de recherche
			\item \lstinline|suffix()| : la séquence de caractères suivant la capture
			\item \lstinline|prefix()| : la séquence de caractères précédant la capture
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Expressions rationnelles (regex)}
	\begin{lstlisting}[language=C++]
string s("abcd123efg");
regex r("[0-9]+");
smatch m;

regex_search(s, m, r);
m.size();       // 1
m.str(0);       // 123
m.position(0);  // 4
m.prefix();     // abcd
m.suffix();     // efg\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Expressions rationnelles (regex)}
	\begin{itemize}
		\item Fonction de remplacement : \lstinline|std::regex_replace()|
	\end{itemize}

	\begin{lstlisting}[language=C++]
string s("abcd123efg");
regex r("[0-9]+");
regex_replace(s, r, "-"); // abcd-efg\end{lstlisting}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:27,positionColumn:1,positionLineNumber:27,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%23include+%3Cstring%3E%0A%23include+%3Cregex%3E%0A%0Aint+main()%0A%7B%0A++%7B%0A++++std::string+s(%22abcd123efg%22)%3B%0A++++std::regex+r(%22%5B0-9%5D%2B%22)%3B%0A++++std::smatch+m%3B%0A%0A++++std::regex_search(s,+m,+r)%3B%0A++++std::cout+%3C%3C+m.size()+%3C%3C+!'%5Cn!'%3B%0A++++std::cout+%3C%3C+m.str(0)+%3C%3C+!'%5Cn!'%3B%0A++++std::cout+%3C%3C+m.position(0)+%3C%3C+!'%5Cn!'%3B%0A++++std::cout+%3C%3C+m.prefix()+%3C%3C+!'%5Cn!'%3B%0A++++std::cout+%3C%3C+m.suffix()+%3C%3C+!'%5Cn!'%3B%0A++%7D%0A%0A++%7B%0A++++std::string+s(%22abcd123efg%22)%3B%0A++++std::regex+r(%22%5B0-9%5D%2B%22)%3B%0A%0A++++std::cout+%3C%3C+std::regex_replace(s,+r,+%22-%22)+%3C%3C+!'%5Cn!'%3B%0A++%7D%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Expressions rationnelles (regex)}
	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Préférez les expressions rationnelles aux analyseurs \og à la main\fg{}
		\end{itemize}
	\end{exampleblock}

	\begin{alertblock}{Don't}
		\begin{itemize}
			\item N'utilisez pas les expressions rationnelles pour les traitements triviaux
			\item Préférez les algorithmes
		\end{itemize}

\note[item]{Traitements triviaux : recherche d'un caractère particulier, passage en majuscule, récupération des n premiers caractères}
 	\end{alertblock}

	\begin{block}{Conseil}
		\begin{itemize}
			\item Encapsulez les expressions rationnelles ayant une sémantique claire et utilisées plusieurs fois dans une fonction dédiée au nom évocateur
		\end{itemize}
	\end{block}

	\begin{block}{Performance}
		\begin{itemize}
			\item Construction très couteuse de l'expression rationnelle
		\end{itemize}
	\end{block}
\end{frame}

\subsection*{Nombres aléatoires}
\begin{frame}[fragile]
	\frametitle{Nombres aléatoires}
	\begin{itemize}
		\item Générateurs pseudo-aléatoires initialisés par une graine (congruence linéaire, Mersenne, \ldots)
		\item Générateur aléatoire
	\end{itemize}

	\begin{alertblock}{Attention}
		\begin{itemize}
			\item Peut ne pas être présent sur certaines implémentations
			\item Peut être un générateur pseudo-aléatoire (entropie nulle) sur d'autres
		\end{itemize}
	\end{alertblock}

	\begin{itemize}
		\item Distributions adaptant la séquence d'un générateur pour respecter une distribution particulière (uniforme, normale, binomiale, de Poisson, \ldots)
		\item Fonction de normalisation ramenant la séquence générée dans [0,1)
	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Nombres aléatoires}
	\begin{lstlisting}[language=C++]
default_random_engine gen;
uniform_int_distribution<int> distribution(0,9);
gen.seed(system_clock::now().time_since_epoch().count());

// Nombre aleatoire entre 0 et 9
distribution(gen);\end{lstlisting}

	\begin{exampleblock}{Do}
		\begin{itemize}
			\item Préférez ces générateurs et distributions à \lstinline|rand()|
		\end{itemize}
	\end{exampleblock}

	\begin{block}{Quiz}
		Comment générer un tirage équiprobable entre 6 et 42 avec \lstinline|rand()|
	\end{block}

	\vskip 10mm plus 10fill
	\hfill
	\href{https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(filename:'1',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,selection:(endColumn:1,endLineNumber:13,positionColumn:1,positionLineNumber:13,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Ciostream%3E%0A%23include+%3Crandom%3E%0A%23include+%3Cchrono%3E%0A%0Aint+main()%0A%7B%0A++std::default_random_engine+generator%3B%0A++std::uniform_int_distribution%3Cint%3E+distribution(0,9)%3B%0A%0A++generator.seed(std::chrono::system_clock::now().time_since_epoch().count())%3B%0A++std::cout+%3C%3C+distribution(generator)+%3C%3C+!'%5Cn!'%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:executor,i:(argsPanelShown:'1',compilationPanelShown:'0',compiler:g122,compilerName:'',compilerOutShown:'0',execArgs:'',execStdin:'',fontScale:14,fontUsePx:'0',j:1,lang:c%2B%2B,libs:!((name:boost,ver:'175')),options:'-std%3Dc%2B%2B11+-Wall+-Wextra',source:1,stdinPanelShown:'1',tree:'1',wrap:'0'),l:'5',n:'0',o:'Executor+x86-64+gcc+12.2+(C%2B%2B,+Editor+%231)',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4}{\includegraphics[height=0.5cm]{input_src/play-button.png}}
\end{frame}
\end{document}